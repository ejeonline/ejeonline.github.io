<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="低端码农技术整理，如有疑问欢迎大佬指正，联系邮箱78606393@qq.com"><title>Java常用设计模式 | 二开的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java常用设计模式</h1><a id="logo" href="/.">二开的博客</a><p class="description">二营长等你很久了！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java常用设计模式</h1><div class="post-meta">Mar 21, 2019<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言："><span class="toc-number">1.</span> <span class="toc-text">前言：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一、工厂方法模式："><span class="toc-number">2.</span> <span class="toc-text">一、工厂方法模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、抽象工厂模式："><span class="toc-number">3.</span> <span class="toc-text">二、抽象工厂模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、建造者模式："><span class="toc-number">4.</span> <span class="toc-text">三、建造者模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、单例模式："><span class="toc-number">5.</span> <span class="toc-text">四、单例模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、适配器模式："><span class="toc-number">6.</span> <span class="toc-text">五、适配器模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、装饰器模式："><span class="toc-number">7.</span> <span class="toc-text">六、装饰器模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、策略模式："><span class="toc-number">8.</span> <span class="toc-text">七、策略模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#八、模板方法模式："><span class="toc-number">9.</span> <span class="toc-text">八、模板方法模式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#九、观察者模式："><span class="toc-number">10.</span> <span class="toc-text">九、观察者模式：</span></a></li></ol></div></div><div class="post-content"><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>在Java中，传说有23中模式，总共分为三大类，分别是：</p>
<ul>
<li><strong>创建型</strong>模式(5种)：<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>建造者模式</strong>、<strong>单例模式</strong>、原型模式；</li>
<li>结构型模式(7种)：<strong>适配器模式</strong>、<strong>装饰器模式</strong>、代理模式、外观模式、桥接模式、组合模式、享元模式；</li>
<li>行为型模式(11种)：<strong>策略模式</strong>、<strong>模板方法模式</strong>、<strong>观察者模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<h3 id="一、工厂方法模式："><a href="#一、工厂方法模式：" class="headerlink" title="一、工厂方法模式："></a>一、工厂方法模式：</h3><p>工厂是干嘛的，就是用来生产的嘛，这里说的工厂也是用来生产的，它是用来生产对象的。也就是说，有些对象我们可以在工厂里面生产，需要用时直接从工厂里面拿出来即可，而不用每次需要用的时候都去new对象。工厂方法模式又分为以下三种：</p>
<ul>
<li><strong>普通工厂模式：</strong>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</li>
<li><strong>多个工厂方法模式：</strong>是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。</li>
<li><strong>静态工厂方法模式：</strong>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</li>
</ul>
<p>上面三个模式中，后一个都是对前一个的改良。下面分别看看这三个模式的具体案例。</p>
<p><strong>情景：</strong>有一个发送消息的接口，有两个实现类，一个是发送短信，一个是发送邮件。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line">public interface Sender &#123;</span><br><span class="line">  public <span class="keyword">void</span> Send();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//实现一</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="title">implements</span> <span class="title">Sender</span> </span>&#123; </span><br><span class="line">  @Override</span><br><span class="line">  public <span class="keyword">void</span> Send() &#123;</span><br><span class="line">     System.out.println(<span class="string">"this is mail sender!"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//实现二</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="title">implements</span> <span class="title">Sender</span> </span>&#123; </span><br><span class="line">  @Override</span><br><span class="line">  public <span class="keyword">void</span> Send() &#123; </span><br><span class="line">     System.out.println(<span class="string">"this is sms sender!"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就看看用这三种工厂方法模式分别要怎么做。</p>
<ul>
<li><strong>普通工厂模式：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123; </span><br><span class="line">   public Sender produce(<span class="built_in">String</span> type) &#123; </span><br><span class="line">       <span class="keyword">if</span> (<span class="string">"mail"</span>.equals(type)) &#123; </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"sms"</span>.equals(type)) &#123; </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SmsSender(); </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">           System.out.println(<span class="string">"请输入正确的类型!"</span>); </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候就创建这个工厂的对象，调用produce方法，需要发邮件就传入”mail”，需要发短信就传入”sms”，如果传入的是别的内容，就不会创建任何对象。</p>
<ul>
<li><strong>多个工厂方法模式：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123; </span><br><span class="line">   public Sender produceMail()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">   &#125;</span><br><span class="line">   public Sender produceSms()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通工厂模式生产对象都是在一个方法内完成，多个工厂方法模式是提供多个方法，分别生产对应的对象。使用时先创建工厂的实例，要发短信就调用生产短信实例的方法，要发邮件就调用生产邮件实例的方法。</p>
<ul>
<li><strong>静态工厂方法模式：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">  public <span class="keyword">static</span> Sender produceMail()&#123;   </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> MailSender(); </span><br><span class="line">  &#125; </span><br><span class="line">  public <span class="keyword">static</span> Sender produceSms()&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是多个工厂方法模式里面的方法设为静态的，这样可以直接通过工厂类的类名调用，更加方便。</p>
<h3 id="二、抽象工厂模式："><a href="#二、抽象工厂模式：" class="headerlink" title="二、抽象工厂模式："></a>二、抽象工厂模式：</h3><p>上面的工厂方法模式有一个缺点，就是类的创建依赖工厂类，比如现在还可以用微信发消息，那么就得在工厂类中新增一个创建WeChat实体的方法。这样就违背了开闭原则。如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，就不需要修改之前的工厂类代码。 上面的案例代码就可以修改成下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂类接口</span></span><br><span class="line">public interface Provider &#123;</span><br><span class="line">    public Sender produce();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产SmsSender对象的工厂</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendSmsFactory</span> <span class="title">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">  @Override</span><br><span class="line">   public Sender produce() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产MailSender对象的工厂</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendMailFactory</span> <span class="title">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public Sender produce() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">       Provider provider = <span class="keyword">new</span> SendMailFactory();</span><br><span class="line">       Sender sender = provider.produce(); </span><br><span class="line">       sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样即使要新增生产WechatSender实例的方法，也不需要修改现有代码，只需实现工厂接口，重写生产方法即可。从工厂方法模式到抽象工厂模式，后者更加体现了Java的封装、抽象等思想。</p>
<h3 id="三、建造者模式："><a href="#三、建造者模式：" class="headerlink" title="三、建造者模式："></a>三、建造者模式：</h3><p>工厂模式提供的是创建单个类实例的模式，而建造者模式可以理解为是批量生产。还是使用工厂方法模式中的情景，看看用建造者模式怎么实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建造类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123; </span><br><span class="line">   private List&lt;Sender&gt; list = <span class="keyword">new</span> ArrayList&lt;Sender&gt;();</span><br><span class="line">   public <span class="keyword">void</span> produceMailSender(int count) &#123; <span class="comment">// 生产count个MailSender</span></span><br><span class="line">      <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> MailSender());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public <span class="keyword">void</span> produceSmsSender(int count) &#123; <span class="comment">// 生产count个SmsSender</span></span><br><span class="line">      <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> SmsSender());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* =========================== 使用 ============================*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestBuilder</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">      Builder builder = <span class="keyword">new</span> Builder();</span><br><span class="line">      builder.produceMailSender(<span class="number">10</span>); <span class="comment">// 生产10个MailSender</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、单例模式："><a href="#四、单例模式：" class="headerlink" title="四、单例模式："></a>四、单例模式：</h3><p>什么叫单例，就是保证一个类在内存中只有一个对象。Runtime()方法就是单例设计模式进行设计的。如何保证内存中只有一个对象呢？  <strong>设计思路：</strong></p>
<ul>
<li>不让其他程序创建该类对象。</li>
<li>在本类中创建一个本类对象。</li>
<li>对外提供方法，让其他程序获取这个对象。</li>
</ul>
<p><strong>实现步骤：</strong></p>
<ul>
<li>私有化构造函数；</li>
<li>创建私有并静态的本类对象；</li>
<li>定义公有并静态的方法，返回该对象。</li>
</ul>
<p><strong>代码实现：</strong></p>
<ul>
<li>懒汉式：延迟加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    private Single()&#123;&#125; <span class="comment">// 将构造方法私有化</span></span><br><span class="line">    private <span class="keyword">static</span> Single s = <span class="literal">null</span>; <span class="comment">// 私有静态的本类对象</span></span><br><span class="line">    public <span class="keyword">static</span> synchronized Single getInstance()&#123; <span class="comment">// 静态公共的返回对象的方法</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">null</span>)</span><br><span class="line">            s = <span class="keyword">new</span> Single();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>饿汉式：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    private Single()&#123;&#125; <span class="comment">//私有化构造函数。</span></span><br><span class="line">    private <span class="keyword">static</span> Single s = <span class="keyword">new</span> Single(); <span class="comment">//创建私有并静态的本类对象。</span></span><br><span class="line">    public <span class="keyword">static</span> Single getInstance()&#123; <span class="comment">//定义公有并静态的方法，返回该对象。</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、适配器模式："><a href="#五、适配器模式：" class="headerlink" title="五、适配器模式："></a>五、适配器模式：</h3><p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为以下三类：</p>
<ul>
<li>类的适配器模式：比如一个类有一个方法method1，但是客户端使用的时候还需要一个method2方法，那就可以将method1和method2方法写进接口中，然后新建一个适配器类继承原来的类并实现这个接口。</li>
<li>对象的适配器模式：与类适配器相比，不需再继承source类，而是将source的对象传过去。</li>
<li>接口的适配器模式</li>
</ul>
<p>看一下具体用代码怎么体现：</p>
<ul>
<li>类的适配器模式：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">void</span> method1() &#123;</span><br><span class="line">     System.out.println(<span class="string">"这是method1方法"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建接口</span></span><br><span class="line">public interface Targetable &#123; </span><br><span class="line">   <span class="comment">/* 与原类中的方法相同 */</span> </span><br><span class="line">   public <span class="keyword">void</span> method1();  </span><br><span class="line">   <span class="comment">/* 新类的方法 */</span></span><br><span class="line">   public <span class="keyword">void</span> method2(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 适配类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="title">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public <span class="keyword">void</span> method2() &#123; </span><br><span class="line">      System.out.println(<span class="string">"这是method2方法"</span>); </span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* ===================== 使用 ======================*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">      Targetable target = <span class="keyword">new</span> Adapter(); </span><br><span class="line">      target.method1(); </span><br><span class="line">      target.method2(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象的适配器模式：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">void</span> method1() &#123;</span><br><span class="line">     System.out.println(<span class="string">"这是method1方法"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line">public interface Targetable &#123;</span><br><span class="line">   <span class="comment">/* 与原类中的方法相同 */</span></span><br><span class="line">   public <span class="keyword">void</span> method1();</span><br><span class="line">   <span class="comment">/* 新类的方法 */</span></span><br><span class="line">   public <span class="keyword">void</span> method2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="title">implements</span> <span class="title">Targetable</span> </span>&#123; </span><br><span class="line">   private Source source;</span><br><span class="line">   public Wrapper(Source source) &#123; </span><br><span class="line">      <span class="keyword">super</span>(); </span><br><span class="line">      <span class="keyword">this</span>.source = source;</span><br><span class="line">   &#125; </span><br><span class="line">   @Override</span><br><span class="line">   public <span class="keyword">void</span> method2() &#123;</span><br><span class="line">      System.out.println(<span class="string">"this is the targetable method!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public <span class="keyword">void</span> method1() &#123;</span><br><span class="line">       source.method1();</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ======================= 使用 =========================*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">      Source source = <span class="keyword">new</span> Source();</span><br><span class="line">      Targetable target = <span class="keyword">new</span> Wrapper(source);</span><br><span class="line">      target.method1();</span><br><span class="line">      target.method2();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与类的适配器模式不同的是，对象的适配器模式不再继承source类，而是直接将source对象传到Wrapper类就可以了。   </p>
<ul>
<li>接口的适配器模式</li>
</ul>
<p>接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。</p>
<h3 id="六、装饰器模式："><a href="#六、装饰器模式：" class="headerlink" title="六、装饰器模式："></a>六、装饰器模式：</h3><p>装饰模式就是给一个对象动态的增加一些新的功能。要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。 这样说得也很抽象，看看具体的案例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line">public interface Sourceable &#123;</span><br><span class="line">    public <span class="keyword">void</span> method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被装饰的类，实现Sourceable接口</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="title">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> method() &#123;</span><br><span class="line">        System.out.println(<span class="string">"the original method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 装饰的类，也要实现Sourceable 接口</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="title">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">    private Sourceable source; <span class="comment">// 持有被装饰类的对象</span></span><br><span class="line">    public Decorator(Sourceable source) &#123;</span><br><span class="line">         <span class="keyword">super</span>();</span><br><span class="line">         <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> method() &#123;</span><br><span class="line">         System.out.println(<span class="string">"before decorator!"</span>); <span class="comment">// 装饰</span></span><br><span class="line">         source.method(); </span><br><span class="line">         System.out.println(<span class="string">"after decorator!"</span>); <span class="comment">// 装饰</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">         Sourceable source = <span class="keyword">new</span> Source();</span><br><span class="line">         Sourceable obj = <span class="keyword">new</span> Decorator(source);</span><br><span class="line">         obj.method();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IO流体系中很多类就用到了这种设计模式。</p>
<h3 id="七、策略模式："><a href="#七、策略模式：" class="headerlink" title="七、策略模式："></a>七、策略模式：</h3><p>策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。看看具体的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line">public interface Strategy &#123;</span><br><span class="line">    public <span class="keyword">void</span> strategyInterface();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略类A</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="title">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> strategyInterface() &#123;</span><br><span class="line">        <span class="comment">// 相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略类B</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="title">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> strategyInterface() &#123;</span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用策略的类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    public Context(Strategy strategy)&#123; <span class="comment">// 构造函数，传入一个具体策略对象</span></span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">void</span> contextInterface()&#123; <span class="comment">// 策略方法</span></span><br><span class="line">        strategy.strategyInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建Context类对象的时候，需要使用哪个策略就传入该策略，然后就可以使用。</p>
<h3 id="八、模板方法模式："><a href="#八、模板方法模式：" class="headerlink" title="八、模板方法模式："></a>八、模板方法模式：</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。简单的说就是很多相同的步骤，只是在某一些地方有差别，那么就可以使用这种模式。看例子：</p>
<ul>
<li>获取一段程序运行时间的模板：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract <span class="class"><span class="keyword">class</span> <span class="title">GetTime</span></span>&#123;</span><br><span class="line">      public long getTime()&#123;</span><br><span class="line">         long  start = System.currentTimeMillis;</span><br><span class="line">         <span class="comment">//表示要计算运行时间的代码</span></span><br><span class="line">         code();</span><br><span class="line">         long  end = System.currentTimeMillis;</span><br><span class="line">         <span class="keyword">return</span> end-start;</span><br><span class="line">      &#125;</span><br><span class="line">      public abstract <span class="keyword">void</span> code(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用该模板：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">forDemo</span> <span class="keyword">extends</span> <span class="title">GetTime</span></span>&#123;</span><br><span class="line">     <span class="comment">//重写抽象方法</span></span><br><span class="line">     public <span class="keyword">void</span> code()&#123;</span><br><span class="line">          <span class="keyword">for</span>(int x=<span class="number">0</span>;x&lt;<span class="number">1000</span>;x++)&#123;</span><br><span class="line">                 System.out.println(x);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">     GetTime gt=<span class="keyword">new</span> forDemo();</span><br><span class="line">     gt.getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以计算那个for循环运行的时间了。</p>
<h3 id="九、观察者模式："><a href="#九、观察者模式：" class="headerlink" title="九、观察者模式："></a>九、观察者模式：</h3><p>在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新，这就是观察者模式。  <strong>情景：</strong>有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。  示例代码：</p>
<ul>
<li>定义一个被观察者接口：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface BeObserverd &#123;</span><br><span class="line">    public <span class="keyword">void</span> registerObserver(Observer o);<span class="comment">// 添加观察者</span></span><br><span class="line">    public <span class="keyword">void</span> removeObserver(Observer o);<span class="comment">// 删除观察者</span></span><br><span class="line">    public <span class="keyword">void</span> notifyObserver();<span class="comment">// 通知观察者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个观察者接口：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> message);<span class="comment">// 当被观察者发出通知时，这个方法就会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义被观察者，实现了BeObserverd接口，对BeObserverd接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被观察者，也就是微信公众号服务实现了BeObserverd接口，对BeObserverd接口的三个方法进行了具体实现</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WechatServer</span> <span class="title">implements</span> <span class="title">BeObserverd</span> </span>&#123;</span><br><span class="line">    private List&lt;Observer&gt; list;</span><br><span class="line">    private <span class="built_in">String</span> message;</span><br><span class="line">    public WechatServer() &#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;(); <span class="comment">// 观察者的集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新增观察者</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> registerObserver(Observer o) &#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除观察者</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> removeObserver(Observer o) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())</span><br><span class="line">            list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给观察者发通知</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> notifyObserver() &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            Observer observer = list.get(i);</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟公众号推送消息的方法</span></span><br><span class="line">    public <span class="keyword">void</span> setInfomation(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = s;</span><br><span class="line">        System.out.println(<span class="string">"微信服务更新消息： "</span> + s);</span><br><span class="line">        <span class="comment">//消息更新，通知所有观察者</span></span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义具体观察者，微信公众号的具体观察者为用户User。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="title">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    private <span class="built_in">String</span> message;</span><br><span class="line">    public User(<span class="built_in">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">        public <span class="keyword">void</span> read() &#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 收到推送消息： "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如现有三个人关注公众号，当微信公众号调用setInfomation方法发送推文时，通过调用notifyObserver方法，通知每个观察者，在notifyObserver方法里调用update方法，update里面调用read方法，三个人都能收到推送；加入现在有人取消关注了，那么就会调用removeObserver方法，下次推送这个人就收不到了。(本案例参考<a href="https://www.cnblogs.com/luohanguo/p/7825656.html" target="_blank" rel="noopener">罗汉果</a>的博文，感谢大神整理！)</p>
</div><iframe src="/donate/?AliPayQR=/img/al.png&amp;WeChatQR=/img/wx.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/面试/">面试</a></div><div class="post-nav"><a class="pre" href="/2019/03/25/spring容器启动的加载过程/">spring容器启动的加载过程</a><a class="next" href="/2019/03/21/mysql整理/">mysql整理</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础/">Java基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring/">Spring</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小技能/">小技能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/环境搭建/">环境搭建</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/破解/">破解</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/">面试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Auto-js/" style="font-size: 15px;">Auto.js</a> <a href="/tags/环境搭建/" style="font-size: 15px;">环境搭建</a> <a href="/tags/EFK/" style="font-size: 15px;">EFK</a> <a href="/tags/ElasticSearch/" style="font-size: 15px;">ElasticSearch</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/资源-软件破解/" style="font-size: 15px;">资源-软件破解</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Java基础/" style="font-size: 15px;">Java基础</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/pinpoint/" style="font-size: 15px;">pinpoint</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/springboot/" style="font-size: 15px;">springboot</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/21/一键部署springboot项目到docker/">一键部署springboot项目到docker</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/17/VMware安装黑苹果踩坑/">VMware安装黑苹果踩坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/19/Java基础整理/">Java基础整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/16/Navicat-12激活/">Navicat 12激活</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/06/SpringBoot学习-03-在IDEA上本地更新远程项目/">SpringBoot学习-03.在IDEA上本地更新远程项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/05/ThreadLocal理解/">ThreadLocal理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/05/SpringBoot学习-02-在IDEA上实现项目的远程调试/">SpringBoot学习-02.在IDEA上实现项目的远程调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/05/SpringBoot学习-01-实现微信接入/">SpringBoot学习-01.实现微信接入</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/03/Auto-js学习/">Auto.js学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/文件对比神器Beyond-Compare4/">文件对比神器Beyond Compare4</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">二开的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>