<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一键部署springboot项目到docker</title>
    <url>/2020/01/21/%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE%E5%88%B0docker/</url>
    <content><![CDATA[<p>本文介绍如何将 Spring Boot 项目一键打包到远程 Docker 容器，然后通过运行一个镜像的方式来启动一个 Spring Boot 项目。</p>
<a id="more"></a>
<h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><h4 id="1-1-准备-Docker"><a href="#1-1-准备-Docker" class="headerlink" title="1.1 准备 Docker"></a>1.1 准备 Docker</h4><p>我这里以 CentOS7 为例来给大家演示。</p>
<p>首先需要在 CentOS7 上安装好 Docker，这个安装方式网上很多，我就不多说了，我自己去年写过一个 Docker 入门教程，大家可以在公众号后台回复 <code>Docker</code> 获取教程下载地址。</p>
<p>默认情况下，Docker守护进程Unix socket（/var/run/docker.sock）来进行本地进程通信，而不会监听任何端口，因此只能在本地使用docker客户端或者使用Docker API进行操作。如果想在其他主机上操作Docker主机，就需要让Docker守护进程打开一个HTTP Socket，这样才能实现远程通信。</p>
<p>Docker 安装成功之后，我们首先需要修改 Docker 配置，开启允许远程访问 Docker 的功能，开启方式很简单，修改 <code>/usr/lib/systemd/system/docker.service</code> 文件，加入如下内容：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby">H <span class="symbol">tcp:</span>/<span class="regexp">/0.0.0.0:2375  -H unix:/</span><span class="regexp">//var</span><span class="regexp">/run/docker</span>.sock</span></span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/1579593305260.png" alt="1579593305260"></p>
<p>配置完成后，保存退出，然后重启 Docker：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">daemon-reload</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start docker</span></span><br></pre></td></tr></table></figure>
<p>Docker 重启成功之后，Docker 的准备工作就算是 OK 了。</p>
<p>经过这里的时候我是遇到了很麻烦的问题 一直显示</p>
<p>Cannot connect to the Docker daemon at tcp://ip:2375. Is the docker daemon running?</p>
<p>???  我启动了啊 防火墙看了一下也是关的，为了确认 专门上腾讯云设置了一下安全组</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/1579600570283.png" alt="1579600570283"></p>
<p>然后跟着网上各种方法试，没办法了 重装 重整 。配置完之后还是不行，抱着试一试的态度看了一下防火墙</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=2375/tcp --permanent</span><br><span class="line">FirewallD is <span class="keyword">not</span> running</span><br><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/21/一键部署springboot项目到docker/20181110210835432.png" alt="img"></p>
<p>这是个啥玩意  ！！！ 最后查到 这是因为进程被锁住了。</p>
<p>对它进行解锁就可以了。执行命令，即可实现取消服务的锁定 </p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl unmask firewalld</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/21/一键部署springboot项目到docker/20181110211010917.png" alt="img"></p>
<p>好了，现在防火墙已经重新启动了。 </p>
<p>注：下次需要锁定该服务时可以输入以下命令行执行</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># systemctl mask firewalld</span></span><br></pre></td></tr></table></figure>
<p>原来是这个原因  </p>
<p>重启之后 的测试方法：</p>
<p>通过接口获取所有的镜像:</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">curl 'http://192.168.18.54:<span class="number">2375</span>/images/json?all=0'<span class="string">| python -m json.tool</span></span><br></pre></td></tr></table></figure>
<p>查看已经启动的容器信息：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">curl http:<span class="regexp">//</span><span class="number">192.168</span>.<span class="number">18.54</span>:<span class="number">2375</span><span class="regexp">/containers/</span>json |python -m json.tool</span><br></pre></td></tr></table></figure>
<p>获取指定容器的具体信息：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">curl -X GET 'http://192.168.18.54:<span class="number">2375</span>/containers/e37e50e73bd4/json'<span class="string">|python -m json.tool</span></span><br></pre></td></tr></table></figure>
<p>启动指定容器：【此处使用容器别名】</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">curl</span> -XPOST <span class="string">"http://192.168.18.54:2375/containers/t1/start"</span></span><br></pre></td></tr></table></figure>
<p>成功解决。</p>
<h4 id="1-2-准备-IDEA"><a href="#1-2-准备-IDEA" class="headerlink" title="1.2 准备 IDEA"></a>1.2 准备 IDEA</h4><p>IDEA 上的准备工作，主要是安装一个 Docker 插件，点击 <code>File-&gt;Settings-&gt;Plugins-&gt;Browse Repositories</code> 如下：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593368115.webp" alt="img"></p>
<p>点击右边绿色的 Install 按钮，完成安装，安装完成之后需要重启一下 IDEA。</p>
<p>IDEA 重启成功之后，我们依次打开 <code>File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Docker</code> ，然后配置一下 Docker 的远程连接地址：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593380622.webp" alt="img"></p>
<p>配置一下 Docker 的地址，配置完成后，可以看到下面有一个 Connection successful 提示，这个表示 Docker 已经连接上了。</p>
<p>如此之后，我们的准备工作就算是 OK 了。</p>
<h3 id="2-准备项目"><a href="#2-准备项目" class="headerlink" title="2.准备项目"></a>2.准备项目</h3><p>接下来我们来创建一个简单的 Spring Boot 项目（只需要引入 <code>spring-boot-starter-web</code> 依赖即可），项目创建成功之后，我们再创建一个普通的 <code>HelloDockerController</code>，用来做测试，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line">publicclass HelloDockerController &#123;</span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/hello"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String hello() &#123;</span><br><span class="line">        <span class="keyword">return</span><span class="string">"hello docker!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个很简单的接口，无需多说。</p>
<h3 id="3-配置-Dockerfile"><a href="#3-配置-Dockerfile" class="headerlink" title="3.配置 Dockerfile"></a>3.配置 Dockerfile</h3><p>接下来，在项目的根目录下，我创建一个 Dockerfile ，作为我镜像的构建文件，具体位置如下图：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593391529.webp" alt="img"></p>
<p>文件内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> hub.c.<span class="number">163</span>.com/library/java:latest</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> target/docker-0.0.1-SNAPSHOT.jar app.jar</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure>
<p>这里只有简单的四行，我说一下：</p>
<ol>
<li>Spring Boot 项目的运行依赖 Java 环境，所以我自己的镜像基于 Java 镜像来构建。</li>
<li>考虑到 Docker 官方镜像下载较慢，我这里使用了网易提供的 Docker 镜像。</li>
<li>由于 Spring Boot 运行时需要 tmp 目录，这里数据卷配置一个 /tmp 目录出来。</li>
<li>将本地 target 目录中打包好的 .jar 文件复制一份新的 到 /app.jar。</li>
<li>最后就是配置一下启动命令，由于我打包的 jar 已经成为 app.jar 了，所以启动命令也是启动 app.jar。</li>
</ol>
<p>这是我们配置的一个简单的 Dockerfile。</p>
<h3 id="4-配置-Maven-插件"><a href="#4-配置-Maven-插件" class="headerlink" title="4.配置 Maven 插件"></a>4.配置 Maven 插件</h3><p>接下来在 pom.xml 文件中，添加如下插件：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>build-image<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>http://192.168.66.131:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>javaboy/$</span><span class="template-variable">&#123;project.artifactId&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>$</span><span class="template-variable">&#123;project.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">forceTags</span>&gt;</span>true<span class="tag">&lt;/<span class="name">forceTags</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;project.build.directory&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>$</span><span class="template-variable">&#123;project.build.finalName&#125;</span><span class="xml">.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这个插件的配置不难理解：</p>
<ol>
<li>首先在 execution 节点中配置当执行 mvn package 的时候，顺便也执行一下 docker:build</li>
<li>然后在 configuration 中分别配置 Docker 的主机地址，镜像的名称，镜像的 tags，其中 dockerDirectory 表示指定 Dockerfile 的位置。</li>
<li>最后 resource 节点中再配置一下 jar 的位置和名称即可。</li>
</ol>
<p>OK，做完这些我们就算大功告成了。</p>
<h3 id="5-打包运行"><a href="#5-打包运行" class="headerlink" title="5.打包运行"></a>5.打包运行</h3><p>接下来对项目进行打包，打包完成后，项目会自动构建成一个镜像，并且上传到 Docker 容器中，打包方式如下：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593402473.webp" alt="img"></p>
<p>打包过程会稍微有一点旧，因为还包含了镜像的构建，特别是第一次打包，需要下载基础镜像，会更慢一些。</p>
<p>部分打包日志如下（项目构建过程）:</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593409895.webp" alt="img"></p>
<p>项目打包成功之后，我们就可以在 Docker 容器中看到我们刚刚打包成的镜像了，如下：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593417899.webp" alt="img"></p>
<h4 id="5-1-运行方式一"><a href="#5-1-运行方式一" class="headerlink" title="5.1 运行方式一"></a>5.1 运行方式一</h4><p>此时，我们可以直接在 Linux 上像创建普通容器一样创建这个镜像的容器，然后启动，执行如下命令即可：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker run -d --name javaboy -p <span class="number">8080</span>:<span class="number">8080</span> javaboy/docker:<span class="number">0.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>启动成功之后，我们就可以访问容器中的接口了。</p>
<p>但是这种操作显然还是有点麻烦，结合我们一开始安装的 Docker 插件，这个运行步骤还可以做进一步的简化。</p>
<h4 id="5-2-运行方式二"><a href="#5-2-运行方式二" class="headerlink" title="5.2 运行方式二"></a>5.2 运行方式二</h4><p>大家注意，此时我们的 IDEA 中多了一个选项，就是 docker，如下：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593432929.webp" alt="img"></p>
<p>点击左边的绿色启动按钮，连接上 Docker 容器，连接成功之后，我们就可以看到目前 Docker 中的所有容器和镜像了，当然也包括我们刚刚创建的 Docker 镜像，如下：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593439334.webp" alt="img"></p>
<p>此时，我们选中这个镜像，右键单击，即可基于此镜像创建出一个容器，如下图：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593445555.webp" alt="img"></p>
<p>我们选择 Create container，然后填入容器的一些必要信息，配置一下容器名称，镜像 ID 会自动填上，暴露的端口使用 Specify 即可，然后写上端口的映射关系：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593451263.webp" alt="img"></p>
<p>配置完成后，点击下方的 <code>run</code> 按钮，就可以开始运行了。运行日志如下：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640-1579593457951.webp" alt="img"></p>
<p>注意，这个日志是在 Docker 的那个窗口里打印出来的。</p>
<p>项目运行成功之后，在浏览器输入远程服务器的地址，就可以访问了：</p>
<p><img src="/2020/01/21/一键部署springboot项目到docker/640.webp" alt="img"></p>
<p>如此之后，我们的 Spring Boot 项目就算顺利发布到远程 Docker 容器中了。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware安装黑苹果踩坑</title>
    <url>/2020/01/17/VMware%E5%AE%89%E8%A3%85%E9%BB%91%E8%8B%B9%E6%9E%9C%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<p><strong>VMware安装黑苹果以及踩坑记录</strong></p>
<a id="more"></a>
<h4 id="准备软件"><a href="#准备软件" class="headerlink" title="准备软件:"></a>准备软件:</h4><p><strong>VMware14或者15 自行下载 </strong></p>
<p><strong>MacOS Unlocker for VMware</strong>, 简称 Unlocker。能够让 VMware 选择 Mac 系统进行安装的补丁，<a href="https://github.com/theJaxon/unlocker/releases" target="_blank" rel="noopener">Unlocker 在 github 的下载地址</a>  windows 选择第一个 unlocker302.zip 进行下载即可</p>
<p><strong>Mac OS X 10镜像</strong>:  cdr [推荐], 懒人安装包, 因为易装, 麻烦少. dmg, 原始镜像, 没有试过这个格式的安装, 不了解填这个坑 我这里提供的是cdr 和MacOS Unlocker for VMware, 简称 Unlocker</p>
<p>unlocker和Mac os下载地址 链接：<a href="https://pan.baidu.com/s/1e2TCqEdWECDd3zFJBaUiIg" target="_blank" rel="noopener">https://pan.baidu.com/s/1e2TCqEdWECDd3zFJBaUiIg</a>  提取码：uzry</p>
<h4 id="安装-VMware-Mac补丁"><a href="#安装-VMware-Mac补丁" class="headerlink" title="安装 VMware Mac补丁"></a>安装 VMware Mac补丁</h4><p>打开任务管理器：win+R，输入services.msc，将VMware 的服务全部停止运行。<br>[<img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304212419794-568382280.png" alt="img"></p>
<p>下载VMware14unlocker解压，右键选择以管理员身份运行win-install这个文件。</p>
<p>主要的问题在这里 如果这里安装好了 其他的就跟着走就行了</p>
<p><a href="https://img2018.cnblogs.com/blog/1267816/201903/1267816-20190304212438109-752218180.png" target="_blank" rel="noopener"><img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304212438109-752218180.png" alt="img"></a></p>
<p>看到终端有 Successfully, Finished 等词, 先不要高兴太早, 因为那整句话是否定的.</p>
<p>报错内容有:</p>
<ul>
<li><p>文件权限问题</p>
<blockquote>
<p>哪一个文件的权限出了问题, 就找到它并给它添加权限就可以了.</p>
<p>操作步骤: 右击选择属性 –&gt; 选择安全选项卡 –&gt; 点击编辑 –&gt; 选择 Everyone (组或用户名) –&gt; 允许完全控制.</p>
</blockquote>
</li>
<li><p>没有找到 <code>drawn*.*</code> 文件</p>
<blockquote>
<p>看了一下终端是访问了 <code>http://***</code> 链接之后才报的错误, 认为是访问超时了结果重试了几次都不行, 然后打开浏览器进行访问该链接, 结果浏览器返回 not found. 一脸懵逼, 简直坑爹啊</p>
<p><strong>填叁号坑</strong>: 解决办法 - 修改源码后重新编译打包exe<br>修改文件: gettools.py, 修改后的完整代码放在最后, 有中文注释.<br>思路: 访问问题, 那就修改访问的链接; 由于VMware 服务器识别 UA, 所以伪装 UA.<br>打包exe: 需要 python3.x 环境, 依赖包: requests, PyInstaller; 打包命令 <code>pyinstaller -F gettools.py</code><br>替换 gettools.exe 文件: 打包 exe 后, 会生成 dist 文件夹, 找到里面的 exe 文件, 替换 unlocker 文件夹中的 gettools.exe 文件</p>
<p>补充: 安装依赖包的命令: <code>pip3 install requests</code>; <code>pip3 install PyInstaller</code>; 打包exe 前, 需要打开终端并切换目录到 gettools.py 文件所在目录下.</p>
</blockquote>
</li>
</ul>
<p>gettools.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加处, 方便伪装 User-Agent</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加处</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_drawn</span><span class="params">(url, path)</span>:</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    resp = requests.get(url, headers=headers, timeout=<span class="number">180</span>)</span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">"wb"</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(resp.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertpath</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="comment"># OS path separator replacement funciton</span></span><br><span class="line">    <span class="keyword">return</span> path.replace(os.path.sep, <span class="string">'\\'</span>)  <span class="comment"># 修改处</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Check minimal Python version is 2.7</span></span><br><span class="line">    <span class="keyword">if</span> sys.version_info &lt; (<span class="number">2</span>, <span class="number">7</span>):</span><br><span class="line">        sys.stderr.write(<span class="string">'You need Python 2.7 or later\n'</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Setup url and file paths</span></span><br><span class="line">    url = <span class="string">'http://softwareupdate.vmware.com/cds/vmw-desktop/fusion/'</span></span><br><span class="line">    dest = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Re-create the tools folder</span></span><br><span class="line">    shutil.rmtree(dest + <span class="string">'/tools'</span>, <span class="literal">True</span>)</span><br><span class="line">    os.mkdir(dest + <span class="string">'/tools'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删改处</span></span><br><span class="line">    urlpost15 = url + <span class="string">'11.1.0/13668589'</span> + <span class="string">'/packages/com.vmware.fusion.tools.darwin.zip.tar'</span></span><br><span class="line">    urlpre15 = url + <span class="string">'11.1.0/13668589'</span> + <span class="string">'/packages/com.vmware.fusion.tools.darwinPre15.zip.tar'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Download the darwin.iso tgz file</span></span><br><span class="line">    print(<span class="string">'Retrieving Darwin tools from: '</span> + urlpost15)</span><br><span class="line">    <span class="comment"># 修改处</span></span><br><span class="line">    download_drawn(urlpost15, convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwin.zip.tar'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extract the tar to zip</span></span><br><span class="line">    tar = tarfile.open(convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwin.zip.tar'</span>), <span class="string">'r'</span>)</span><br><span class="line">    tar.extract(<span class="string">'com.vmware.fusion.tools.darwin.zip'</span>, path=convertpath(dest + <span class="string">'/tools/'</span>))</span><br><span class="line">    tar.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extract the iso and sig files from zip</span></span><br><span class="line">    cdszip = zipfile.ZipFile(convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwin.zip'</span>), <span class="string">'r'</span>)</span><br><span class="line">    cdszip.extract(<span class="string">'payload/darwin.iso'</span>, path=convertpath(dest + <span class="string">'/tools/'</span>))</span><br><span class="line">    cdszip.extract(<span class="string">'payload/darwin.iso.sig'</span>, path=convertpath(dest + <span class="string">'/tools/'</span>))</span><br><span class="line">    cdszip.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Move the iso and sig files to tools folder</span></span><br><span class="line">    shutil.move(convertpath(dest + <span class="string">'/tools/payload/darwin.iso'</span>), convertpath(dest + <span class="string">'/tools/darwin.iso'</span>))</span><br><span class="line">    shutil.move(convertpath(dest + <span class="string">'/tools/payload/darwin.iso.sig'</span>), convertpath(dest + <span class="string">'/tools/darwin.iso.sig'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Cleanup working files and folders</span></span><br><span class="line">    shutil.rmtree(convertpath(dest + <span class="string">'/tools/payload'</span>), <span class="literal">True</span>)</span><br><span class="line">    os.remove(convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwin.zip.tar'</span>))</span><br><span class="line">    os.remove(convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwin.zip'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Download the darwinPre15.iso tgz file</span></span><br><span class="line">    print(<span class="string">'Retrieving DarwinPre15 tools from: '</span> + urlpre15)</span><br><span class="line">    <span class="comment"># 修改处</span></span><br><span class="line">    download_drawn(urlpre15, convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwinPre15.zip.tar'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extract the tar to zip</span></span><br><span class="line">    tar = tarfile.open(convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwinPre15.zip.tar'</span>), <span class="string">'r'</span>)</span><br><span class="line">    tar.extract(<span class="string">'com.vmware.fusion.tools.darwinPre15.zip'</span>, path=convertpath(dest + <span class="string">'/tools/'</span>))</span><br><span class="line">    tar.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extract the iso and sig files from zip</span></span><br><span class="line">    cdszip = zipfile.ZipFile(convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwinPre15.zip'</span>), <span class="string">'r'</span>)</span><br><span class="line">    cdszip.extract(<span class="string">'payload/darwinPre15.iso'</span>, path=convertpath(dest + <span class="string">'/tools/'</span>))</span><br><span class="line">    cdszip.extract(<span class="string">'payload/darwinPre15.iso.sig'</span>, path=convertpath(dest + <span class="string">'/tools/'</span>))</span><br><span class="line">    cdszip.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Move the iso and sig files to tools folder</span></span><br><span class="line">    shutil.move(convertpath(dest + <span class="string">'/tools/payload/darwinPre15.iso'</span>), convertpath(dest + <span class="string">'/tools/darwinPre15.iso'</span>))</span><br><span class="line">    shutil.move(convertpath(dest + <span class="string">'/tools/payload/darwinPre15.iso.sig'</span>), convertpath(dest + <span class="string">'/tools/darwinPre15.iso.sig'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Cleanup working files and folders</span></span><br><span class="line">    shutil.rmtree(convertpath(dest + <span class="string">'/tools/payload'</span>), <span class="literal">True</span>)</span><br><span class="line">    os.remove(convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwinPre15.zip.tar'</span>))</span><br><span class="line">    os.remove(convertpath(dest + <span class="string">'/tools/com.vmware.fusion.tools.darwinPre15.zip'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h4 id="解决VMware开机不可恢复错误"><a href="#解决VMware开机不可恢复错误" class="headerlink" title="解决VMware开机不可恢复错误"></a>解决VMware开机不可恢复错误</h4><p>安装好了Mac虚拟机后，这时点击VMware虚拟机开机会提示如下错误：<br><img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304212845737-2027874771.png" alt="img"><br>解决办法就是到安装目录，找到VMX文件这个配置文件。<br><img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304212954854-1410442909.png" alt="img"></p>
<p>用记事本打开它，然后在<code>smc.present = &quot;TRUE&quot;</code>后面加一行：<code>smc.version = 0</code>，保存即可<br><img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304213051567-1641451939.png" alt="img"></p>
<h4 id="Mac-OS系统安装"><a href="#Mac-OS系统安装" class="headerlink" title="Mac OS系统安装"></a>Mac OS系统安装</h4><p>按照上面的操作，接下来再用VMware开机的话，你就可以看到经典的Mac OS开机画面了。</p>
<p>点击左侧列出的磁盘，如果无法分区，请点击格式化。<br><img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304213521051-1905153965.png" alt="img">现在再次点击格式化，分区保持默认即可。<br><img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304213558030-1383284819.png" alt="img"><img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304213618556-703940230.png" alt="img">配置完成后，我们点击左上角红色的叉叉退出磁盘工具，点击继续进入到下一步。</p>
<p><img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304213637754-1269034290.png" alt="img">同意协议，选择你要将Mac OS安装到的磁盘，也就是刚刚我们格式化掉的磁盘。<br><img src="/2020/01/17/VMware安装黑苹果踩坑/1267816-20190304213720454-687019062.png" alt="img">耐心等待个十几分钟，全新的Mac OS就会安装完成了</p>
<h4 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h4><p>我选了个默认的DHCP,然后填了两个DNS就好了 如果这里不行就查一下吧</p>
<h4 id="安装-VMTools"><a href="#安装-VMTools" class="headerlink" title="安装 VMTools"></a>安装 VMTools</h4><p>VMWare Tools工具是开启文件共享的。如果这个是灰色的,,,请先把mac虚拟机打开再看</p>
<p><img src="/2020/01/17/VMware安装黑苹果踩坑/1579247356668.png" alt="1579247356668"></p>
<p>如果没解决 ,右键虚拟机打开虚拟机设置, 在 CD/DVD 处选择 自动检测<img src="/2020/01/17/VMware安装黑苹果踩坑/20180110140142129.png" alt="img"></p>
<p>其实我也不知道我装了咋用  linux有xshell   这个…难道只能通过虚拟机?   试过teamview 不理想 哈哈哈 以后再说吧</p>
<p>感谢大佬的教程</p>
<p>安装 <a href="https://www.cnblogs.com/L1079991001/p/10473846.html" target="_blank" rel="noopener">https://www.cnblogs.com/L1079991001/p/10473846.html</a></p>
<p>问题  <a href="http://www.voidcn.com/article/p-cmqiimub-byz.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-cmqiimub-byz.html</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础整理</title>
    <url>/2019/12/19/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p><strong>面试整理</strong></p>
<a id="more"></a>
<h3 id="hashCode和equals的区别"><a href="#hashCode和equals的区别" class="headerlink" title="hashCode和equals的区别"></a>hashCode和equals的区别</h3><p>重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理这两个方法。</p>
<blockquote>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。使用通过调用hashCode()方法获取对象的hash值。</p>
</blockquote>
<p>想要明白hashCode的作用，必须要先知道Java中的集合。　　<br> 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。</p>
<p>那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？</p>
<p>这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。<br> 于是，Java采用了哈希表的原理。</p>
<p>这样一来，当集合要添加新的元素时，</p>
<p>先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。</p>
<p>如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；</p>
<p>如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p>
<blockquote>
<p>equals它的作用也是判断两个对象是否相等，如果对象重写了equals()方法，比较两个对象的内容是否相等；如果没有重写，比较两个对象的地址是否相同，价于“==”。同样的，equals()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有equals()函数。object类中equals与==是等效的</p>
</blockquote>
<p><img src="/2019/12/19/Java基础整理/2333435-853d6874222b3a78.jpg" alt="img"></p>
<h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><p>分为三块：</p>
<p><strong>Set （集合）是无序、不可以重复的</strong></p>
<p><strong>List（列表）是有序、可以重复的</strong></p>
<p><strong>Map （映射）是键-值对：Map<key , value></key></strong></p>
<p>分为三块：List列表、Set集合、Map映射</p>
<p><strong>Set、List和Map可以看做集合的三大类：</strong><br><strong>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</strong><br><strong>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。</strong><br><strong>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</strong> </p>
<p><strong>List接口</strong><br>List接口继承于Collection接口，它可以定义一个<strong>允许重复</strong>的<strong>有序集合</strong>。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p>
<p>List接口为Collection直接接口。List所代表的是<strong>有序的Collection</strong>，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p>
<p><strong>Map一种映射，用于储存关系型数据，保存着两种值，一组用于保存key,另一组用来保存value。并且key不允许重复。</strong><br><strong>HashMap底层就是一个数组，数组中根据存入的Key的HashCode决定存放位置，其Entry单元中有四个属性，分别为HashCode，Key，Vaule，和下一个Entry</strong>，这样就形成了一个链表，当HashMap中的另一个拥有相同的HashCode值的不同的Key存入时，会将原来的Entry赋到新Entry的属性中，然后形成Entry链，查询的时候先比较HashCode，如果相同且Key值相同则直接取出，如果HashCode相同Key值不同则继续顺着链表寻找直到寻找到相同的Key值。<br>TreeMap与HashMap的不同：表象上时TreeMap可以对Key进行排序，原因时TreeMap使用的时“红黑树”的二叉树结构储存Entry，也就是排序二叉树，左边恒放比此值小的数右边恒放比此值大的树，按照当前节点值与传入查询值的比较进行判断决定其存放位置/查询其数值；<br><strong>Set集合</strong>：Set与Map可以手动的互相转换 Set转换Map只需要新建一个对象，对象中又key和value两个属性，新建一个类继承Set存储新建的对象即可实现。Map转换为Set只需要将Map的Value固定，只使用Key存储数据即可实现；<br>HashTable:Map的线程安全型号；</p>
<h4 id="HashMap，HashTable底层实现的区别，hashTable和ConCurrentHashTable呢？"><a href="#HashMap，HashTable底层实现的区别，hashTable和ConCurrentHashTable呢？" class="headerlink" title="HashMap，HashTable底层实现的区别，hashTable和ConCurrentHashTable呢？"></a>HashMap，HashTable底层实现的区别，hashTable和ConCurrentHashTable呢？</h4><p>HashTable简单的理解就是hashmap的线程安全类 其方法大部分都相同只不过家了synchronize关键字保证其线程安全。其他的区别也有继承的接口不同这点。<br>ConCurrentHashTable则是改进了hashtable的效率，hashtable虽然安全但是不能多线程同时操作，ConCurrentHashTable使用了分块的模式支持多线程操作，且使用了lock替换synchronize来提高了效率。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat 12激活</title>
    <url>/2019/12/16/Navicat-12%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<p>github大神的<a href="https://github.com/DoubleLabyrinth/navicat-keygen" target="_blank" rel="noopener">激活项目地址</a></p>
<a id="more"></a>
<h3 id="激活步骤"><a href="#激活步骤" class="headerlink" title="激活步骤"></a>激活步骤</h3><h4 id="1-下载-从这里下载最新的release。从这里下载最新的Navicat-x64版本"><a href="#1-下载-从这里下载最新的release。从这里下载最新的Navicat-x64版本" class="headerlink" title="1.下载 从这里下载最新的release。从这里下载最新的Navicat x64版本"></a>1.下载 <a href="https://github.com/DoubleLabyrinth/navicat-keygen/releases" target="_blank" rel="noopener">从这里</a>下载最新的release。<a href="http://www.navicat.com.cn/download/direct-download?product=navicat_premium_cs_x64.exe&amp;location=1" target="_blank" rel="noopener">从这里</a>下载最新的Navicat x64版本</h4><h4 id="2-安装Navicat12-一路next-没啥问题"><a href="#2-安装Navicat12-一路next-没啥问题" class="headerlink" title="2.安装Navicat12  一路next,没啥问题"></a>2.安装Navicat12  一路next,没啥问题</h4><h4 id="3-解压navicat-keygen之后-打开cmd-exe执行命令"><a href="#3-解压navicat-keygen之后-打开cmd-exe执行命令" class="headerlink" title="3.解压navicat-keygen之后 打开cmd.exe执行命令"></a>3.解压navicat-keygen之后 打开cmd.exe执行命令</h4><p>navicat-patcher.exe “C:\Program Files\PremiumSoft\Navicat Premium 12” 回车 大概界面长这样 <code>navicat-patcher.exe</code>将会在当前目录生成一个新的RSA-2048私钥文件. 具体的原理看github</p>
<p><img src="/2019/12/16/Navicat-12激活/image-20191216112712712.png" alt="image-20191216112712712"></p>
<h4 id="4-接下来使用navicat-keygen-exe来生成序列号和激活码"><a href="#4-接下来使用navicat-keygen-exe来生成序列号和激活码" class="headerlink" title="4.接下来使用navicat-keygen.exe来生成序列号和激活码"></a>4.接下来使用<code>navicat-keygen.exe</code>来生成序列号和激活码</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">navicat-keygen</span><span class="selector-class">.exe</span> <span class="selector-tag">-text</span> .\<span class="selector-tag">RegPrivateKey</span><span class="selector-class">.pem</span></span><br></pre></td></tr></table></figure>
<p>详细参数含义查看github</p>
<p>你会被要求选择Navicat产品类别、语言以及输入主版本号。之后会随机生成一个序列号。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Select Navicat product:</span><br><span class="line"><span class="number">0.</span> DataModeler</span><br><span class="line"><span class="number">1.</span> Premium</span><br><span class="line"><span class="number">2.</span> MySQL</span><br><span class="line"><span class="number">3.</span> PostgreSQL</span><br><span class="line"><span class="number">4.</span> Oracle</span><br><span class="line"><span class="number">5.</span> SQLServer</span><br><span class="line"><span class="number">6.</span> SQLite</span><br><span class="line"><span class="number">7.</span> MariaDB</span><br><span class="line"><span class="number">8.</span> MongoDB</span><br><span class="line"><span class="number">9.</span> ReportViewer</span><br><span class="line"></span><br><span class="line">(Input index)&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Select product language:</span><br><span class="line"><span class="number">0.</span> English</span><br><span class="line"><span class="number">1.</span> Simplified Chinese</span><br><span class="line"><span class="number">2.</span> Traditional Chinese</span><br><span class="line"><span class="number">3.</span> Japanese</span><br><span class="line"><span class="number">4.</span> Polish</span><br><span class="line"><span class="number">5.</span> Spanish</span><br><span class="line"><span class="number">6.</span> French</span><br><span class="line"><span class="number">7.</span> German</span><br><span class="line"><span class="number">8.</span> Korean</span><br><span class="line"><span class="number">9.</span> Russian</span><br><span class="line"><span class="number">10.</span> Portuguese</span><br><span class="line"></span><br><span class="line">(Input index)&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">(Input major version number, range: <span class="number">0</span> ~ <span class="number">15</span>, <span class="keyword">default</span>: <span class="number">12</span>)&gt; <span class="number">12</span></span><br><span class="line"></span><br><span class="line">Serial number:</span><br><span class="line">NAVO<span class="number">-2</span>ORP-IN5A-GQEE</span><br><span class="line"></span><br><span class="line">Your name:</span><br></pre></td></tr></table></figure>
<p>接下来你会被要求输入<code>用户名</code>和<code>组织名</code>；请随便填写，但不要太长(注意 稍微别太普通 什么test demo 张三之类的 据说时间长了会失败 因为可能用这种名字的人很多) </p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Your name: DoubleLabyrinth</span><br><span class="line">Your organization: DoubleLabyrinth</span><br><span class="line">Input request code (<span class="keyword">in</span> Base64), input <span class="literal">empty</span> <span class="built_in">line</span> <span class="built_in">to</span> <span class="keyword">end</span>:</span><br></pre></td></tr></table></figure>
<p>之后你会被要求填入请求码。注意 <strong>不要关闭命令行</strong> <strong>不要关闭命令行</strong> <strong>不要关闭命令行</strong>!</p>
<h4 id="5-断开网络-并打开Navicat。找到注册窗口，并填入keygen给你的序列号。然后点击激活按钮。"><a href="#5-断开网络-并打开Navicat。找到注册窗口，并填入keygen给你的序列号。然后点击激活按钮。" class="headerlink" title="5.断开网络 并打开Navicat。找到注册窗口，并填入keygen给你的序列号。然后点击激活按钮。"></a>5.断开网络 并打开Navicat。找到<code>注册</code>窗口，并填入keygen给你的序列号。然后点击<code>激活</code>按钮。</h4><p>一般来说在线激活肯定会失败，这时候Navicat会询问你是否<code>手动激活</code>，直接选吧。</p>
<p>在<code>手动激活</code>窗口你会得到一个请求码，复制它并把它粘贴到keygen里。最后别忘了连按至少两下回车结束输入。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Your <span class="string">name:</span> DoubleLabyrinth</span><br><span class="line">Your <span class="string">organization:</span> DoubleLabyrinth</span><br><span class="line"></span><br><span class="line">Input request code (<span class="keyword">in</span> Base64), input empty line to <span class="string">end:</span></span><br><span class="line">t2U+<span class="number">0</span>yfE2FfnbjyhCXa0lglZOHu9Ntc3qyGiPbR6xb1QoU63<span class="regexp">/9BVfdaCq0blwVycXPyT/</span>Vqw5joIKdM5oCRR<span class="regexp">/afCPM7iRcyhQMAnvqwc+AOKCqayVV+SqKLvtR/</span>AbREI12w++PQ6Ewfs4A8PgB8OJ9G0jKt6Q<span class="regexp">/iJRblqi2WWw9mwy+YHcYYh3UAfygTnyj/</span>xl+MzRymbY0lkus+<span class="number">6</span>LPtpDecVsFFhM7F32Ee1QPwISko7bAkHOtkt+joPfYDdn9PDGZ4HEmeLvH6UqZCXkzgaAfynB7cQZFEkId8FsW2NGkbpM7wB2Hi3fNFgOIjutTprixTdbpFKn4w6gGc28ve23A==</span><br><span class="line"></span><br><span class="line">Request <span class="string">Info:</span></span><br><span class="line">&#123;<span class="string">"K"</span>:<span class="string">"NAVO2ORPIN5AGQEE"</span>, <span class="string">"DI"</span>:<span class="string">"R91j6WyMhxHznAKSxxxx"</span>, <span class="string">"P"</span>:<span class="string">"WIN"</span>&#125;</span><br><span class="line"></span><br><span class="line">Response <span class="string">Info:</span></span><br><span class="line">&#123;<span class="string">"K"</span>:<span class="string">"NAVO2ORPIN5AGQEE"</span>,<span class="string">"DI"</span>:<span class="string">"R91j6WyMhxHznAKSxxxx"</span>,<span class="string">"N"</span>:<span class="string">"DoubleLabyrinth"</span>,<span class="string">"O"</span>:<span class="string">"DoubleLabyrinth"</span>,<span class="string">"T"</span>:<span class="number">1547826060</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">License:</span></span><br><span class="line">lRF18o+ZhBphyN0U5kFLHtAAGGXuvhqOcxNuvAk4dJcGeR0ISuw74mQvAfdNjv0T</span><br><span class="line">I5NZFzqIJvrzM0XeR88q+<span class="number">3</span>kmZkECuxwwWHP3zzDPhPiylcTV4DoGZ1tfoViUSYQc</span><br><span class="line">LgXG0Fl7koZeP61YOKQ8GfX+Xk2ZTM64bYaF7NlhonM+GQUJCCF2JThmrP921t2p</span><br><span class="line">b/E5pV6fLOYMM13881ZQcQcltMNVDZn4lzgzKRFFxCQFaTl6fJMHZdYVmICQTHtI</span><br><span class="line">sNaym0zduc8/cv34mgJ+<span class="number">7</span>NseXmsEPCdjrZ59wgfPsLhZLXqtfxi5hGWw4NMa3Sb2</span><br><span class="line">UI8dzqFzRp/hSDEM0mEqiA==</span><br></pre></td></tr></table></figure>
<h4 id="6-如果不出意外，你会得到一个看似用Base64编码的激活码。直接复制它，并把它粘贴到Navicat的手动激活窗口，最后点激活按钮。如果没什么意外的话应该能成功激活。"><a href="#6-如果不出意外，你会得到一个看似用Base64编码的激活码。直接复制它，并把它粘贴到Navicat的手动激活窗口，最后点激活按钮。如果没什么意外的话应该能成功激活。" class="headerlink" title="6.如果不出意外，你会得到一个看似用Base64编码的激活码。直接复制它，并把它粘贴到Navicat的手动激活窗口，最后点激活按钮。如果没什么意外的话应该能成功激活。"></a>6.如果不出意外，你会得到一个看似用Base64编码的激活码。直接复制它，并把它粘贴到Navicat的<code>手动激活</code>窗口，最后点<code>激活</code>按钮。如果没什么意外的话应该能成功激活。</h4><p><img src="/2019/12/16/Navicat-12激活/image-20191216114222152.png" alt="image-20191216114222152"></p>
<p>以上~</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习-03.在IDEA上本地更新远程项目</title>
    <url>/2019/12/06/SpringBoot%E5%AD%A6%E4%B9%A0-03-%E5%9C%A8IDEA%E4%B8%8A%E6%9C%AC%E5%9C%B0%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>转载至<a href="https://www.jianshu.com/p/21a6f3f92d53" target="_blank" rel="noopener">https://www.jianshu.com/p/21a6f3f92d53</a></p>
<p><code>SpringBoot devtools 的远程应用</code> 这句话什么意思？</p>
<blockquote>
<p>Spring Boot开发者工具并不仅限于本地开发，在运行远程应用时你也可以使用一些特性。<br>远程支持是可选的，你需要确保开发者工具被包含在重新打包的归档文件中。</p>
</blockquote>
<p>即对于本地代码的修改，能够实时的更新到远程应用中，从而实现本地代码和远程应用的联合调试。</p>
<a id="more"></a>
<h3 id="1-将devtools打到jar包中"><a href="#1-将devtools打到jar包中" class="headerlink" title="1. 将devtools打到jar包中"></a>1. 将<code>devtools</code>打到jar包中</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-设置spring-devtools-remote-secret属性"><a href="#2-设置spring-devtools-remote-secret属性" class="headerlink" title="2. 设置spring.devtools.remote.secret属性"></a>2. 设置<code>spring.devtools.remote.secret</code>属性</h3><p>在<code>application.properties</code>中配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.devtools.remote.secret</span>=<span class="string">mysecrt</span></span><br></pre></td></tr></table></figure>
<p>或在<code>application.yml</code>中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  devtools:</span></span><br><span class="line"><span class="attr">    remote:</span></span><br><span class="line"><span class="attr">      secret:</span> <span class="string">mysecret</span></span><br></pre></td></tr></table></figure>
<h3 id="3-打好jar包，并在远程服务器运行"><a href="#3-打好jar包，并在远程服务器运行" class="headerlink" title="3. 打好jar包，并在远程服务器运行"></a>3. 打好jar包，并在远程服务器运行</h3><p><img src="/2019/12/06/SpringBoot学习-03-在IDEA上本地更新远程项目/1575531539101.png" alt="1575531539101"></p>
<p>远程调试启动截图2.jpg</p>
<h3 id="4-创建并启动客户端程序"><a href="#4-创建并启动客户端程序" class="headerlink" title="4. 创建并启动客户端程序"></a>4. 创建并启动客户端程序</h3><p>【Run】-&gt; 【Edit Configuration】-&gt; 点击加号 -&gt; 选择 Application，如下图填写 ，最后OK。</p>
<p><img src="/2019/12/06/SpringBoot学习-03-在IDEA上本地更新远程项目/1575531616149.png" alt="1575531616149"></p>
<p>最后运行它。<br> 运行结果如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">C:\develop\jdk\jdk1<span class="number">.8</span>\bin\java.exe -agentlib:jdwp=transport=dt_socket,address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4725</span>,suspend=y,server=n -javaagent:D:\develop\IDEA201823\lib\rt\debugger-agent.jar=file:/C:/Users/xu/AppData/Local/Temp/capture.props -Dfile.encoding=UTF<span class="number">-8</span> -classpath C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\charsets.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\deploy.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\access-bridge<span class="number">-64.</span>jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\cldrdata.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\dnsns.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\jaccess.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\jfxrt.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\localedata.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\nashorn.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\sunec.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\sunjce_provider.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\sunmscapi.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\sunpkcs11.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\ext\zipfs.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\javaws.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\jce.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\jfr.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\jfxswt.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\jsse.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\management-agent.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\plugin.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\resources.jar;C:\develop\jdk\jdk1<span class="number">.8</span>\jre\lib\rt.jar;D:\liuchuanwei_study\spring\spring-boot\SpringBoot-Example\springboot03\target\classes;C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot-starter\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot-starter<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\spring-context\<span class="number">5.1</span><span class="number">.4</span>.RELEASE\spring-context<span class="number">-5.1</span><span class="number">.4</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot-autoconfigure<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot-starter-logging\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot-starter-logging<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar;C:\Users\xu\.m2\repository\ch\qos\logback\logback-classic\<span class="number">1.2</span><span class="number">.3</span>\logback-classic<span class="number">-1.2</span><span class="number">.3</span>.jar;C:\Users\xu\.m2\repository\ch\qos\logback\logback-core\<span class="number">1.2</span><span class="number">.3</span>\logback-core<span class="number">-1.2</span><span class="number">.3</span>.jar;C:\Users\xu\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\<span class="number">2.11</span><span class="number">.1</span>\log4j-to-slf4j<span class="number">-2.11</span><span class="number">.1</span>.jar;C:\Users\xu\.m2\repository\org\apache\logging\log4j\log4j-api\<span class="number">2.11</span><span class="number">.1</span>\log4j-api<span class="number">-2.11</span><span class="number">.1</span>.jar;C:\Users\xu\.m2\repository\org\slf4j\jul-to-slf4j\<span class="number">1.7</span><span class="number">.25</span>\jul-to-slf4j<span class="number">-1.7</span><span class="number">.25</span>.jar;C:\Users\xu\.m2\repository\javax\annotation\javax.annotation-api\<span class="number">1.3</span><span class="number">.2</span>\javax.annotation-api<span class="number">-1.3</span><span class="number">.2</span>.jar;C:\Users\xu\.m2\repository\org\springframework\spring-core\<span class="number">5.1</span><span class="number">.4</span>.RELEASE\spring-core<span class="number">-5.1</span><span class="number">.4</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\spring-jcl\<span class="number">5.1</span><span class="number">.4</span>.RELEASE\spring-jcl<span class="number">-5.1</span><span class="number">.4</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\yaml\snakeyaml\<span class="number">1.23</span>\snakeyaml<span class="number">-1.23</span>.jar;C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot-starter-web\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot-starter-web<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot-starter-json\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot-starter-json<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar;C:\Users\xu\.m2\repository\com\fasterxml\jackson\core\jackson-databind\<span class="number">2.9</span><span class="number">.8</span>\jackson-databind<span class="number">-2.9</span><span class="number">.8</span>.jar;C:\Users\xu\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\<span class="number">2.9</span><span class="number">.0</span>\jackson-annotations<span class="number">-2.9</span><span class="number">.0</span>.jar;C:\Users\xu\.m2\repository\com\fasterxml\jackson\core\jackson-core\<span class="number">2.9</span><span class="number">.8</span>\jackson-core<span class="number">-2.9</span><span class="number">.8</span>.jar;C:\Users\xu\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\<span class="number">2.9</span><span class="number">.8</span>\jackson-datatype-jdk8<span class="number">-2.9</span><span class="number">.8</span>.jar;C:\Users\xu\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\<span class="number">2.9</span><span class="number">.8</span>\jackson-datatype-jsr310<span class="number">-2.9</span><span class="number">.8</span>.jar;C:\Users\xu\.m2\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\<span class="number">2.9</span><span class="number">.8</span>\jackson-module-parameter-names<span class="number">-2.9</span><span class="number">.8</span>.jar;C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot-starter-tomcat\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot-starter-tomcat<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\apache\tomcat\embed\tomcat-embed-core\<span class="number">9.0</span><span class="number">.14</span>\tomcat-embed-core<span class="number">-9.0</span><span class="number">.14</span>.jar;C:\Users\xu\.m2\repository\org\apache\tomcat\embed\tomcat-embed-el\<span class="number">9.0</span><span class="number">.14</span>\tomcat-embed-el<span class="number">-9.0</span><span class="number">.14</span>.jar;C:\Users\xu\.m2\repository\org\apache\tomcat\embed\tomcat-embed-websocket\<span class="number">9.0</span><span class="number">.14</span>\tomcat-embed-websocket<span class="number">-9.0</span><span class="number">.14</span>.jar;C:\Users\xu\.m2\repository\org\hibernate\validator\hibernate-validator\<span class="number">6.0</span><span class="number">.14</span>.<span class="keyword">Final</span>\hibernate-validator<span class="number">-6.0</span><span class="number">.14</span>.<span class="keyword">Final</span>.jar;C:\Users\xu\.m2\repository\javax\validation\validation-api\<span class="number">2.0</span><span class="number">.1</span>.<span class="keyword">Final</span>\validation-api<span class="number">-2.0</span><span class="number">.1</span>.<span class="keyword">Final</span>.jar;C:\Users\xu\.m2\repository\org\jboss\logging\jboss-logging\<span class="number">3.3</span><span class="number">.2</span>.<span class="keyword">Final</span>\jboss-logging<span class="number">-3.3</span><span class="number">.2</span>.<span class="keyword">Final</span>.jar;C:\Users\xu\.m2\repository\com\fasterxml\classmate\<span class="number">1.4</span><span class="number">.0</span>\classmate<span class="number">-1.4</span><span class="number">.0</span>.jar;C:\Users\xu\.m2\repository\org\springframework\spring-web\<span class="number">5.1</span><span class="number">.4</span>.RELEASE\spring-web<span class="number">-5.1</span><span class="number">.4</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\spring-beans\<span class="number">5.1</span><span class="number">.4</span>.RELEASE\spring-beans<span class="number">-5.1</span><span class="number">.4</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\spring-webmvc\<span class="number">5.1</span><span class="number">.4</span>.RELEASE\spring-webmvc<span class="number">-5.1</span><span class="number">.4</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\spring-aop\<span class="number">5.1</span><span class="number">.4</span>.RELEASE\spring-aop<span class="number">-5.1</span><span class="number">.4</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\spring-expression\<span class="number">5.1</span><span class="number">.4</span>.RELEASE\spring-expression<span class="number">-5.1</span><span class="number">.4</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot-starter-thymeleaf\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot-starter-thymeleaf<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\thymeleaf\thymeleaf-spring5\<span class="number">3.0</span><span class="number">.11</span>.RELEASE\thymeleaf-spring5<span class="number">-3.0</span><span class="number">.11</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\thymeleaf\thymeleaf\<span class="number">3.0</span><span class="number">.11</span>.RELEASE\thymeleaf<span class="number">-3.0</span><span class="number">.11</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\attoparser\attoparser\<span class="number">2.0</span><span class="number">.5</span>.RELEASE\attoparser<span class="number">-2.0</span><span class="number">.5</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\unbescape\unbescape\<span class="number">1.1</span><span class="number">.6</span>.RELEASE\unbescape<span class="number">-1.1</span><span class="number">.6</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\slf4j\slf4j-api\<span class="number">1.7</span><span class="number">.25</span>\slf4j-api<span class="number">-1.7</span><span class="number">.25</span>.jar;C:\Users\xu\.m2\repository\org\thymeleaf\extras\thymeleaf-extras-java8time\<span class="number">3.0</span><span class="number">.2</span>.RELEASE\thymeleaf-extras-java8time<span class="number">-3.0</span><span class="number">.2</span>.RELEASE.jar;C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot-devtools\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot-devtools<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar;D:\develop\IDEA201823\lib\idea_rt.jar org.springframework.boot.devtools.RemoteSpringApplication http:<span class="comment">//192.168.0.152:8090</span></span><br><span class="line">Connected to the target VM, address: <span class="string">'127.0.0.1:4725'</span>, transport: <span class="string">'socket'</span></span><br><span class="line">  .   ____          _                                              __ _ _</span><br><span class="line"> /\\ / ___<span class="string">'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \</span></span><br><span class="line"><span class="string">( ( )\___ | '</span>_ | <span class="string">'_| | '</span>_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) <span class="string">'  \/ _ \  _/ -_) ) ) ) )</span></span><br><span class="line"><span class="string">  '</span>  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /</span><br><span class="line"> =========|_|==============|___/===================================/_/_/_/</span><br><span class="line"> :: Spring Boot Remote ::  (v2<span class="number">.1</span><span class="number">.2</span>.RELEASE)</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">01</span>:<span class="number">28.932</span>  INFO <span class="number">27296</span> --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication v2<span class="number">.1</span><span class="number">.2</span>.RELEASE on DESKTOP<span class="number">-75</span>IE5AL with PID <span class="number">27296</span> (C:\Users\xu\.m2\repository\org\springframework\boot\spring-boot-devtools\<span class="number">2.1</span><span class="number">.2</span>.RELEASE\spring-boot-devtools<span class="number">-2.1</span><span class="number">.2</span>.RELEASE.jar started by xu in D:\liuchuanwei_study\spring\spring-boot\SpringBoot-Example\springboot03)</span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">01</span>:<span class="number">28.936</span>  INFO <span class="number">27296</span> --- [           main] o.s.b.devtools.RemoteSpringApplication   : No active profile set, falling back to <span class="keyword">default</span> profiles: <span class="keyword">default</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">01</span>:<span class="number">29.284</span>  WARN <span class="number">27296</span> --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http:<span class="comment">//192.168.0.152:8090 is insecure. You should use a URL starting with 'https://'.</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">01</span>:<span class="number">29.357</span>  INFO <span class="number">27296</span> --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port <span class="number">35729</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">01</span>:<span class="number">29.371</span>  INFO <span class="number">27296</span> --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in <span class="number">1.096</span> seconds (JVM running <span class="keyword">for</span> <span class="number">1.941</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-修改本地项目代码，编译项目。"><a href="#5-修改本地项目代码，编译项目。" class="headerlink" title="5. 修改本地项目代码，编译项目。"></a>5. 修改本地项目代码，编译项目。</h3><h4 id="未修改HelloController之前"><a href="#未修改HelloController之前" class="headerlink" title="未修改HelloController之前"></a>未修改HelloController之前</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问 <a href="https://links.jianshu.com/go?to=http%3A%2F%2F192.168.0.152%3A8090%2Fhello" target="_blank" rel="noopener">http://192.168.0.152:8090/hello</a>，控制台输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">03</span>:<span class="number">51.096</span>  INFO <span class="number">19286</span> --- [nio<span class="number">-8090</span>-<span class="keyword">exec</span><span class="number">-1</span>] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet <span class="string">'dispatcherServlet'</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">03</span>:<span class="number">51.096</span>  INFO <span class="number">19286</span> --- [nio<span class="number">-8090</span>-<span class="keyword">exec</span><span class="number">-1</span>] o.s.web.servlet.DispatcherServlet        : Initializing Servlet <span class="string">'dispatcherServlet'</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-15</span> <span class="number">19</span>:<span class="number">03</span>:<span class="number">51.104</span>  INFO <span class="number">19286</span> --- [nio<span class="number">-8090</span>-<span class="keyword">exec</span><span class="number">-1</span>] o.s.web.servlet.DispatcherServlet        : Completed initialization <span class="keyword">in</span> <span class="number">8</span> ms</span><br><span class="line">Hello!</span><br></pre></td></tr></table></figure>
<h3 id="修改HelloController"><a href="#修改HelloController" class="headerlink" title="修改HelloController"></a>修改HelloController</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World !"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后重新编译，在IDEA中【Build Project】。<br> 客户端程序控制台会输出</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">2019<span class="selector-tag">-01-15</span> 19<span class="selector-pseudo">:10</span><span class="selector-pseudo">:52.590</span>  <span class="selector-tag">INFO</span> 27296 <span class="selector-tag">---</span> <span class="selector-attr">[   File Watcher]</span> <span class="selector-tag">o</span><span class="selector-class">.s</span><span class="selector-class">.b</span><span class="selector-class">.d</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.ClassPathChangeUploader</span>      : <span class="selector-tag">Uploaded</span> 1 <span class="selector-tag">class</span> <span class="selector-tag">resource</span></span><br><span class="line">2019<span class="selector-tag">-01-15</span> 19<span class="selector-pseudo">:10</span><span class="selector-pseudo">:53.607</span>  <span class="selector-tag">INFO</span> 27296 <span class="selector-tag">---</span> <span class="selector-attr">[pool-1-thread-1]</span> <span class="selector-tag">o</span><span class="selector-class">.s</span><span class="selector-class">.b</span><span class="selector-class">.d</span><span class="selector-class">.r</span><span class="selector-class">.c</span><span class="selector-class">.DelayedLiveReloadTrigger</span>     : <span class="selector-tag">Remote</span> <span class="selector-tag">server</span> <span class="selector-tag">has</span> <span class="selector-tag">changed</span>, <span class="selector-tag">triggering</span> <span class="selector-tag">LiveReload</span></span><br></pre></td></tr></table></figure>
<p>而服务器则自动重启了</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">03</span>:<span class="number">51.096</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [nio-<span class="number">8090</span>-exec-<span class="number">1</span>] o.a.<span class="built_in">c</span>.<span class="built_in">c</span>.<span class="type">C</span>.[<span class="type">Tomcat</span>].[localhost].[/]       : <span class="type">Initializing</span> <span class="type">Spring</span> <span class="type">DispatcherServlet</span> 'dispatcherServlet'</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">03</span>:<span class="number">51.096</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [nio-<span class="number">8090</span>-exec-<span class="number">1</span>] o.s.web.servlet.<span class="type">DispatcherServlet</span>        : <span class="type">Initializing</span> <span class="type">Servlet</span> 'dispatcherServlet'</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">03</span>:<span class="number">51.104</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [nio-<span class="number">8090</span>-exec-<span class="number">1</span>] o.s.web.servlet.<span class="type">DispatcherServlet</span>        : <span class="type">Completed</span> initialization <span class="keyword">in</span> <span class="number">8</span> ms</span><br><span class="line"><span class="type">Hello!</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.223</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [       <span class="type">Thread</span>-<span class="number">0</span>] o.s.s.concurrent.<span class="type">ThreadPoolTaskExecutor</span>  : <span class="type">Shutting</span> down <span class="type">ExecutorService</span> 'applicationTaskExecutor'</span><br><span class="line"></span><br><span class="line">  .   <span class="number">____</span>          <span class="number">_</span>            <span class="number">__</span> <span class="number">_</span> <span class="number">_</span></span><br><span class="line"> /\\ / <span class="number">___</span>'<span class="number">_</span> <span class="number">__</span> <span class="number">_</span> <span class="number">_</span>(<span class="number">_</span>)<span class="number">_</span> <span class="number">__</span>  <span class="number">__</span> <span class="number">_</span> \ \ \ \</span><br><span class="line">( ( )\<span class="number">___</span> | '<span class="number">_</span> | '<span class="number">_</span>| | '<span class="number">_</span> \/ <span class="number">_</span>` | \ \ \ \</span><br><span class="line"> \\/  <span class="number">___</span>)| |<span class="number">_</span>)| | | | | || (<span class="number">_</span>| |  ) ) ) )</span><br><span class="line">  '  |<span class="number">____</span>| .<span class="number">__</span>|<span class="number">_</span>| |<span class="number">_</span>|<span class="number">_</span>| |<span class="number">_</span>\<span class="number">__</span>, | / / / /</span><br><span class="line"> =========|<span class="number">_</span>|==============|<span class="number">___</span>/=/<span class="number">_</span>/<span class="number">_</span>/<span class="number">_</span>/</span><br><span class="line"> :: <span class="type">Spring</span> <span class="type">Boot</span> ::        (v2.<span class="number">1.2</span>.<span class="type">RELEASE</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.412</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] <span class="built_in">c</span>.l.s.<span class="type">Springboot03Application</span>            : <span class="type">Starting</span> <span class="type">Springboot03Application</span> v0.<span class="number">0.1</span>-<span class="type">SNAPSHOT</span> on centos56 with <span class="type">PID</span> <span class="number">19286</span> (/home/software/www/springboot03-<span class="number">0.0</span>.<span class="number">1</span>-<span class="type">SNAPSHOT</span>.jar started by root <span class="keyword">in</span> /home/software/www)</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.414</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] <span class="built_in">c</span>.l.s.<span class="type">Springboot03Application</span>            : <span class="type">No</span> active profile <span class="keyword">set</span>, falling back to <span class="keyword">default</span> profiles: <span class="keyword">default</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.712</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] o.s.b.w.embedded.tomcat.<span class="type">TomcatWebServer</span>  : <span class="type">Tomcat</span> initialized with port(s): <span class="number">8090</span> (http)</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.713</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] o.apache.catalina.core.<span class="type">StandardService</span>   : <span class="type">Starting</span> service [<span class="type">Tomcat</span>]</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.714</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] org.apache.catalina.core.<span class="type">StandardEngine</span>  : <span class="type">Starting</span> <span class="type">Servlet</span> engine: [<span class="type">Apache</span> <span class="type">Tomcat</span>/<span class="number">9.0</span>.<span class="number">14</span>]</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.718</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] o.a.<span class="built_in">c</span>.<span class="built_in">c</span>.<span class="type">C</span>.[<span class="type">Tomcat</span>].[localhost].[/]       : <span class="type">Initializing</span> <span class="type">Spring</span> embedded <span class="type">WebApplicationContext</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.719</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] o.s.web.context.<span class="type">ContextLoader</span>            : <span class="type">Root</span> <span class="type">WebApplicationContext</span>: initialization completed <span class="keyword">in</span> <span class="number">299</span> ms</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.746</span>  <span class="type">WARN</span> <span class="number">19286</span> --- [  restartedMain] .s.b.d.a.<span class="type">RemoteDevToolsAutoConfiguration</span> : <span class="type">Listening</span> <span class="keyword">for</span> remote restart updates on /.~~spring-boot!~/restart</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.867</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] o.s.s.concurrent.<span class="type">ThreadPoolTaskExecutor</span>  : <span class="type">Initializing</span> <span class="type">ExecutorService</span> 'applicationTaskExecutor'</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.937</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] o.s.b.w.embedded.tomcat.<span class="type">TomcatWebServer</span>  : <span class="type">Tomcat</span> started on port(s): <span class="number">8090</span> (http) with context path ''</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">51.938</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [  restartedMain] <span class="built_in">c</span>.l.s.<span class="type">Springboot03Application</span>            : <span class="type">Started</span> <span class="type">Springboot03Application</span> <span class="keyword">in</span> <span class="number">0.565</span> seconds (<span class="type">JVM</span> running <span class="keyword">for</span> <span class="number">972.991</span>)</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">52.235</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [nio-<span class="number">8090</span>-exec-<span class="number">1</span>] o.a.<span class="built_in">c</span>.<span class="built_in">c</span>.<span class="type">C</span>.[<span class="type">Tomcat</span>].[localhost].[/]       : <span class="type">Initializing</span> <span class="type">Spring</span> <span class="type">DispatcherServlet</span> 'dispatcherServlet'</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">52.235</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [nio-<span class="number">8090</span>-exec-<span class="number">1</span>] o.s.web.servlet.<span class="type">DispatcherServlet</span>        : <span class="type">Initializing</span> <span class="type">Servlet</span> 'dispatcherServlet'</span><br><span class="line"><span class="number">2019</span>-<span class="number">01</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">10</span>:<span class="number">52.238</span>  <span class="type">INFO</span> <span class="number">19286</span> --- [nio-<span class="number">8090</span>-exec-<span class="number">1</span>] o.s.web.servlet.<span class="type">DispatcherServlet</span>        : <span class="type">Completed</span> initialization <span class="keyword">in</span> <span class="number">3</span> ms</span><br></pre></td></tr></table></figure>
<p>这个过程是不是就像在本地热部署一样啊！！</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal理解</title>
    <url>/2019/12/05/ThreadLocal%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>ThreadLocal是什么</strong></p>
<p>​        ThreadLocal提供线程局部变量。这些变量与普通的变量不同之处在于，每个访问这种变量的线程（通过它的get或set方法）都有自己的、独立初始化的变量副本。</p>
<a id="more"></a>
<p>ThreadLocal实例通常是希望将状态关联到一个线程的类的私有静态字段（比如，user ID 或者 Transaction ID 等等）。</p>
<p>（</p>
<p>画外音：这段话表达了三个意思</p>
<ol>
<li>ThreadLocal是一种变量类型，我们称之为“线程局部变量”</li>
<li>每个线程访问这种变量的时候都会创建该变量的副本，这个变量副本为线程私有</li>
<li>ThreadLocal类型的变量一般用private static加以修饰</li>
</ol>
<p>）</p>
<p>例如，下面的例子中这个类为每个线程生成唯一标识。一个线程的id是它第一次调用ThreadId.get()方法指定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cjs.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextId.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadId.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadLocal主要操作"><a href="#ThreadLocal主要操作" class="headerlink" title="ThreadLocal主要操作"></a>ThreadLocal主要操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程对ThreadLocal变量的“初始值”</span></span><br><span class="line"><span class="comment"> * 这个方法将在线程第一次访问变量（通过调用get方法）时被调用，如果之前已经调用过了就不会再调了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value for this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置当前线程的ThreadLocal变量的副本为指定的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程的ThreadLocal变量副本的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前线程的ThreadLocal变量副本的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Thread-变量-threadLocals"><a href="#Thread-变量-threadLocals" class="headerlink" title="Thread 变量 threadLocals"></a>Thread 变量 threadLocals</h3><p>线程类Thread内部有一个名为<code>threadLocals</code> 的 <code>ThreadLocal.ThreadLocalMap</code> 变量，它定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocal-ThreadLocalMap"><a href="#ThreadLocal-ThreadLocalMap" class="headerlink" title="ThreadLocal.ThreadLocalMap"></a>ThreadLocal.ThreadLocalMap</h3><p><code>ThreadLocal.ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocalMap is a customized hash map suitable only for</span></span><br><span class="line"><span class="comment"> * maintaining thread local values. No operations are exported</span></span><br><span class="line"><span class="comment"> * outside of the ThreadLocal class. The class is package private to</span></span><br><span class="line"><span class="comment"> * allow declaration of fields in class Thread.  To help deal with</span></span><br><span class="line"><span class="comment"> * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment"> * WeakReferences for keys. However, since reference queues are not</span></span><br><span class="line"><span class="comment"> * used, stale entries are guaranteed to be removed only when</span></span><br><span class="line"><span class="comment"> * the table starts running out of space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看注释的第一句话 <code>ThreadLocalMap is a customized hash map suitable only for maintaining thread local values.</code> 意思是 ThreadLocalMap 是一个自定义 HashMap，只适用于线程局部变量。完全可以把它看做是一个 HashMap。</p>
<p>类<code>ThreadLocal</code>的结构如下：</p>
<p><img src="/2019/12/05/ThreadLocal理解/5752218-92d415c7619d399b.webp" alt="img"></p>
<p>重要的方法只有两个：<strong>set 和 get</strong></p>
<h4 id="ThreadLocal-set-value"><a href="#ThreadLocal-set-value" class="headerlink" title="ThreadLocal.set(value)"></a>ThreadLocal.set(value)</h4><p><code>ThreadLocal.set(value)</code> 向 <code>Thread</code> 内部的 <code>threadLocals</code> 变量添加值，它的实现如下：</p>
<p><img src="/2019/12/05/ThreadLocal理解/ThreadLocal理解.assets/874963-20181011152245886-1506205830-1582190360505.png" alt="img"></p>
<p><img src="/2019/12/05/ThreadLocal理解/ThreadLocal理解.assets/874963-20181011152457548-439162523-1582190375526.png" alt="img"></p>
<p><img src="/2019/12/05/ThreadLocal理解/ThreadLocal理解.assets/874963-20181011152603331-927753529-1582190399109.png" alt="img"></p>
<p>可以看到，ThreadLocalMap底层是一个数组，数组中元素类型是Entry类型</p>
<p>set操作是向当前线程的ThreadLocal.ThreadLocalMap类型的成员变量threadLocals中设置值，key是this，value是我们指定的值</p>
<p>注意，这里传的this代表的是那个ThreadLocal类型的变量（或者说叫对象）</p>
<p>也就是说，每个线程都维护了一个ThreadLocal.ThreadLocalMap类型的对象，而set操作其实就是以ThreadLocal变量为key，以我们指定的值为value，最后将这个键值对封装成Entry对象放到该线程的ThreadLocal.ThreadLocalMap对象中。每个ThreadLocal变量在该线程中都是ThreadLocal.ThreadLocalMap对象中的一个Entry。既然每个ThreadLocal变量都对应ThreadLocal.ThreadLocalMap中的一个元素，那么就可以对这些元素进行读写删除操作。</p>
<h4 id="ThreadLocal-get"><a href="#ThreadLocal-get" class="headerlink" title="ThreadLocal.get()"></a>ThreadLocal.get()</h4><p><img src="/2019/12/05/ThreadLocal理解/ThreadLocal理解.assets/874963-20181011153747726-1579315823-1582190434817.png" alt="img"></p>
<p>get()方法就是从当前线程的ThreadLocal.ThreadLocalMap对象中取出对应的ThreadLocal变量所对应的值</p>
<p>同理，remove()方法就是清除这个值</p>
<p>用图形表示的话，大概是这样的：</p>
<p><img src="/2019/12/05/ThreadLocal理解/ThreadLocal理解.assets/874963-20181011153955199-569890474-1582190462355.png" alt="img"></p>
<p>或者是这样的：</p>
<p><img src="/2019/12/05/ThreadLocal理解/ThreadLocal理解.assets/874963-20181011160429567-1437635434-1582190462258.png" alt="img"></p>
<h3 id="ThreadLocal使用场景主要是在线程生命周期内传值"><a href="#ThreadLocal使用场景主要是在线程生命周期内传值" class="headerlink" title="ThreadLocal使用场景主要是在线程生命周期内传值"></a>ThreadLocal使用场景主要是在线程生命周期内传值</h3><p><strong>一切都归功于ThreadLocalMap</strong></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p><code>ThreadLocal</code>和<code>Synchronized</code>都是为了解决多线程中相同变量的访问冲突问题，不同的是：</p>
<ul>
<li><code>Synchronized</code> 是通过线程等待，牺牲时间来解决访问冲突</li>
<li><code>ThreadLocal</code> 是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于<code>Synchronized</code>，<code>ThreadLocal</code> 具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</li>
</ul>
</blockquote>
<p>正因为<code>ThreadLocal</code>的线程隔离特性，使他的应用场景相对来说更为特殊一些。在android中Looper、ActivityThread以及AMS中都用到了ThreadLocal。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习-02.在IDEA上实现项目的远程调试</title>
    <url>/2019/12/05/SpringBoot%E5%AD%A6%E4%B9%A0-02-%E5%9C%A8IDEA%E4%B8%8A%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p><strong>远程的时候我们往往可能不知道问题出自哪儿，通过这个方法可以使用本地代码调试远程的程序。</strong></p>
<a id="more"></a>
<h3 id="1-在远程服务器执行jar"><a href="#1-在远程服务器执行jar" class="headerlink" title="1. 在远程服务器执行jar"></a>1. 在远程服务器执行jar</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=9561 wechat-develop-0.0.1-SNAPSHOT.jar</span><br><span class="line">使用nohup启动</span><br><span class="line">nohup java -jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=9561 wechat-develop-0.0.1-SNAPSHOT.jar &gt; nohup-wechat.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>address 是开启远程端口，本地通过监听这个端口来实现远程调试。</p>
<p>远程端口需要防火墙开启或者开放端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 9561 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/05/SpringBoot学习-02-在IDEA上实现项目的远程调试/1575527849534.png" alt="1575527849534"></p>
<h3 id="2-本地调试"><a href="#2-本地调试" class="headerlink" title="2. 本地调试"></a>2. 本地调试</h3><h4 id="2-1-Run-gt-Edit-Configuration"><a href="#2-1-Run-gt-Edit-Configuration" class="headerlink" title="2.1 Run -&gt; Edit Configuration"></a>2.1 Run -&gt; Edit Configuration</h4><p><img src="/2019/12/05/SpringBoot学习-02-在IDEA上实现项目的远程调试/1575528013701.png" alt="1575528013701"></p>
<h4 id="2-2-点击加号，选择Remote"><a href="#2-2-点击加号，选择Remote" class="headerlink" title="2.2 点击加号，选择Remote"></a>2.2 点击加号，选择Remote</h4><h4 id="2-3-填写远程主机Host和端口Port，其他都默认-此处的端口要和第1步执行命令中的address一致。"><a href="#2-3-填写远程主机Host和端口Port，其他都默认-此处的端口要和第1步执行命令中的address一致。" class="headerlink" title="2.3 填写远程主机Host和端口Port，其他都默认,此处的端口要和第1步执行命令中的address一致。"></a>2.3 填写远程主机Host和端口Port，其他都默认,此处的端口要和第1步执行命令中的address一致。</h4><p><img src="/2019/12/05/SpringBoot学习-02-在IDEA上实现项目的远程调试/1575528128253.png" alt="1575528128253"></p>
<h3 id="3-启动调试"><a href="#3-启动调试" class="headerlink" title="3. 启动调试"></a>3. 启动调试</h3><p>在远程服务器启动jar包后，启动本地调试</p>
<p>控制台Console输出以下内容，说明启动成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Connected to the target VM, address: <span class="string">'1.1.1.1:9561'</span>, transport: <span class="string">'socket'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果提示连接超时的错误，那么检查一下远程端口是否能访问？远程服务器是否开启了防火墙？</p>
</blockquote>
<h3 id="4-测试断点"><a href="#4-测试断点" class="headerlink" title="4. 测试断点"></a>4. 测试断点</h3><p>在本地代码中打个断点，然后测试。<br> 发现远程项目运行时，真的走了本地的断点呢！！！</p>
<blockquote>
<p>打断点时，本地代码要和远程项目代码一致。<br>远程调试时，修改本地代码对远程项目无效。（要想实现修改的本地代码实时更新到远程项目，请参考这篇文章<a href="https://www.jianshu.com/p/21a6f3f92d53" target="_blank" rel="noopener">SpringBoot笔记3：devtools 的远程应用</a>）</p>
</blockquote>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习-01.实现微信接入</title>
    <url>/2019/12/05/SpringBoot%E5%AD%A6%E4%B9%A0-01-%E5%AE%9E%E7%8E%B0%E5%BE%AE%E4%BF%A1%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Auto.js学习</title>
    <url>/2019/12/03/Auto-js%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="Auto-js学习"><a href="#Auto-js学习" class="headerlink" title="Auto.js学习"></a>Auto.js学习</h3><p>​                                                                                                            转载至<a href="https://zhuanlan.zhihu.com/p/90065914" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90065914</a></p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在正文开始之前，我们要知道Auto.js是啥，根据官方文档定义：Auto.js是一款无需root权限的JavaScript自动化软件。如何理解它？</p>
<ol>
<li>Auto.js是一款安卓手机应用，和微信一样，安装在手机上使用</li>
<li>Auto.js是一款自动化软件，根据脚本内容便可以自动地执行相关的操作，并且手机无需root</li>
<li>Auto.js的脚本需要使用JavaScript编写</li>
</ol>
<p>另外，需要说明的是，文章面向<strong>有编程基础</strong>但不了解Auto.js的人群。文章以开发自动完成淘宝领喵币任务的脚本举例，对代码讲解，旨在让您可以快速上手开发Auto.js脚本。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p><strong>准备阶段</strong></p>
<ul>
<li>手机安装Auto.js应用</li>
<li>电脑上有代码编辑器，vscode最佳（Auto.js作者提供了vscode的插件便于调试）</li>
</ul>
<p>Auto.js因某种原因全网下架，我是在某个群里找到的apk安装包及打包插件的，也不确定apk是否安全。强烈建议大家自行编译<a href="https://link.zhihu.com/?target=https%3A//github.com/hyb1996/Auto.js" target="_blank" rel="noopener">Auto.js</a>应用及打包插件!!!为照顾像我一样的菜鸡，我会提供我群里找到的apk，再三强调apk可能不安全！<strong>使用本文提供的apk造成的一切后果自负</strong>！</p>
<p><a href="https://link.zhihu.com/?target=https%3A//share.weiyun.com/5a9g8ys" target="_blank" rel="noopener">Auto.js4.1.0share.weiyun.com</a><a href="https://link.zhihu.com/?target=https%3A//share.weiyun.com/5yQt3kc" target="_blank" rel="noopener">Auto.js4.1.0打包插件share.weiyun.com</a></p>
<p><img src="/2019/12/03/Auto-js学习/v2-d4e13298c8d1475792bb5a5a0d7d8479_hd.jpg" alt="img">Auto.js设置</p>
<p>接下来需要写脚本了，你可以</p>
<ul>
<li>在vscode上写脚本，写好后发给手机，在Auto.js应用中加载运行</li>
<li>在vscode上写脚本，电脑与手机在同一局域网，通过安装auto.js的<a href="https://link.zhihu.com/?target=https%3A//github.com/hyb1996/Auto.js-VSCode-Extension" target="_blank" rel="noopener">vscode插件</a>，实现在vscode上运行，手机就会相应执行脚本</li>
<li>在手机的Auto.js应用中直接码代码（不提倡）</li>
</ul>
<p><strong>实战开始</strong></p>
<p><strong>1.打开淘宝-&gt;点击领喵币按钮</strong></p>
<p>为了编写脚本简单，淘宝预先打开喵铺主页</p>
<p><img src="/2019/12/03/Auto-js学习/v2-7a5b8a95960671f9a59a306b237fa61c_hd.jpg" alt="img">1.喵铺主页</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">auto.waitFor()</span><br><span class="line"><span class="keyword">var</span> appName = <span class="string">"手机淘宝"</span>;</span><br><span class="line">launchApp(appName);</span><br><span class="line">sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//寻找领喵币按钮并点击</span></span><br><span class="line"><span class="keyword">var</span> lingmiaobi = text(<span class="string">"领喵币"</span>).findOnce();</span><br><span class="line"><span class="keyword">if</span> (lingmiaobi) &#123;</span><br><span class="line">    lingmiaobi.click();</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    toast(<span class="string">"未检查到领喵币按钮"</span>);</span><br><span class="line">    <span class="comment">//中止脚本</span></span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详解：</p>
<ol>
<li>Auto.js无需root，但是需要对该应用开启无障碍模式，开启后才可以进行屏幕点击等操作auto.waitFor()表示直到检查该应用开启无障碍后才执行其后面的代码，否则一直卡在这里，一般放到脚本的第一行</li>
<li>launchApp()可以打开对应应用，由于不同手机响应速度不同，本代码让它睡眠3s。</li>
<li>定位组件是autojs的最常见的操作，这很类似前端的定位dom元素。在任何点击之前都需要找到对应的组件，这不同于点击某像素位置，点击组件更能适配不同分辨率的手机。在auto.js中通过各种条件选取到的控件称为<a href="https://link.zhihu.com/?target=https%3A//hyb1996.github.io/AutoJs-Docs/%23/widgetsBasedAutomation%3Fid%3Duiselector" target="_blank" rel="noopener">UiSelector</a>。那么筛选条件是如何确定呢？打开Auto.js应用的悬浮窗，在喵铺主页，点击Auto.js<strong>悬浮窗</strong>后选择出现的<strong>蓝色按钮</strong>，点击<strong>布局范围分析</strong>后选择领喵币按钮<strong>查看控件信息</strong>，你就能看到如图2所示的信息。</li>
<li>click()表示点击该元素。</li>
<li>toast()表示展示一个消息框。</li>
</ol>
<p><img src="/2019/12/03/Auto-js学习/v2-7253c98a93b4354101db295bb0035df8_hd.jpg" alt="img">2.领喵币按钮的控件信息截图</p>
<p><strong>2.点击去进店/去浏览</strong></p>
<p><img src="/2019/12/03/Auto-js学习/v2-9e738ff36cd183d6ad2c30c8f7ff05e3_hd.jpg" alt="img">喵币任务栏</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开始执行任务</span></span><br><span class="line">execTask();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> target =  text(<span class="string">"去进店"</span>).findOnce() || text(<span class="string">"去浏览"</span>).findOnce();</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">            toast(<span class="string">"任务完成"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        target.click();</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//浏览网页20s</span></span><br><span class="line">        viewWeb(<span class="number">20</span>);</span><br><span class="line">        back();</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信现在你看这段代码能看懂了，viewWeb是一会儿我们要写的函数，目的是模拟浏览网页20s的操作，虽说淘宝要求15s就行了，但是可能部分手机加载耗时比较多，所以多写了5s。当判断任务栏有”去进店”、”去浏览”的组件时，点击跳转至浏览广告，浏览完毕后，返回至任务栏页面，循环执行该操作直到找不到”去进店”、”去浏览”的组件结束（任务完成后按钮文字会变成”已完成”）。</p>
<p><img src="/2019/12/03/Auto-js学习/v2-14afcbe16cc5c3d7b86e371a7fc2f94c_hd.jpg" alt="img">任务执行完文字会变为已完成</p>
<p><strong>3.浏览广告</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">viewWeb</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">    gesture(<span class="number">1000</span>, [<span class="number">300</span>, <span class="number">600</span>], [<span class="number">300</span>, <span class="number">300</span>]);</span><br><span class="line">    <span class="keyword">var</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> finish = desc(<span class="string">"任务完成"</span>).exists() || textStartsWith(<span class="string">"已获得"</span>).exists();</span><br><span class="line">        <span class="keyword">if</span> (finish || cnt &gt; time) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟返回键，返回到任务栏页面</span></span><br><span class="line">    back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于到了最后的环节了，函数的参数为当前页面的最大停留时间（防止意外而一直停留该页面）。</p>
<p>浏览广告完成的标志：</p>
<ul>
<li>当前页面出现”任务完成”或”已获得<strong>*</strong>“的组件</li>
<li>位于当前页面的时间大于所设定的最大限制</li>
</ul>
<p>gesture是指屏幕滑动操作，这是本文唯一涉及屏幕像素的语句。gesture(duration, [x1, y1], [x2, y2]表示用duration的时间，从(x1,y1)点滑到(x2,y2)点，代码中表示如图用1s从黄点滑向红点，故是上滑操作浏览广告。</p>
<p>本次淘宝的活动最开始滑动一次，之后等着时间够了即可，故代码中没有再额外滑动。在浏览广告完毕后back()模拟返回键返回值任务栏页面。</p>
<p><img src="/2019/12/03/Auto-js学习/v2-66a5448e8ceaceb69c29b16c3c2b60a4_hd.jpg" alt="img">(x,y)表示距离屏幕左端x像素，距离顶端y像素</p>
<p>你也许会注意到这段代码定位组件用到了desc()，之所于用desc是因为该控件的desc信息是”任务完成”，还记得如何查看控件信息吧？总之，想定位控件，就先去查它的控件信息。</p>
<p><strong>4. 测试</strong></p>
<p>代码终于写完了，将脚本发到手机中，在Auto.js应用点击右下角的+号，选择导入，在文件目中寻找对应的脚本加载。</p>
<p><img src="/2019/12/03/Auto-js学习/v2-c3eef92a75924dd88aa05c883074b29b_hd.jpg" alt="img"></p>
<p>将淘宝打开至喵铺主页，返回Auto.js，点击运行即可执行脚本，在日志处可以查看脚本运行日志，我还没提到日志？在脚本中你可以使用log()函数记录日志，这等同于print，常用于调试或记录日志信息。</p>
<p><strong>5. 打包apk</strong></p>
<p>编写完代码，将代码打包成一个独立的apk。</p>
<ol>
<li>右下角+号，新建文件夹命名为double11</li>
<li>在double11文件夹中加载对应脚本</li>
<li>如图选择，打包apk</li>
</ol>
<p><img src="/2019/12/03/Auto-js学习/v2-be542373f2794a4f01ec45300c03b887_hd.jpg" alt="img"></p>
<p><strong>你还需要知道的:</strong></p>
<ol>
<li><strong>选择器筛选条件</strong>：除使用text、desc筛选选择器外，组件的大多数属性都可以筛选，详情见<a href="https://link.zhihu.com/?target=https%3A//hyb1996.github.io/AutoJs-Docs/%23/widgetsBasedAutomation%3Fid%3Duiselector" target="_blank" rel="noopener">官方文档</a>。单一的筛选条件常常无法定位到元素，那么可以进行链式调用。如定位任务栏的关闭×按钮：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">className(<span class="string">"android.widget.Button"</span>).depth(<span class="number">18</span>).indexInParent(<span class="number">1</span>).findOnce();</span><br></pre></td></tr></table></figure>
<p>\2. <strong>定位选择器</strong>：findOnce()表示找到第一个满足条件的控件，找不到返回null;另外还有findOne(),findOne(time)等方法，具体的可以看<a href="https://link.zhihu.com/?target=https%3A//hyb1996.github.io/AutoJs-Docs/%23/widgetsBasedAutomation%3Fid%3Duiselectorfindone" target="_blank" rel="noopener">文档</a>。这里有一个坑，findOne()如果没找到匹配的组件会一直找，直至所描述的控件出现为止，故该函数不会返回null，找不到可能会卡在这里，所以谨慎使用。</p>
<p>\3. <strong>click()</strong>：当定位的元素的clickable属性为true时，才可以点击，如果你查看某控件的clickable为false，那说明此控件不能点！！你可能是想点击它的子/父控件。</p>
<hr>
<p>源码参考<a href="https://link.zhihu.com/?target=https%3A//github.com/ErazerControl/2019double11" target="_blank" rel="noopener">https://github.com/ErazerControl/2019double11</a>，切换tag至v1.0.0</p>
]]></content>
      <categories>
        <category>小技能</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>文件对比神器Beyond Compare4</title>
    <url>/2019/12/02/%E6%96%87%E4%BB%B6%E5%AF%B9%E6%AF%94%E7%A5%9E%E5%99%A8Beyond-Compare4/</url>
    <content><![CDATA[<p>转载至<a href="https://touwoyimuli.github.io/2019/07/04/Beyond-Compare-4文件对比神器-（带官网离线安装包和破解工具）-破解教程/" target="_blank" rel="noopener">https://touwoyimuli.github.io/2019/07/04/Beyond-Compare-4文件对比神器-（带官网离线安装包和破解工具）-破解教程/</a></p>
<p>提供<code>Beyond Compare 4</code>软件的破解教程，以及相关资源下载。</p>
<a id="more"></a>
<h2 id="软件用途："><a href="#软件用途：" class="headerlink" title="软件用途："></a>软件用途：</h2><p>一个程序，可以很容易地比较文件和文件夹。使用该软件提供的功能强大的工具，你将能够找到的所有文件/文件夹之间的差异，然后再结合或同步它们。</p>
<p>它能够通过检查修改的唯一文件大小和日期很快整个比较硬盘驱动器或文件夹。或者，它可以通过文件的字节比较，这需要较长的时间进行更彻底，字节，但它提供了更精确的结果。该方案是能够比较任何类型的文件，无论是可执行文件（.exe文件），文档（.doc，.pdf等），图像等</p>
<p><img src="/2019/12/02/文件对比神器Beyond-Compare4/20190921224959.png" alt="img"></p>
<p>该实用程序可用于文件夹同步。该程序会比较两个文件夹，并在视觉上突出显示所有的差异。在此之后，你可以同步两个文件夹，轻松地让他们相同的内容。</p>
<p>它可以让你自动执行重复性任务。要做到这一点，有脚本语言。任何脚本可以在命令行中运行，这样你就可以在任何时间为你安排同步。</p>
<ul>
<li><img src="/2019/12/02/文件对比神器Beyond-Compare4/20190921224924.png" alt="img">国外官网下载(推荐)：<a href="https://www.scootersoftware.com/" target="_blank" rel="noopener">Beyond Compare 官网</a></li>
<li>使用博主提供好的：链接：<a href="https://pan.baidu.com/s/1DjGgwbM67T6UVmKFRC_ElA" target="_blank" rel="noopener">https://pan.baidu.com/s/1DjGgwbM67T6UVmKFRC_ElA</a><br>提取码：6bfj </li>
</ul>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>若是无特殊说明，<strong>链接一般都是为百度云链接</strong>，且这些分享的软件，都是经过我自己重度使用过了的，亲测有效，且最少都是使用了好几个月了的，亲测有效。若是链接失效，可以评论留言，我会更新该链接。</p>
<h2 id="下载工具推荐："><a href="#下载工具推荐：" class="headerlink" title="下载工具推荐："></a>下载工具推荐：</h2><p>推荐使用<code>PanDownload</code>，我都是使用了快一年了，感觉一直都很稳定。 <strong>嫌弃麻烦的，可以考虑使用提供的网页版：</strong> <strong>使用教程和详细：</strong> <a href="https://blog.csdn.net/qq_33154343/article/details/94618573" target="_blank" rel="noopener">破解百度云 PanDownload_Beta 使用教程</a></p>
<h2 id="破解激活："><a href="#破解激活：" class="headerlink" title="破解激活："></a>破解激活：</h2><p>安装完成， 开始激活破解了：<br><img src="/2019/12/02/文件对比神器Beyond-Compare4/1575257384371.png" alt="1575257384371"></p>
<p>运行压缩包里面的<code>Beyond_Compare_Keygen_4.x通用注册机.exe</code>，其中名称可以随意更改，但不要使用默认的<br>否则过一两天段时间，会显示该证书已经吊销。</p>
<p><img src="/2019/12/02/文件对比神器Beyond-Compare4/1575257418364.png" alt="1575257418364"></p>
<p><img src="/2019/12/02/文件对比神器Beyond-Compare4/20190921224533.png" alt="img"></p>
<p>比如我的生成的激活码就是这个，然后点击如下<code>Beyond Compare 4</code>的快捷方式，注册激活码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span><span class="bullet">--</span> <span class="string">BEGIN</span> <span class="string">LICENSE</span> <span class="string">KEY</span> <span class="meta">---</span></span><br><span class="line"><span class="string">RyfQg25Q+y6D+e9t-rKVWfI2Njw48dYOgS0bxuwvT6WSO5ov+WJdpiapblD0kIqOrcKOMd0DsgccpROWP8kroS22VbQNk9ai56+SiyWFOY6u2tgsjhfOAdvinqbtalnhy0taz4iCTY3sSKSDtgKTdKtCt9qSLqsBYivKEqXuet3hPIAuEljmmjxOCA2-0diMVoLV3Lvh3aMvKWWRFPyEEEu4s0e48hJBQC9ymBpKIhp0F2d8RfjR32qo0W8C77zhXOUVmp-ACBf8y1BPNvEkOvbHeIGxcCNwKx1OIwRXLFIMtidT+q-BGwgKzEqqNvDBI-CaFjBrascuYxdHZrdmDk++</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">--</span> <span class="string">END</span> <span class="string">LICENSE</span> <span class="string">KEY</span> <span class="bullet">-----</span></span><br></pre></td></tr></table></figure>
<p>运行<code>Beyond Compare 4.exe</code>之后，会发现下图ERROR提示信息， 不过不用管，直接点击输入秘钥即可：</p>
<p><img src="/2019/12/02/文件对比神器Beyond-Compare4/20190921224419.png" alt="img"></p>
<p>然后会看到提示成功，再接着就是进入软件，查看是否真的激活成功</p>
<p><img src="/2019/12/02/文件对比神器Beyond-Compare4/20190921224400.png" alt="img"></p>
<p>激活成功✿✿ヽ(°▽°)ノ✿</p>
<p><img src="/2019/12/02/文件对比神器Beyond-Compare4/20190921224336.png" alt="img"></p>
<h2 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h2><p><strong>更新:2019-09-21</strong></p>
<p>若是发现出现秘钥被吊销吊销的情况，请在注册机输入用户名，输入一个自己的随意一个的用户名，生成对应的激活秘钥，再进行激活，就又可以使用了；大概率是使用默认用户名激活的太多了，默认用户被吊销了；<strong>或建议一开始就自己创建一个复杂一点的用户名生成自己的专属秘钥来激活。</strong></p>
<h2 id="版权声明："><a href="#版权声明：" class="headerlink" title="版权声明："></a>版权声明：</h2><p>本文仅用于学习、研究和交流目的，欢迎非商业性质转载。但请注明博客来源</p>
<ul>
<li>文章内容部分来源于互联网，不代表本人的任何立场；涉及到的软件来源于互联网，仅供个人下载使用，请勿用于商业用途，版权归软件开发者所有，下载后请于24小时内删除，如有真实需要请支持正版！因下载本站任何资源造成的损失，全部责任由使用者本人承担！如果你是版权方，认为本文内容对您的权益有所侵犯，<a href="https://touwoyimuli.github.io/about/" target="_blank" rel="noopener">请联系博主的QQ</a>，附上添加好友理由，且应该提交相应的证明材料，待博主进行严格地审查和背景调查后，情况属实的将在最快时间(三~五天)内将本文删除或修正。</li>
<li>附:二○○二年一月一日《计算机软件保护条例》第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬!</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx理解</title>
    <url>/2019/04/01/Nginx%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="代理介绍"><a href="#代理介绍" class="headerlink" title="代理介绍"></a>代理介绍</h3><p>　　在Java设计模式中，代理模式是这样定义的：给某个对象提供一个代理对象，并由代理对象控制原对象的引用。代理简单来说，就是如果我们想做什么，但又不想直接去做，那么这时候就找另外一个人帮我们去做。比如中介公司就是给我们做代理服务的，我们委托中介公司帮我们找房子。　</p>
<a id="more"></a>　<br>    Nginx 主要能够代理如下几种协议，其中用到的最多的就是做Http代理服务器。<br><br><img src="/2019/04/01/Nginx理解/1120165-20180905232339438-913760288.png" alt="img"><br><br>### 正向代理<br><br>​    VPN 就是做正向代理的。正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。<br><br>​    什么是 VPN，VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机。这样做有什么好处呢？比如 VPN 游戏加速方面的原理，我们要玩网通区的 LOL，但是本机接入的是电信的宽带，玩网通区的会比较卡，这时候就利用 VPN 将电信网络变为网通网络，然后在玩网通区的LOL就不会卡了（注意：VPN 是不能增加带宽的，不要以为不卡了是因为网速提升了）。<br><br>　　理解这两种代理的关键在于代理服务器所代理的对象是什么，正向代理代理的是客户端，我们需要在客户端进行一些代理的设置。而反向代理代理的是服务器，作为客户端的我们是无法感知到服务器的真实存在的。<br>    反向代理和正向代理的区别就是：<strong>正向代理代理客户端，反向代理代理服务器。</strong><br><br>### 反向代理<br><br>e.g 使用 nginx 反向代理 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 直接跳转到127.0.0.1:8080<br>步骤:启动一个 tomcat，浏览器地址栏输入 127.0.0.1:8080<br>通过修改本地 host 文件，将 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 映射到 127.0.0.1<br><br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">www</span><span class="selector-class">.123</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure>
<p>配置完成之后，我们便可以通过 <a href="http://www.123.com:8080" target="_blank" rel="noopener">www.123.com:8080</a> 访问到第一步出现的 Tomcat初始界面。<br>如何只需要输入 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 便可以跳转到 Tomcat初始界面呢？便用到 nginx的反向代理。</p>
<p>在 nginx.conf 配置文件中增加如下配置：</p>
<pre><code>server {
        listen       80;
        server_name  www.123.com;
        location / {
        proxy_pass http://127.0.0.1:8080;
        index  index.html index.htm index.jsp;
    }
}
</code></pre><p>​    如上配置，我们监听80端口，访问域名为<a href="http://www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。" target="_blank" rel="noopener">www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。</a><br>我们在浏览器端输入 <a href="http://www.123.com" target="_blank" rel="noopener">www.123.com</a> 结果如下：</p>
<p><img src="/2019/04/01/Nginx理解/1120165-20180906073551600-75534434.png" alt="img"></p>
<p>总结：其实这里更贴切的说是通过nginx代理端口，原先访问8080端口，通过nginx代理之后，通过80端口就可以访问了。</p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射</title>
    <url>/2019/03/26/java%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p><strong>Java反射原理（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码）） </strong></p>
<a id="more"></a>
<p>1.将Java文件保存到本地硬盘</p>
<p>2.编译Java文件，生成.class文件</p>
<p>3.使用Java虚拟机（JVM）将字节码文件加载到内存</p>
<p>4.字节码文件在内存中使用Class类表示</p>
<p>5.使用反射的时候，首先获取到Class类，就可以得到class文件里的所有内容，包含属性、构造方法、普通方法</p>
<p>6.属性通过Filed类表示</p>
<p>7.构造方法通过Constructor表示</p>
<p>8.普通方法通过Method表示</p>
<p>即JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。</p>
<h4 id="1、获取类对象："><a href="#1、获取类对象：" class="headerlink" title="1、获取类对象："></a>1、获取类对象：</h4><p>通过类名获取Class对象，Class<t> c = Class.forName(“类的完全路径”);</t></p>
<p>通过Class对象获取具体的类对象：Object o = (Object) c.newInstance();</p>
<h4 id="2、获取类中的构造方法："><a href="#2、获取类中的构造方法：" class="headerlink" title="2、获取类中的构造方法："></a>2、获取类中的构造方法：</h4><p><img src="/2019/03/26/java反射/831179-20170311161343451-803699800.png" alt="img"></p>
<p><img src="/2019/03/26/java反射/831179-20170311161408982-698240323.png" alt="img"></p>
<h4 id="3、获取类中的属性："><a href="#3、获取类中的属性：" class="headerlink" title="3、获取类中的属性："></a>3、获取类中的属性：</h4><p><img src="/2019/03/26/java反射/831179-20170311161735389-1882210002.png" alt="img"></p>
<p><img src="/2019/03/26/java反射/831179-20170311161755498-1621406504.png" alt="img"></p>
<h4 id="4、获取类中的方法："><a href="#4、获取类中的方法：" class="headerlink" title="4、获取类中的方法："></a>4、获取类中的方法：</h4><p><img src="/2019/03/26/java反射/831179-20170311161823873-503164825.png" alt="img"></p>
<p><img src="/2019/03/26/java反射/831179-20170311161907357-844512641.png" alt="img"></p>
<p>获取class的三种方式<br>先定义一个实体类Person：</p>
<p>Package reflex;</p>
<p>public class Person {</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//私有属性</span></span><br><span class="line"><span class="keyword">private</span> String name = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="comment">//公有属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//私有方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"private say()..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公有方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"public work()..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
<p>获取class方法</p>
<h5 id="1、对象调用-getClass-方法来获取-通常应用在：比如你传过来一个-Object"><a href="#1、对象调用-getClass-方法来获取-通常应用在：比如你传过来一个-Object" class="headerlink" title="1、对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object"></a>1、对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object</h5><p>//  类型的对象，而我不知道你具体是什么类，用这种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Class c1 = p1.getClass();</span><br></pre></td></tr></table></figure>
<p>​       </p>
<h5 id="2、类名-class-的方式得到-该方法最为安全可靠，程序性能更高"><a href="#2、类名-class-的方式得到-该方法最为安全可靠，程序性能更高" class="headerlink" title="2、类名.class 的方式得到,该方法最为安全可靠，程序性能更高"></a>2、类名.class 的方式得到,该方法最为安全可靠，程序性能更高</h5><p>//  这说明任何一个类都有一个隐含的静态成员变量 class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c2 = Person.class;</span><br></pre></td></tr></table></figure>
<p>​        </p>
<h5 id="3、通过-Class-对象的-forName-静态方法来获取，用的最多，"><a href="#3、通过-Class-对象的-forName-静态方法来获取，用的最多，" class="headerlink" title="3、通过 Class 对象的 forName() 静态方法来获取，用的最多，"></a>3、通过 Class 对象的 forName() 静态方法来获取，用的最多，</h5><p>//   但可能抛出 ClassNotFoundException 异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c3 = Class.forName(<span class="string">"reflex.Person"</span>);</span><br></pre></td></tr></table></figure>
<p>需要注意的是：一个类在 JVM 中只会有一个 Class 实例,即我们对上面获取的 c1,c2,c3进行 equals 比较，发现都是true。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class class1 = Person.class;</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Class class2= person.getClass();</span><br><span class="line"><span class="keyword">if</span>(class1.equals(class2))&#123;</span><br><span class="line">    System.out.println(<span class="string">"class1.equals(class2)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Class具有的部分方法如下：</p>
<p>getName()：获得类的完整名字。</p>
<p>　　getFields()：获得类的public类型的属性。</p>
<p>　　getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类</p>
<p>　　getMethods()：获得类的public类型的方法。</p>
<p>　　getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类</p>
<p>　　getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。</p>
<p>　　getConstructors()：获得类的public类型的构造方法。</p>
<p>　　getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。</p>
<p>　　newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</p>
<p>Class能实现的功能<br>1判断对象属于哪个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Class class2= person.getClass();</span><br><span class="line">System.out.println(<span class="string">"class2："</span>+class2);</span><br></pre></td></tr></table></figure>
<p>输出：class2：class reflect.Person</p>
<p>2获取类信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class class1 = Person.class;   </span><br><span class="line">Method[] methods = class1.getMethods();</span><br><span class="line">Method[] declaredMethods = class1.getDeclaredMethods();</span><br><span class="line">Field[] declaredFields = class1.getDeclaredFields();</span><br></pre></td></tr></table></figure>
<p>3构建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Class class2= person.getClass();</span><br><span class="line">Object o = class2.newInstance();</span><br><span class="line"><span class="comment">//强转前先用instanceof判断</span></span><br><span class="line"><span class="keyword">if</span>(o <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">    ((Person) o).work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4动态执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class class1 = Person.class;</span><br><span class="line">Method work = class1.getDeclaredMethod(<span class="string">"work"</span>);</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">work.invoke(person);</span><br></pre></td></tr></table></figure>
<p>5动态操作属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class class1 = Person.class;</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Field field = class1.getDeclaredField(<span class="string">"age"</span>);</span><br></pre></td></tr></table></figure>
<p>//age默认值是18</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">field.set(person,<span class="number">22</span>);</span><br><span class="line">System.out.println(person.age);</span><br></pre></td></tr></table></figure>
<p>6动态代理</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>框架相关面试</title>
    <url>/2019/03/25/%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h4 id="1-JDBC编程有什么不足？mybatis是如何解决的？"><a href="#1-JDBC编程有什么不足？mybatis是如何解决的？" class="headerlink" title="1. JDBC编程有什么不足？mybatis是如何解决的？"></a>1. JDBC编程有什么不足？mybatis是如何解决的？</h4><p>主要有以下几个方面：</p>
<ul>
<li>JDBC中数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能  mybatis解决：在mybatis配置文件中配置数据连接池，使用连接池管理数据库连接。</li>
<li>Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。  mybatis解决：将Sql语句配置在mapper.xml文件中，与java代码分离。</li>
<li>向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数一一对应。  mybatis解决： Mybatis自动将java对象映射至sql语句。</li>
<li>对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历。  mybatis解决：Mybatis自动将sql执行结果映射至java对象。</li>
</ul>
<h4 id="2-mybatis编程步骤是怎样的？"><a href="#2-mybatis编程步骤是怎样的？" class="headerlink" title="2. mybatis编程步骤是怎样的？"></a>2. mybatis编程步骤是怎样的？</h4><p>步骤如下：</p>
<ul>
<li>创建SqlSessionFactory</li>
<li>通过SqlSessionFactory创建 SqlSession</li>
<li>通过sqlsession执行数据库操作</li>
<li>调用session.commit()提交事务</li>
<li>调用session.close()关闭会话</li>
</ul>
<h4 id="3-Mybatis中-和-的区别？"><a href="#3-Mybatis中-和-的区别？" class="headerlink" title="3. Mybatis中#和$的区别？"></a>3. Mybatis中#和$的区别？</h4><p> 使用${参数}就是单纯的字符串拼接，拼接完成后才会对SQL进行编译、执行，所以性能较低；#{参数名}在SQL中相当于一个参数占位符“?”，用来补全预编译语句，所有这种方式可以防止SQL注入，它补全预编译语句时，会在此参数值两端加了单引号。但是有些地方必须要用$，比如参数是表名的时候：${表名}，因为如果使用#，sql语句就会变成 ‘表名’，会加上单引号，这样就找不到该表。总之，能用#就不要用$。</p>
<h4 id="4-使用MyBatis的mapper接口调用时有哪些要求？"><a href="#4-使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="4. 使用MyBatis的mapper接口调用时有哪些要求？"></a>4. 使用MyBatis的mapper接口调用时有哪些要求？</h4><p>有以下规则：</p>
<ul>
<li>Mapper接口方法名和mapper.xml中对应的sql的id相同 ；</li>
<li>Mapper接口方法的输入参数类型和mapper.xml中对应的sql 的parameterType的类型相同 ；</li>
<li>Mapper接口方法的输出参数类型和mapper.xml中对应的sql的resultType的类型相同 ；</li>
<li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li>
</ul>
<h4 id="5-谈谈mybatis中的一级缓存和二级缓存。"><a href="#5-谈谈mybatis中的一级缓存和二级缓存。" class="headerlink" title="5. 谈谈mybatis中的一级缓存和二级缓存。"></a>5. 谈谈mybatis中的一级缓存和二级缓存。</h4><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该Session中的所有 Cache 就将清空。</p>
<ul>
<li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap存储，不同在于其存储作用域为 Mapper(Namespace)，即对该namespance对应的配置文件中所有的select操作结果都缓存，这样不同线程之间就可以共用二级缓存。并且可自定义存储源，如 Ehcache。启动二级缓存：在mapper配置文件中加上：<cache>。</cache></li>
</ul>
<h4 id="6-在进行插入操作时如何回传ID？"><a href="#6-在进行插入操作时如何回传ID？" class="headerlink" title="6. 在进行插入操作时如何回传ID？"></a>6. 在进行插入操作时如何回传ID？</h4><p>在insert标签中配置如下属性即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"insert"</span> parameterType=<span class="string">"com.test.User"</span> keyProperty=<span class="string">"userId"</span> useGeneratedKeys=<span class="string">"true"</span> &gt; </span><br><span class="line">   ......</span><br><span class="line">&lt;<span class="regexp">/insert&gt;</span></span><br></pre></td></tr></table></figure>
<p>用keyProperty指定Id属性，把useGeneratedKeys设置为true即可。</p>
<h4 id="7-mapper接口工作原理是什么？"><a href="#7-mapper接口工作原理是什么？" class="headerlink" title="7. mapper接口工作原理是什么？"></a>7. mapper接口工作原理是什么？</h4><p>mapper接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为mapper接口生成代理对象，代理对象会拦截接口方法，转而执行对应的sql，然后将sql执行结果返回。</p>
<h4 id="8-mapper接口里的方法可以重载吗？为什么？"><a href="#8-mapper接口里的方法可以重载吗？为什么？" class="headerlink" title="8. mapper接口里的方法可以重载吗？为什么？"></a>8. mapper接口里的方法可以重载吗？为什么？</h4><p>不能重载。对应的xml映射文件是根据方法名将方法与sql语句绑定的，如果重载，将无法区分绑定哪个方法。</p>
<h4 id="9-你了解mybatis的动态SQL吗？"><a href="#9-你了解mybatis的动态SQL吗？" class="headerlink" title="9. 你了解mybatis的动态SQL吗？"></a>9. 你了解mybatis的动态SQL吗？</h4><p>动态SQL可以完成逻辑判断和动态拼接sql的功能。在mybatis的xml映射文件中，我们可以标签的形式编写动态sql。常用的动态sql标签有<if>、<where>、<set>等。</set></where></if></p>
<h4 id="10-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#10-Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="10. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>10. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h4><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置<code>lazyLoadingEnabled=true</code>来启用延迟加载。它的原理是使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<h4 id="四-、hibernate"><a href="#四-、hibernate" class="headerlink" title="(四)、hibernate"></a>(四)、hibernate</h4><p><strong>1. 简单的说一下hibernate的开发流程。</strong>  <strong>答：</strong>步骤如下：</p>
<ul>
<li>加载 hibernate 的配置文件，读取其他配置文件(jdbc.properties、表与对象关系映射文件);</li>
<li>创建 SessionFactory 会话工厂;</li>
<li>打开 session 获取连接，构造 session 对象(一次会话维持一个数据连接，也是一级缓存)</li>
<li>开启事务;</li>
<li>使用session进行操作 ；</li>
<li>提交事务；</li>
<li>关闭session；</li>
<li>关闭SessionFactory 。</li>
</ul>
<p><strong>2. 说说hibernate中对象的三种状态。</strong>  <strong>答：</strong>hibernate中，对象有以下3种状态：</p>
<ul>
<li>临时态：直接new出来的对象，不处于session的管理，数据库中没有对象的记录；调用save方法后就变成持久态。</li>
<li>持久态：当调用session的save/saveOrUpdate/get/load/list等方法的时候，对象就是持久化状态。处于session的管理，数据库中有对应的记录；调用delete方法后变成临时态，调用session.close()后就变成了游离态。</li>
<li>游离态：Session关闭后，对象的状态就是游离态。不处于session的管理，数据库中有对应的记录；调用update方法后又变成持久态。</li>
</ul>
<p><strong>3. 你知道hibernate的缓存吗？</strong>  <strong>答：</strong>使用缓存的目的就是减少对数据库的访问次数，以提高hibernate的执行效率。hibernate有一级缓存和二级缓存之分：</p>
<ul>
<li>一级缓存：也叫做session的缓存，它可以在session范围内减少数据库的访问次数，只在session范围有效，Session关闭，一级缓存失效，不同的session不会共享缓存数据。当调用session的 save/saveOrUpdate/get/load/list/iterator 方法的时候，都会把对象放入session的缓存中。 Session的缓存由hibernate维护， 用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作。</li>
<li>二级缓存：Hibernate提供了基于应用程序级别的缓存， 可以跨多个session，即不同的session都可以访问缓存数据。 这个缓存也叫二级缓存。Hibernate提供的二级缓存有默认的实现，且是一种可插配的缓存框架！如果用户想用二级缓存，只需要在hibernate.cfg.xml中配置即可，不想用，直接移除配置即可。如果用户觉得hibernate提供的缓存框架不好用，可以换其他的缓存框架或自己实现缓存框架都可以。</li>
</ul>
<p><strong>4. hibernate有几种查询方式？</strong>  <strong>答：</strong>hibernate有3种查询方式：</p>
<ul>
<li>HQL查询：面向对象的查询语言,提供了丰富灵活的查询方式。例子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> hql = <span class="string">"select userName from User"</span>; <span class="comment">// userName是实体类属性名而非表的字段名，User是实体类名</span></span><br><span class="line">Query query = session.createQuery(hql);</span><br><span class="line">List&lt;<span class="built_in">Object</span>&gt; nameList = query.list();</span><br></pre></td></tr></table></figure>
<ul>
<li>QBC(Query By Criteria)查询：Criteria对象提供了一种面向对象的方式查询数据库。Criteria对象需要使用Session对象来获得。例子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Criteria c = session.createCriteria(User.class);</span><br><span class="line">c.add(Restrictions.eq(<span class="string">"userName"</span>, <span class="string">"James"</span>));</span><br><span class="line">List&lt;User&gt; userList = c.list();</span><br></pre></td></tr></table></figure>
<ul>
<li>原生SQL查询：就是使用原生的SQL语句进行查询。例子：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> sql = <span class="string">"select id,username,userpwd from t_user"</span>;</span><br><span class="line">List list = session.createSQLQuery(sql).list();</span><br></pre></td></tr></table></figure>
<p><strong>5. hibernate的ORM思想你了解多少？</strong>  <strong>答：</strong>ORM 指的是对象关系映射(Object RelationShip Mapping )，指的就是实体类对象和数据库中的表关系进行一一对应，实现通过操作实体类对象来更改数据库里边的数据信息。这就是对象关系映射。hibernate框架也是一个orm框架，主要是通过主配置文件和实体类对应的映射配置文件来实现对象关系映射。</p>
<p><strong>6. 你知道hibernate的懒加载吗？</strong>  <strong>答：</strong>通过设置lazy属性开启懒加载(hibernate3之后默认开启)。当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，节省了服务器的内存开销，从而提高了服务器的性能。比如使用hibernate进行查询，可以使用get方法，也可以使用load方法，get方法不支持懒加载，而load方法支持。get方法会先查一级缓存，再查二级缓存，然后查数据库，如果没有找到会返回null。load方法会先查一级缓存，如果没有找到，就创建代理对象，等需要的时候去查询二级缓存和数据库。也就是说，使用load方法的时候，并不会立刻去数据库查找，等你真的要用到该对象的时候，才会去数据库查找，这就是懒加载。</p>
<p><strong>7. hibernate和mybatis有何异同？</strong>  <strong>答：</strong>异同如下：  <strong>(1).</strong>相同点：</p>
<ul>
<li>Hibernate与MyBatis都是由XML配置文件生成SessionFactory，然后由SessionFactory 生成 Session，最后由 Session 来开启执行事务和 SQL 语句。其中两者的SessionFactory，Session的生命周期都是差不多的。</li>
<li>Hibernate和MyBatis都支持JDBC和JTA事务处理。</li>
</ul>
<p><strong>(2).</strong>不同点：</p>
<ul>
<li>hibernate是全自动，而mybatis是半自动。hibernate完全可以通过对象关系模型实现对数据库的操作，会自动生成sql。而mybatis仅有基本的字段映射，对数据的操作还需要自己编写sql来实现。</li>
<li>hibernate数据库移植性远大于mybatis。因为hibernate不需要自己编写sql语句，所有与数据库解耦；而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性，用了很多数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</li>
<li>hibernate拥有完整的日志系统，mybatis则欠缺一些。hibernate日志系统非常健全，涉及广泛，而mybatis则除了基本记录功能外，功能薄弱很多。</li>
<li>sql优化上，mybatis要比hibernate方便很多。由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql。</li>
</ul>
<p>总的来说，mybatis小巧灵活，易于使用，而hibernate学习成本相对较高，数据库移植性好。</p>
<p><strong>8. 谈谈Hibernate中inverse的作用。</strong>  <strong>答：</strong>inverse属性默认是false,就是说双方都维护关联关系。 比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。如果Student这边inverse=”true”, 那么关系就由Teacher维护，就是说当插入Student时，不会操作TeacherStudent表。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false”或默认时，会导致在中间表中插入两次关系。</p>
<p><strong>9. Hibernate有哪些核心接口？</strong>  <strong>答：</strong>有如下核心接口：</p>
<ul>
<li>Configuration 接口：配置Hibernate，根据其启动hibernate，创建SessionFactory 对象；</li>
<li>SessionFactory 接口：初始化Hibernate，充当数据存储源的代理，创建session 对象，sessionFactory 是线程安全的，意味着它的同一个实例多个线程共享；</li>
<li>Session 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的， 避免多个线程共享同一个session；</li>
<li>Transaction 接口：管理事务；</li>
<li>Query 和Criteria 接口：执行数据库的查询。</li>
</ul>
<h4 id="五-、Redis"><a href="#五-、Redis" class="headerlink" title="(五)、Redis"></a>(五)、<a href="https://cloud.tencent.com/product/crs" target="_blank" rel="noopener">Redis</a></h4><p><strong>1. 什么是redis？</strong>  <strong>答：</strong>redis是使用C语言编写的典型的NoSQL数据库，它是一个key-value存储系统，数据存储在内存中，所以存取速度非常快。</p>
<p><strong>2. 为什么redis要把数据放到内存中？</strong>  <strong>答：</strong>Redis为了达到最快的读写速度将数据都读到内存中，并定期将数据写入磁盘。如果不将数据放在磁盘中，会严重影响 redis 的性能。</p>
<p><strong>3. redis支持哪些数据类型？</strong>  <strong>答：</strong>redis有5种基本数据类型，分别是String(字符串)、Hash(字典)、List(列表)、Set(集合)、Zset(有序集合)。</p>
<p><strong>4. 说说redis的优缺点。</strong>  <strong>答：</strong>优缺点如下：  <strong>(1).</strong> 优点：</p>
<ul>
<li>由于是基于内存的，所以性能极高。</li>
<li>支持丰富的数据类型。</li>
<li>Redis 的所有操作都是原子性的。</li>
</ul>
<p><strong>(2).</strong> 缺点：</p>
<ul>
<li>由于是内存数据库，所以单台机器存储的数据量，跟机器本身的内存大小。</li>
<li>如果进行完整重同步，由于需要生成 rdb 文件并进行传输，会占用主机的 CPU，消耗带宽。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>spring容器启动的加载过程</title>
    <url>/2019/03/25/spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>相当长  现在看不懂 以后有机会看一下 转载地址<a href="https://www.cnblogs.com/hjy9420/p/4218140.html" target="_blank" rel="noopener">https://www.cnblogs.com/hjy9420/p/4218140.html</a></p>
<a id="more"></a>
<p>使用spring，我们在web.xml都会配置ContextLoaderListener</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">          org.springframework.web.context.ContextLoaderListener</span><br><span class="line">      <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"><span class="comment">//由于他继承自ContextLoader，加载的时候当然会先加载他啦，那我们来看看这个类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ContextLoader这个类有一段静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"ContextLoader.properties"</span>;<span class="comment">//这个文件是在org.springframework.web.context.ContextLoader.properties他里面是</span></span><br><span class="line">org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext <span class="comment">//这个后面再研究 以后就会把spring所有重要的东西都能看到了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties defaultStrategies;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line">    <span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line">    <span class="comment">// by application developers.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);</span><br><span class="line">        defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);<span class="comment">//根据上面的properties文件，就能得到一个默认的properties了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load 'ContextLoader.properties': "</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步：我们在看看ContextLoaderListener的这个方法，在容器启动的时候，他会扫描web.xml的listener配置，然后自动调用Listener的contextInitialized初始化方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.contextLoader = createContextLoader();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.contextLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.contextLoader = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.contextLoader.initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 第二步：initWebApplicationContext初始化web应用上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) 		&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot initialize context because there is already a root application context present - "</span> + <span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">        servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line">            <span class="comment">// it is available on ServletContext shutdown.</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">                <span class="comment">//判断是否有WebApplicationContext，没有则创建，创建得到的是ConfigurableWebApplicationContext</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">                ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line">                <span class="keyword">if</span> (!cwac.isActive()) &#123;  <span class="comment">//上下文尚未活动</span></span><br><span class="line">                    <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                    <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                    <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">                        <span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">                        ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">                       <span class="comment">//决定根Web应用程序环境是否存在父应用程序环境，一般是返回null</span></span><br><span class="line">                        cwac.setParent(parent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">                    <span class="comment">//在这里是初始化web应用上下文的入口 ,spring的依赖注入也从这里开始了。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; 																	         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line">            <span class="comment">//把创建的根Web应用程序环境保存到Servlet环境中，每个派遣器Servlet加载的子环境会应用这个环境作为父环境    </span></span><br><span class="line"></span><br><span class="line">            ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            <span class="comment">//取得线程的类加载器</span></span><br><span class="line">            <span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">                currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">                <span class="comment">//如果线程和本类拥有相同的类加载器，则使用静态变量保存即可，因为同一类加载器加载同一份静态变量    </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">                <span class="comment">//如果线程和本类拥有不同的类加载器，则使用线程的类加载器作为键值保存在一个映射对象里，保证析构时能拿到Web应用程序环境进行关闭操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">                logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            logger.error(<span class="string">"Context initialization failed"</span>, ex); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">            <span class="comment">//如果产生任何异常，则保存异常对象到Servlet环境里 </span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">            logger.error(<span class="string">"Context initialization failed"</span>, err); servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">            <span class="comment">//如果产生任何错误，则保存错误对象到Servlet环境里</span></span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第三步：得到具体的应用上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTEXT_CLASS_PARAM = <span class="string">"contextClass"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"ContextLoader.properties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Properties defaultStrategies;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个静态代码块，会去加载相同目录下的ContextLoader.properties，这个目录是org.springframework.web.context，这个配置文件的配置信息就只有org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line">        <span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line">        <span class="comment">// by application developers.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);</span><br><span class="line">            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load 'ContextLoader.properties': "</span> + ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ServletContext sc)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; contextClass = determineContextClass(sc);<span class="comment">//决定要得到哪个ContextClass</span></span><br><span class="line">        <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Custom context class ["</span> + contextClass.getName() + <span class="string">"] is not of type ["</span> + ConfigurableWebApplicationContext.class.getName() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);   <span class="comment">//实例化Web应用程序环境类 </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">        String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);<span class="comment">//获取web.xml配置的contextClass</span></span><br><span class="line">        <span class="keyword">if</span> (contextClassName != <span class="keyword">null</span>) &#123;<span class="comment">//配置了contextClass,返回具体的Class</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                        <span class="string">"Failed to load custom context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());<span class="comment">//在上面的静态代码块中已经加载了XmlWebApplicationContext，返回的是XmlWebApplicationContext的全路径名：org.springframework.web.context.support.XmlWebApplicationContext</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());<span class="comment">//没有配置contextClass,则通过配置文件，返回了XmlWebApplicationContext的class</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                        <span class="string">"Failed to load default context class ["</span> + contextClassName + <span class="string">"]"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步：用于封装ApplicationContext数据并且初始化所有相关Bean对象。它会从web.xml中读取名为contextConfigLocation的配置，这就是spring xml数据源设置，然后放到ApplicationContext中，最后调用传说中的refresh方法执行所有Java对象的创建。</p>
<p>public static final String CONFIG_LOCATION_PARAM = “contextConfigLocation”;  在wen.xml中配置的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">        <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">        <span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">        String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">        <span class="comment">//设置Web应用程序环境的ID  </span></span><br><span class="line">        <span class="keyword">if</span> (idParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac.setId(idParam);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generate default id...</span></span><br><span class="line">             <span class="comment">//如果 Servlet规范 &lt;= 2.4，则使用web.xml里定义的应用程序名字定义Web应用程序名</span></span><br><span class="line">            <span class="keyword">if</span> (sc.getMajorVersion() == <span class="number">2</span> &amp;&amp; sc.getMinorVersion() &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// Servlet &lt;= 2.4: resort to name specified in web.xml, if any.</span></span><br><span class="line">                wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">                        ObjectUtils.getDisplayString(sc.getServletContextName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果Servlet规范是 2.5， 则使用配置的ContextPath定义Web应用程序名 </span></span><br><span class="line">                wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">                        ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存Servlet环境    </span></span><br><span class="line">    wac.setServletContext(sc);</span><br><span class="line">    String initParameter = sc.getInitParameter(CONFIG_LOCATION_PARAM);<span class="comment">//这里得到"contextConfigLocation"配置的值:classpath*:spring-config.xml,</span></span><br><span class="line">    <span class="keyword">if</span> (initParameter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(initParameter);<span class="comment">//设置保存ConfigLocation，待后面加载的时候，扫描里面的配置</span></span><br><span class="line">    &#125;</span><br><span class="line">    customizeContext(sc, wac);<span class="comment">//提供子类可互换Web应用程序环境的机会 占位符方法  </span></span><br><span class="line">    wac.refresh();<span class="comment">//刷新Web应用程序环境以加载Bean定义,这里才是把我们XML里定义的bean放入容器的时候  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  “contextConfigLocation”在web.xml的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:spring-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第五步：bean的注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">            prepareRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<span class="comment">//告诉子类刷新内部bean工厂。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">            prepareBeanFactory(beanFactory);<span class="comment">//准备bean工厂给上下文使用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">                postProcessBeanFactory(beanFactory);<span class="comment">//允许在上下文后处理bean工厂的子类</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">                invokeBeanFactoryPostProcessors(beanFactory);<span class="comment">//调用处理器工厂注册的bean上下文</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">                registerBeanPostProcessors(beanFactory);注册bean拦截器拦截bean的创建</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">                initMessageSource();<span class="comment">//给上下文初始化消息来源</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">                initApplicationEventMulticaster();<span class="comment">//给上下文初始化事件多播</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Initialize other special beans in specific context subclasses.//在特定上下文初始化其他特殊bean子类</span></span><br><span class="line">                onRefresh();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">                registerListeners();<span class="comment">//检查监听器bean并注册他们</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">                finishBeanFactoryInitialization(beanFactory);<span class="comment">//实例化所有剩余(non-lazy-init)单例对象</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">                finishRefresh();<span class="comment">//发布相应的事件</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">                destroyBeans();<span class="comment">//销毁已经创建的单例，避免悬挂的资源</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">                cancelRefresh(ex);<span class="comment">//重置“活跃”标志</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第六步:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refreshBeanFactory();<span class="comment">//具体实现调用子类容器的refreshBeanFactory()方法 </span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第七步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRefreshableApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Bean factory for this context */</span></span><br><span class="line">    <span class="keyword">private</span> DefaultListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//如果已经有beanfactory了，则销毁所有的bean,关闭beanfactory</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanFactory()) &#123;  </span><br><span class="line">            destroyBeans();</span><br><span class="line">            closeBeanFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到一个默认的DefaultListableBeanFactory</span></span><br><span class="line">            DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">            beanFactory.setSerializationId(getId());</span><br><span class="line">            <span class="comment">//对IoC容器进行定制化，如设置启动参数，开启注解的自动装配等 </span></span><br><span class="line">            customizeBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">//调用载入Bean定义的方法，主要这里又使用了一个委派模式，在当前类中只定义了抽象的loadBeanDefinitions方法，具体的实现调用子类容器  </span></span><br><span class="line">            loadBeanDefinitions(beanFactory);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建beanfactory</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeansException, IOException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第八步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlWebApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshableWebApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Default config location for the root context */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONFIG_LOCATION = <span class="string">"/WEB-INF/applicationContext.xml"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Default prefix for building a config location for a namespace */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONFIG_LOCATION_PREFIX = <span class="string">"/WEB-INF/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Default suffix for building a config location for a namespace */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONFIG_LOCATION_SUFFIX = <span class="string">".xml"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">         <span class="comment">//创建XmlBeanDefinitionReader，即创建Bean读取器，并通过回调设置到容器中去，容器使用该读取器读取Bean定义资源  </span></span><br><span class="line">        XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">        <span class="comment">// resource loading environment.</span></span><br><span class="line">        <span class="comment">//设置环境</span></span><br><span class="line">        beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        <span class="comment">//为Bean读取器设置Spring资源加载器，AbstractXmlApplicationContext的祖先父类AbstractApplicationContext，他继承DefaultResourceLoader，因此容器本身也是一个资源加载器  </span></span><br><span class="line">        beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//为Bean读取器设置SAX xml解析器 </span></span><br><span class="line">        beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">        <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">        <span class="comment">//当Bean读取器读取Bean定义的Xml资源文件时，启用Xml的校验机制 </span></span><br><span class="line">        initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">        <span class="comment">//Bean读取器真正实现加载的方法 </span></span><br><span class="line">        loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取配置资源的定位 </span></span><br><span class="line">        String[] configLocations = getConfigLocations();</span><br><span class="line">        <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String configLocation : configLocations) &#123;</span><br><span class="line">            <span class="comment">//XmlBean读取器调用其父类AbstractBeanDefinitionReader读取定位的Bean定义资源  </span></span><br><span class="line">                reader.loadBeanDefinitions(configLocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第九步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定的资源加载bean定义，返回bean定义的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        ResourceLoader resourceLoader = getResourceLoader();<span class="comment">//得到资源加载器</span></span><br><span class="line">        <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">            <span class="comment">// Resource pattern matching available.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">                <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);<span class="comment">//得到加载bean定义的数量，而且在这里将bean定义注入进了spring容器中</span></span><br><span class="line">                <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                        actualResources.add(resource);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> loadCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                        <span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">            Resource resource = resourceLoader.getResource(location);</span><br><span class="line">            <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                actualResources.add(resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            counter += loadBeanDefinitions(resource);<span class="comment">//加载不同的资源类型，使用不同的具体子类来加载，这里使用的是xml。所以他的子类是XmlBeanDefinitionReader，还有一个子类是PropertiesBeanDefinitionReader</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第十步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//这里是调用的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encodedResource the resource descriptor for the XML file,</span></span><br><span class="line"><span class="comment">     * allowing to specify an encoding to use for parsing the file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//这里是载入XML形式的BeanDefinition的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">        <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentResources = <span class="keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里得到XML文件，并得到IO的InputStream准备进行读取</span></span><br><span class="line">            InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">                <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            currentResources.remove(encodedResource);</span><br><span class="line">            <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第十一步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Actually load bean definitions from the specified XML file.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resource the resource descriptor for the XML file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of bean definitions found</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//具体的读取过程。这是从特定的XML文件中实际载入的BeanDefinition的地方</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> validationMode = getValidationModeForResource(resource);</span><br><span class="line">            <span class="comment">//取得XML文件的Document对象，这个解析过程由DocumentLoader完成，这个DocumentLoader是DefaultDocumentLoader,在定义DocumentLoader的地方创建</span></span><br><span class="line">            Document doc = <span class="keyword">this</span>.documentLoader.loadDocument(</span><br><span class="line">                    inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler, validationMode, isNamespaceAware());</span><br><span class="line">            <span class="comment">//启动对BeanDefinition解析的详细过程，这个解析会使用到Spring的Bean配置规则。</span></span><br><span class="line">            <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                    <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第十二步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        <span class="comment">//这里得到BeanDefinitionDocumentReader来对XML的BeanDefinition进行解析</span></span><br><span class="line">        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">        documentReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">        <span class="comment">//根据通用的XML进行解析，并没有根据Spring的Bean规则</span></span><br><span class="line">        <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">        <span class="comment">//具体的解析过程在这个registerBeanDefinitions中完成,这里是按照Spring的Bean规则进行解析</span></span><br><span class="line">        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">        <span class="comment">//总的Bean减去通用的，剩下就是spring的bean规则的bean个数</span></span><br><span class="line">        <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create the &#123;<span class="doctag">@link</span> BeanDefinitionDocumentReader&#125; to use for actually</span></span><br><span class="line"><span class="comment">     * reading bean definitions from an XML document.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation instantiates the specified "documentReaderClass".</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setDocumentReaderClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//创建BeanDefinitionDocumentReader</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第十三步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBeanDefinitionDocumentReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation parses bean definitions according to the "spring-beans" XSD</span></span><br><span class="line"><span class="comment">     * (or DTD, historically).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Opens a DOM Document; then initializes the default settings</span></span><br><span class="line"><span class="comment">     * specified at the &#123;<span class="doctag">@code</span> &lt;beans/&gt;&#125; level; then parses the contained bean definitions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//根据spring的bean规则解析bean的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">        Element root = doc.getDocumentElement();</span><br><span class="line"></span><br><span class="line">        doRegisterBeanDefinitions(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            Assert.state(<span class="keyword">this</span>.environment != <span class="keyword">null</span>, <span class="string">"environment property must not be null"</span>);</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.environment.acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.delegate = createHelper(readerContext, root, parent);</span><br><span class="line"></span><br><span class="line">        preProcessXml(root);</span><br><span class="line">        <span class="comment">//委派给delegate解析</span></span><br><span class="line">        parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        postProcessXml(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            NodeList nl = root.getChildNodes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">                Node node = nl.item(i);</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                    Element ele = (Element) node;</span><br><span class="line">                    <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                        parseDefaultElement(ele, delegate);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        delegate.parseCustomElement(ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            delegate.parseCustomElement(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  第十四步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionParserDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里面定义了大量的bean的属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">        String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">        NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第十五步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamespaceHandlerSupport</span> <span class="keyword">implements</span> <span class="title">NamespaceHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里就是解析Bean得到BeanDefinition的地方了</span></span><br><span class="line">        <span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Locates the &#123;<span class="doctag">@link</span> BeanDefinitionParser&#125; from the register implementations using</span></span><br><span class="line"><span class="comment">     * the local name of the supplied &#123;<span class="doctag">@link</span> Element&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">        BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">        <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">            parserContext.getReaderContext().fatal(</span><br><span class="line">                    <span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的BeanDefinitionParser中的parse，有很多种BeanDefinitionParser对其进行解析，BeanDefinitionParser接口就定义了一个BeanDefinition parse(Element element, ParserContext parserContext);专业用来解析bean的，具体的实现交给他的具体。结构如下图：</p>
<p><img src="/2019/03/25/spring容器启动的加载过程/121107246837615.png" alt="img"></p>
<p>我们来看下这个ComponentScanBeanDefinitionParser</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentScanBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这两个是我们常用的属性配置 当然还有别的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ANNOTATION_CONFIG_ATTRIBUTE = <span class="string">"annotation-config"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PACKAGE_ATTRIBUTE = <span class="string">"base-package"</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是他解析的地方了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE),</span><br><span class="line">                ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">        ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">        <span class="comment">//得到ClassPathBeanDefinitionScanner，通过它去扫描包中的类文件，注意：这里是类文件而不是类，因为现在这些类还没有被加载，只是ClassLoader能找到这些class的路径而已。</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">        registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ... </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第十六步：再来看看ClassPathBeanDefinitionScanner的doScan方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">        <span class="comment">//用来保存BeanDefinitionHolder，即Bean的属性</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            <span class="comment">//得到扫描出来的类</span></span><br><span class="line">            Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">            <span class="comment">//得到扫描出来的类后，把他加进beanDefinitions中</span></span><br><span class="line">            <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">                ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">                candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                    postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                    beanDefinitions.add(definitionHolder);</span><br><span class="line">                    registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  第十七：ClassPathScanningCandidateComponentProvider的findCandidateComponents方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathScanningCandidateComponentProvider</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_RESOURCE_PATTERN = <span class="string">"**/*.class"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ResourcePatternResolver resourcePatternResolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个candidates，用来保存BeanDefinition</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">                    resolveBasePackage(basePackage) + <span class="string">"/"</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">            Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line">            <span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line">            <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                    logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                        <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                            <span class="comment">//封装一个ScannedGenericBeanDefinition，并设置属性，然后添加进candidates中。</span></span><br><span class="line">                            ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">                            sbd.setResource(resource);</span><br><span class="line">                            sbd.setSource(resource);</span><br><span class="line">                            <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                    logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line">                                &#125;</span><br><span class="line">                                candidates.add(sbd);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                                    logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + resource);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                                logger.trace(<span class="string">"Ignored because not matching any filter: "</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                                <span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">                        logger.trace(<span class="string">"Ignored because not readable: "</span> + resource);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidates;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看这两句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + <span class="string">"/"</span> + <span class="keyword">this</span>.resourcePattern;</span><br></pre></td></tr></table></figure>
<p>假设我们配置的需要扫描的包名为<code>com.cengle.service</code>，那么<code>packageSearchPath</code>的值就是<code>classpath*:com.cengle.service/**/*.class</code>，意思就是com.cengle.service包(包括子包)下所有class文件；如果配置的是<code>*</code>，那么<code>packageSearchPath</code>的值就是<code>classpath*:*/**/*.class</code>。这里的表达式是Spring自己定义的。Spring会根据这种表达式找出相关的class文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br></pre></td></tr></table></figure>
<p>  这些资源是怎么得到的。看下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">        <span class="comment">//判断是否以classpath*:开头</span></span><br><span class="line">        <span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">            <span class="comment">// a class path resource (multiple resources for same name possible)</span></span><br><span class="line">            <span class="comment">//判断多个资源是否有相同的名称</span></span><br><span class="line">            <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">                <span class="comment">// a class path resource pattern</span></span><br><span class="line">                <span class="comment">//得到类路径的资源模式</span></span><br><span class="line">                <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// all class path resources with the given name</span></span><br><span class="line">                <span class="comment">//得到所有的类路径资源名字</span></span><br><span class="line">                <span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Only look for a pattern after a prefix here</span></span><br><span class="line">            <span class="comment">// (to not get fooled by a pattern symbol in a strange prefix).</span></span><br><span class="line">            <span class="keyword">int</span> prefixEnd = locationPattern.indexOf(<span class="string">":"</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">                <span class="comment">// a file pattern</span></span><br><span class="line">                <span class="comment">//得到文件模式</span></span><br><span class="line">                <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// a single resource with the given name</span></span><br><span class="line">                <span class="comment">//得到一个给定名称的资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Find all class location resources with the given location via the ClassLoader.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> location the absolute path within the classpath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result as Resource array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException in case of I/O errors</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.ClassLoader#getResources</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #convertClassLoaderURL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Resource[] findAllClassPathResources(String location) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String path = location;</span><br><span class="line">        <span class="keyword">if</span> (path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            path = path.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据路径，将资源存进一个迭代器中</span></span><br><span class="line">        Enumeration&lt;URL&gt; resourceUrls = getClassLoader().getResources(path);</span><br><span class="line">        Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">while</span> (resourceUrls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = resourceUrls.nextElement();</span><br><span class="line">            <span class="comment">//将迭代器的元素存进set集合中</span></span><br><span class="line">            result.add(convertClassLoaderURL(url));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将集合转化为数组</span></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[result.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line">        String subPattern = locationPattern.substring(rootDirPath.length());</span><br><span class="line">        <span class="comment">//根据路径，得到一个资源数组</span></span><br><span class="line">        Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line">        Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;Resource&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//循环数组，将数组元素放进一个set集合中。</span></span><br><span class="line">        <span class="keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">            rootDirResource = resolveRootDirResource(rootDirResource);</span><br><span class="line">            <span class="keyword">if</span> (isJarResource(rootDirResource)) &#123;</span><br><span class="line">                result.addAll(doFindPathMatchingJarResources(rootDirResource, subPattern));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rootDirResource.getURL().getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">                result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirResource, subPattern, getPathMatcher()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Resolved location pattern ["</span> + locationPattern + <span class="string">"] to resources "</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将集合转化为数组</span></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[result.size()]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Spring也是用的<code>ClassLoader</code>加载的class文件。一路追踪，原始的ClassLoader是<code>Thread.currentThread().getContextClassLoader();</code>。到此为止，就拿到class文件了。<br>Spring会将class信息封装成<code>BeanDefinition</code>，然后再放进<code>DefaultListableBeanFactory</code>的<code>beanDefinitionMap</code>中。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用设计模式</title>
    <url>/2019/03/21/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>在Java中，传说有23中模式，总共分为三大类，分别是：</p>
<ul>
<li><strong>创建型</strong>模式(5种)：<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>建造者模式</strong>、<strong>单例模式</strong>、原型模式；</li>
<li>结构型模式(7种)：<strong>适配器模式</strong>、<strong>装饰器模式</strong>、代理模式、外观模式、桥接模式、组合模式、享元模式；</li>
<li>行为型模式(11种)：<strong>策略模式</strong>、<strong>模板方法模式</strong>、<strong>观察者模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>
</ul>
<a id="more"></a>
<h3 id="一、工厂方法模式："><a href="#一、工厂方法模式：" class="headerlink" title="一、工厂方法模式："></a>一、工厂方法模式：</h3><p>工厂是干嘛的，就是用来生产的嘛，这里说的工厂也是用来生产的，它是用来生产对象的。也就是说，有些对象我们可以在工厂里面生产，需要用时直接从工厂里面拿出来即可，而不用每次需要用的时候都去new对象。工厂方法模式又分为以下三种：</p>
<ul>
<li><strong>普通工厂模式：</strong>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</li>
<li><strong>多个工厂方法模式：</strong>是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。</li>
<li><strong>静态工厂方法模式：</strong>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</li>
</ul>
<p>上面三个模式中，后一个都是对前一个的改良。下面分别看看这三个模式的具体案例。</p>
<p><strong>情景：</strong>有一个发送消息的接口，有两个实现类，一个是发送短信，一个是发送邮件。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line">public interface Sender &#123;</span><br><span class="line">  public <span class="keyword">void</span> Send();</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//实现一</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="title">implements</span> <span class="title">Sender</span> </span>&#123; </span><br><span class="line">  @Override</span><br><span class="line">  public <span class="keyword">void</span> Send() &#123;</span><br><span class="line">     System.out.println(<span class="string">"this is mail sender!"</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//实现二</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="title">implements</span> <span class="title">Sender</span> </span>&#123; </span><br><span class="line">  @Override</span><br><span class="line">  public <span class="keyword">void</span> Send() &#123; </span><br><span class="line">     System.out.println(<span class="string">"this is sms sender!"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就看看用这三种工厂方法模式分别要怎么做。</p>
<ul>
<li><strong>普通工厂模式：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> public <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123; </span><br><span class="line">   public Sender produce(<span class="built_in">String</span> type) &#123; </span><br><span class="line">       <span class="keyword">if</span> (<span class="string">"mail"</span>.equals(type)) &#123; </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"sms"</span>.equals(type)) &#123; </span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SmsSender(); </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">           System.out.println(<span class="string">"请输入正确的类型!"</span>); </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候就创建这个工厂的对象，调用produce方法，需要发邮件就传入”mail”，需要发短信就传入”sms”，如果传入的是别的内容，就不会创建任何对象。</p>
<ul>
<li><strong>多个工厂方法模式：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123; </span><br><span class="line">   public Sender produceMail()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">   &#125;</span><br><span class="line">   public Sender produceSms()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>普通工厂模式生产对象都是在一个方法内完成，多个工厂方法模式是提供多个方法，分别生产对应的对象。使用时先创建工厂的实例，要发短信就调用生产短信实例的方法，要发邮件就调用生产邮件实例的方法。</p>
<ul>
<li><strong>静态工厂方法模式：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">  public <span class="keyword">static</span> Sender produceMail()&#123;   </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> MailSender(); </span><br><span class="line">  &#125; </span><br><span class="line">  public <span class="keyword">static</span> Sender produceSms()&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是多个工厂方法模式里面的方法设为静态的，这样可以直接通过工厂类的类名调用，更加方便。</p>
<h3 id="二、抽象工厂模式："><a href="#二、抽象工厂模式：" class="headerlink" title="二、抽象工厂模式："></a>二、抽象工厂模式：</h3><p>上面的工厂方法模式有一个缺点，就是类的创建依赖工厂类，比如现在还可以用微信发消息，那么就得在工厂类中新增一个创建WeChat实体的方法。这样就违背了开闭原则。如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，就不需要修改之前的工厂类代码。 上面的案例代码就可以修改成下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂类接口</span></span><br><span class="line">public interface Provider &#123;</span><br><span class="line">    public Sender produce();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产SmsSender对象的工厂</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendSmsFactory</span> <span class="title">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">  @Override</span><br><span class="line">   public Sender produce() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产MailSender对象的工厂</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SendMailFactory</span> <span class="title">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public Sender produce() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">       Provider provider = <span class="keyword">new</span> SendMailFactory();</span><br><span class="line">       Sender sender = provider.produce(); </span><br><span class="line">       sender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样即使要新增生产WechatSender实例的方法，也不需要修改现有代码，只需实现工厂接口，重写生产方法即可。从工厂方法模式到抽象工厂模式，后者更加体现了Java的封装、抽象等思想。</p>
<h3 id="三、建造者模式："><a href="#三、建造者模式：" class="headerlink" title="三、建造者模式："></a>三、建造者模式：</h3><p>工厂模式提供的是创建单个类实例的模式，而建造者模式可以理解为是批量生产。还是使用工厂方法模式中的情景，看看用建造者模式怎么实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建造类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123; </span><br><span class="line">   private List&lt;Sender&gt; list = <span class="keyword">new</span> ArrayList&lt;Sender&gt;();</span><br><span class="line">   public <span class="keyword">void</span> produceMailSender(int count) &#123; <span class="comment">// 生产count个MailSender</span></span><br><span class="line">      <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> MailSender());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public <span class="keyword">void</span> produceSmsSender(int count) &#123; <span class="comment">// 生产count个SmsSender</span></span><br><span class="line">      <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           list.add(<span class="keyword">new</span> SmsSender());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* =========================== 使用 ============================*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestBuilder</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">      Builder builder = <span class="keyword">new</span> Builder();</span><br><span class="line">      builder.produceMailSender(<span class="number">10</span>); <span class="comment">// 生产10个MailSender</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、单例模式："><a href="#四、单例模式：" class="headerlink" title="四、单例模式："></a>四、单例模式：</h3><p>什么叫单例，就是保证一个类在内存中只有一个对象。Runtime()方法就是单例设计模式进行设计的。如何保证内存中只有一个对象呢？  <strong>设计思路：</strong></p>
<ul>
<li>不让其他程序创建该类对象。</li>
<li>在本类中创建一个本类对象。</li>
<li>对外提供方法，让其他程序获取这个对象。</li>
</ul>
<p><strong>实现步骤：</strong></p>
<ul>
<li>私有化构造函数；</li>
<li>创建私有并静态的本类对象；</li>
<li>定义公有并静态的方法，返回该对象。</li>
</ul>
<p><strong>代码实现：</strong></p>
<ul>
<li>懒汉式：延迟加载</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    private Single()&#123;&#125; <span class="comment">// 将构造方法私有化</span></span><br><span class="line">    private <span class="keyword">static</span> Single s = <span class="literal">null</span>; <span class="comment">// 私有静态的本类对象</span></span><br><span class="line">    public <span class="keyword">static</span> synchronized Single getInstance()&#123; <span class="comment">// 静态公共的返回对象的方法</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">null</span>)</span><br><span class="line">            s = <span class="keyword">new</span> Single();</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>饿汉式：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    private Single()&#123;&#125; <span class="comment">//私有化构造函数。</span></span><br><span class="line">    private <span class="keyword">static</span> Single s = <span class="keyword">new</span> Single(); <span class="comment">//创建私有并静态的本类对象。</span></span><br><span class="line">    public <span class="keyword">static</span> Single getInstance()&#123; <span class="comment">//定义公有并静态的方法，返回该对象。</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、适配器模式："><a href="#五、适配器模式：" class="headerlink" title="五、适配器模式："></a>五、适配器模式：</h3><p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为以下三类：</p>
<ul>
<li>类的适配器模式：比如一个类有一个方法method1，但是客户端使用的时候还需要一个method2方法，那就可以将method1和method2方法写进接口中，然后新建一个适配器类继承原来的类并实现这个接口。</li>
<li>对象的适配器模式：与类适配器相比，不需再继承source类，而是将source的对象传过去。</li>
<li>接口的适配器模式</li>
</ul>
<p>看一下具体用代码怎么体现：</p>
<ul>
<li>类的适配器模式：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">void</span> method1() &#123;</span><br><span class="line">     System.out.println(<span class="string">"这是method1方法"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建接口</span></span><br><span class="line">public interface Targetable &#123; </span><br><span class="line">   <span class="comment">/* 与原类中的方法相同 */</span> </span><br><span class="line">   public <span class="keyword">void</span> method1();  </span><br><span class="line">   <span class="comment">/* 新类的方法 */</span></span><br><span class="line">   public <span class="keyword">void</span> method2(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 适配类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="title">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">   @Override</span><br><span class="line">   public <span class="keyword">void</span> method2() &#123; </span><br><span class="line">      System.out.println(<span class="string">"这是method2方法"</span>); </span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* ===================== 使用 ======================*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">      Targetable target = <span class="keyword">new</span> Adapter(); </span><br><span class="line">      target.method1(); </span><br><span class="line">      target.method2(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对象的适配器模式：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">void</span> method1() &#123;</span><br><span class="line">     System.out.println(<span class="string">"这是method1方法"</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line">public interface Targetable &#123;</span><br><span class="line">   <span class="comment">/* 与原类中的方法相同 */</span></span><br><span class="line">   public <span class="keyword">void</span> method1();</span><br><span class="line">   <span class="comment">/* 新类的方法 */</span></span><br><span class="line">   public <span class="keyword">void</span> method2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="title">implements</span> <span class="title">Targetable</span> </span>&#123; </span><br><span class="line">   private Source source;</span><br><span class="line">   public Wrapper(Source source) &#123; </span><br><span class="line">      <span class="keyword">super</span>(); </span><br><span class="line">      <span class="keyword">this</span>.source = source;</span><br><span class="line">   &#125; </span><br><span class="line">   @Override</span><br><span class="line">   public <span class="keyword">void</span> method2() &#123;</span><br><span class="line">      System.out.println(<span class="string">"this is the targetable method!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   @Override</span><br><span class="line">   public <span class="keyword">void</span> method1() &#123;</span><br><span class="line">       source.method1();</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ======================= 使用 =========================*/</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">   public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">      Source source = <span class="keyword">new</span> Source();</span><br><span class="line">      Targetable target = <span class="keyword">new</span> Wrapper(source);</span><br><span class="line">      target.method1();</span><br><span class="line">      target.method2();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与类的适配器模式不同的是，对象的适配器模式不再继承source类，而是直接将source对象传到Wrapper类就可以了。   </p>
<ul>
<li>接口的适配器模式</li>
</ul>
<p>接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。</p>
<h3 id="六、装饰器模式："><a href="#六、装饰器模式：" class="headerlink" title="六、装饰器模式："></a>六、装饰器模式：</h3><p>装饰模式就是给一个对象动态的增加一些新的功能。要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。 这样说得也很抽象，看看具体的案例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line">public interface Sourceable &#123;</span><br><span class="line">    public <span class="keyword">void</span> method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被装饰的类，实现Sourceable接口</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="title">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> method() &#123;</span><br><span class="line">        System.out.println(<span class="string">"the original method!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 装饰的类，也要实现Sourceable 接口</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="title">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">    private Sourceable source; <span class="comment">// 持有被装饰类的对象</span></span><br><span class="line">    public Decorator(Sourceable source) &#123;</span><br><span class="line">         <span class="keyword">super</span>();</span><br><span class="line">         <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> method() &#123;</span><br><span class="line">         System.out.println(<span class="string">"before decorator!"</span>); <span class="comment">// 装饰</span></span><br><span class="line">         source.method(); </span><br><span class="line">         System.out.println(<span class="string">"after decorator!"</span>); <span class="comment">// 装饰</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">         Sourceable source = <span class="keyword">new</span> Source();</span><br><span class="line">         Sourceable obj = <span class="keyword">new</span> Decorator(source);</span><br><span class="line">         obj.method();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IO流体系中很多类就用到了这种设计模式。</p>
<h3 id="七、策略模式："><a href="#七、策略模式：" class="headerlink" title="七、策略模式："></a>七、策略模式：</h3><p>策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。看看具体的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line">public interface Strategy &#123;</span><br><span class="line">    public <span class="keyword">void</span> strategyInterface();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略类A</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="title">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> strategyInterface() &#123;</span><br><span class="line">        <span class="comment">// 相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略类B</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="title">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> strategyInterface() &#123;</span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用策略的类</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    public Context(Strategy strategy)&#123; <span class="comment">// 构造函数，传入一个具体策略对象</span></span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">void</span> contextInterface()&#123; <span class="comment">// 策略方法</span></span><br><span class="line">        strategy.strategyInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建Context类对象的时候，需要使用哪个策略就传入该策略，然后就可以使用。</p>
<h3 id="八、模板方法模式："><a href="#八、模板方法模式：" class="headerlink" title="八、模板方法模式："></a>八、模板方法模式：</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。简单的说就是很多相同的步骤，只是在某一些地方有差别，那么就可以使用这种模式。看例子：</p>
<ul>
<li>获取一段程序运行时间的模板：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public abstract <span class="class"><span class="keyword">class</span> <span class="title">GetTime</span></span>&#123;</span><br><span class="line">      public long getTime()&#123;</span><br><span class="line">         long  start = System.currentTimeMillis;</span><br><span class="line">         <span class="comment">//表示要计算运行时间的代码</span></span><br><span class="line">         code();</span><br><span class="line">         long  end = System.currentTimeMillis;</span><br><span class="line">         <span class="keyword">return</span> end-start;</span><br><span class="line">      &#125;</span><br><span class="line">      public abstract <span class="keyword">void</span> code(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用该模板：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">forDemo</span> <span class="keyword">extends</span> <span class="title">GetTime</span></span>&#123;</span><br><span class="line">     <span class="comment">//重写抽象方法</span></span><br><span class="line">     public <span class="keyword">void</span> code()&#123;</span><br><span class="line">          <span class="keyword">for</span>(int x=<span class="number">0</span>;x&lt;<span class="number">1000</span>;x++)&#123;</span><br><span class="line">                 System.out.println(x);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">     GetTime gt=<span class="keyword">new</span> forDemo();</span><br><span class="line">     gt.getTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以计算那个for循环运行的时间了。</p>
<h3 id="九、观察者模式："><a href="#九、观察者模式：" class="headerlink" title="九、观察者模式："></a>九、观察者模式：</h3><p>在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新，这就是观察者模式。  <strong>情景：</strong>有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。  示例代码：</p>
<ul>
<li>定义一个被观察者接口：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public interface BeObserverd &#123;</span><br><span class="line">    public <span class="keyword">void</span> registerObserver(Observer o);<span class="comment">// 添加观察者</span></span><br><span class="line">    public <span class="keyword">void</span> removeObserver(Observer o);<span class="comment">// 删除观察者</span></span><br><span class="line">    public <span class="keyword">void</span> notifyObserver();<span class="comment">// 通知观察者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个观察者接口：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> message);<span class="comment">// 当被观察者发出通知时，这个方法就会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义被观察者，实现了BeObserverd接口，对BeObserverd接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被观察者，也就是微信公众号服务实现了BeObserverd接口，对BeObserverd接口的三个方法进行了具体实现</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WechatServer</span> <span class="title">implements</span> <span class="title">BeObserverd</span> </span>&#123;</span><br><span class="line">    private List&lt;Observer&gt; list;</span><br><span class="line">    private <span class="built_in">String</span> message;</span><br><span class="line">    public WechatServer() &#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;(); <span class="comment">// 观察者的集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新增观察者</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> registerObserver(Observer o) &#123;</span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除观察者</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> removeObserver(Observer o) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())</span><br><span class="line">            list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给观察者发通知</span></span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> notifyObserver() &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            Observer observer = list.get(i);</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模拟公众号推送消息的方法</span></span><br><span class="line">    public <span class="keyword">void</span> setInfomation(<span class="built_in">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = s;</span><br><span class="line">        System.out.println(<span class="string">"微信服务更新消息： "</span> + s);</span><br><span class="line">        <span class="comment">//消息更新，通知所有观察者</span></span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义具体观察者，微信公众号的具体观察者为用户User。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="title">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    private <span class="built_in">String</span> name;</span><br><span class="line">    private <span class="built_in">String</span> message;</span><br><span class="line">    public User(<span class="built_in">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> update(<span class="built_in">String</span> message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">        public <span class="keyword">void</span> read() &#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 收到推送消息： "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如现有三个人关注公众号，当微信公众号调用setInfomation方法发送推文时，通过调用notifyObserver方法，通知每个观察者，在notifyObserver方法里调用update方法，update里面调用read方法，三个人都能收到推送；加入现在有人取消关注了，那么就会调用removeObserver方法，下次推送这个人就收不到了。(本案例参考<a href="https://www.cnblogs.com/luohanguo/p/7825656.html" target="_blank" rel="noopener">罗汉果</a>的博文，感谢大神整理！)</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql整理</title>
    <url>/2019/03/21/mysql%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。</p>
<p>每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。</p>
<p>我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。</p>
<p>所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p>
<p>RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：</p>
<ul>
<li>1.数据以表格的形式出现</li>
<li>2.每行为各种记录名称</li>
<li>3.每列为记录名称所对应的数据域</li>
<li>4.许多的行和列组成一张表单</li>
<li>5.若干的表单组成database</li>
</ul>
<h2 id="RDBMS-术语"><a href="#RDBMS-术语" class="headerlink" title="RDBMS 术语"></a>RDBMS 术语</h2><p>在我们开始学习MySQL 数据库前，让我们先了解下RDBMS的一些术语：</p>
<ul>
<li><strong>数据库:</strong> 数据库是一些关联表的集合。</li>
<li><strong>数据表:</strong> 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。</li>
<li><strong>列:</strong> 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。</li>
<li><strong>行：</strong>一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。</li>
<li><strong>冗余</strong>：存储两倍数据，冗余降低了性能，但提高了数据的安全性。</li>
<li><strong>主键</strong>：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。</li>
<li><strong>外键：</strong>外键用于关联两个表。</li>
<li><strong>复合键</strong>：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。</li>
<li><strong>索引：</strong>使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。</li>
<li><strong>参照完整性:</strong> 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。</li>
</ul>
<h2 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h2><p>1、如何登陆mysql数据库</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mysql -u username -p</span></span><br></pre></td></tr></table></figure>
<p>1.1、指定IP、端口</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mysql -uroot -h <span class="number">192.168</span><span class="number">.1</span><span class="number">.213</span> -P3306 -p123456</span><br></pre></td></tr></table></figure>
<p>-P（大写）：指定端口；<br>-p（小写）：指定密码；</p>
<p>2、如何开启/关闭mysql服务</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">service mysql <span class="literal">start</span>/<span class="literal">stop</span></span><br></pre></td></tr></table></figure>
<p>3、查看mysql的状态</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">service mysql status</span></span><br></pre></td></tr></table></figure>
<p>4、如何显示数所有数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span></span><br></pre></td></tr></table></figure>
<p>5、如何获取表内所有字段对象的名称和类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">describe</span> table_name;</span><br></pre></td></tr></table></figure>
<h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><p>SQL全程为Structure Query Language(结构化查询语言)。</p>
<p>SQL 语句主要可以划分为以下 3 个类别：</p>
<p>1、DDL(Data Definition Languages)语句:数据定义语言，这些语句定义了不同的数据段、 数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter 等。</p>
<p>2、DML(Data Manipulation Language)语句:数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、update 和 select 等。</p>
<p>3、DCL(Data Control Language)语句:数据控制语句，用于控制不同数据段直接的许可和 访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。</p>
<h2 id="MySQL支持的数据类型"><a href="#MySQL支持的数据类型" class="headerlink" title="MySQL支持的数据类型"></a>MySQL支持的数据类型</h2><p>1、数值类型</p>
<p><img src="/2019/03/21/mysql整理/20170624150458870.png" alt="20170624150458870"></p>
<p>常见的数值类型如下：</p>
<p><img src="/2019/03/21/mysql整理/20170624151329572.png" alt="è¿éåå¾çæè¿°"></p>
<p>注：这里的最小值和最大值代表的是宽度。</p>
<p><strong>对于这几种常见的数值类型，我们应该知道存储的所占的字节，我们还要知道INT最大的长度为10位数字，那么我们设置11为，如：int(11)也是无用的，最多只能为10位数字。TINYINT最大支持3位，那么我们设置tinyint(4)也是无用的。</strong></p>
<p>2、日期时间类型</p>
<p><img src="/2019/03/21/mysql整理/20170624152308240.png" alt="è¿éåå¾çæè¿°"></p>
<p>上图可以看出，每种日期时间类型都有一个有效值范围，如果超出这个范围，在默认的SQLMode下，系统会进行错误示，并将以零值来进行存储。不同日期类型零值的表示如下：</p>
<p><img src="/2019/03/21/mysql整理/20170624151912966.png" alt="è¿éåå¾çæè¿°"></p>
<p>提示：</p>
<p>（1）日期格式中只有TIMESTAMP 可以使用MySQL提供的函数，实现自动设置时间和自动更新时间，脚本如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">`create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">`update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br></pre></td></tr></table></figure>
<p>（2）Navicat for MqlSQL设置如下：</p>
<p><img src="/2019/03/21/mysql整理/20170624152729114.png" alt="è¿éåå¾çæè¿°"></p>
<p>（3）、使用TIMESTAMP 要认识到，他会停止在2038年的一个时刻，但MySQL官方应该后期会提供相应的支持。</p>
<p>（4）DATETIME、TIMESTAMP都可以精确到秒，但是TIMESTAMP只占4个字节，因此可以有效考虑使用；</p>
<p>3、字符串类型</p>
<p><img src="/2019/03/21/mysql整理/20170624153208960.png" alt="è¿éåå¾çæè¿°"></p>
<p>1、常见的char和varchar区别：</p>
<p><img src="/2019/03/21/mysql整理/2616609-f7b5891c703ed414.png" alt="img"></p>
<p>（1）<strong>char(N)用于存放固定长度的字符串，长度最大为255</strong>，比指定长度大的值将被截断，而比指定长度小的值将会用空格进行填补；</p>
<p>（2）<strong>varchar(N)用于保存可变长度的字符串，长度最大为65535</strong>，只存储字符串实际需要的长度，它会增加一个额外字节来保存字符串本身的长度，varchar使用额外的12字节来存储值得长度，如果列的最大长度小于或等于255，则使用1字节，否则就是使用2字节；（1个字节占8位，2的8次方是256（-128127）；2个字节占16位，2的16次方为65536）</p>
<p>（3）char和varchar跟字符编码也有密切联系，lantin1占用1个字节，gbk占用2个字节，utf8占用3个字节。示例如下：</p>
<p>lantin1、1个字符1个字节：</p>
<p>gbk、1个字符2个字节：</p>
<p>utf8、1个字符3个字节：</p>
<p>2、如何选择char和varchar    只给与真正需要的空间，因为更长的列会消耗更多的内存.</p>
<h2 id="MySQL数据类型的选择和优化案例"><a href="#MySQL数据类型的选择和优化案例" class="headerlink" title="MySQL数据类型的选择和优化案例"></a>MySQL数据类型的选择和优化案例</h2><p><strong>1、手机号存储</strong></p>
<p><strong>使用BIGINT代替CHAR或者VARCHAR存放手机号码。</strong></p>
<p>这是因为CHAR或者VARCHAR，占用空间大，影响查询性能。<br>例如：11位手机号CHAR存储，utf8编码，则占用33个字节；<br>使用如果使用INT的话，INT最大只能保存10为数据，而手机号为11位，会出现溢出，所以使用BIGINT占用8个字节，支持11为数据存储。</p>
<h2 id="MySQL中的常用运算符"><a href="#MySQL中的常用运算符" class="headerlink" title="MySQL中的常用运算符"></a>MySQL中的常用运算符</h2><p>1、算术运算符</p>
<p><img src="/2019/03/21/mysql整理/20170624164017861.png" alt="这里写图片描述"></p>
<p>2、比较运算符</p>
<p><img src="/2019/03/21/mysql整理/20170624164101876.png" alt="这里写图片描述"></p>
<h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><p>mysql事务可以理解为一系列操作，要么成功执行，要么失败。</p>
<ol>
<li>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</li>
<li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</li>
<li>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</li>
<li>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li>
</ol>
<h3 id="2-事务的并发问题"><a href="#2-事务的并发问题" class="headerlink" title="2. 事务的并发问题"></a>2. 事务的并发问题</h3><ol>
<li>脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</li>
<li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li>
</ol>
<p>　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<h2 id="MySQL几种表的比较"><a href="#MySQL几种表的比较" class="headerlink" title="MySQL几种表的比较"></a>MySQL几种表的比较</h2><p><img src="/2019/03/21/mysql整理/3883791731-5acdd933f169a_articlex.png" alt="clipboard.png"></p>
<p>MyISAM： 节约空间，读取响应速度快,表应用于读的场景比较多，支持FULLTEXT类型的索引</p>
<p>InnoDB： 如果应用程序需要用到事务,使用外键或需要更高的安全性,以及需要允许很多用户同时 修改某个数据表里的数据,则InnoDB数据表更值得考虑。支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’</p>
<p>Memory: 存储在内存中，所以没有持久化。可以用于test中假数据的读写</p>
<p>实例：公司以前的一张表用的是MyISAM，突然有一天这张表不能读写几个小时。公司上下折腾了好久。最后原因是这张表用的是MyISAM，同时正好有人向表中新加入一列，同时进行索引，由于表很大，所以一直在做索引。因此整张表一直处于锁的状态。</p>
<h2 id="MySQL中的常用函数"><a href="#MySQL中的常用函数" class="headerlink" title="MySQL中的常用函数"></a>MySQL中的常用函数</h2><p>1、字符串函数</p>
<p><img src="/2019/03/21/mysql整理/20170624164250086.png" alt="è¿éåå¾çæè¿°"></p>
<p>2、数值函数</p>
<p><img src="/2019/03/21/mysql整理/20170624164524621.png" alt="这里写图片描述"></p>
<p>3、日期和时间函数</p>
<p><img src="/2019/03/21/mysql整理/20170624164625565.png" alt="è¿éåå¾çæè¿°"></p>
<h2 id="常见查看MySQL状态命令"><a href="#常见查看MySQL状态命令" class="headerlink" title="常见查看MySQL状态命令"></a>常见查看MySQL状态命令</h2><p>1、查看状态</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">show</span> <span class="built_in">status</span>;</span><br></pre></td></tr></table></figure>
<p>2、查看可设置的变量</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">variables</span>\G;</span><br></pre></td></tr></table></figure>
<p>3、查看最大的连接</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">'%max_con%'</span>;</span><br></pre></td></tr></table></figure>
<p>4、查看进程的连接</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">show </span>full processlist<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>6、sql执行性能分析命令<code>explain</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>spring相关面试</title>
    <url>/2019/03/20/spring%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<a id="more"></a>
<h4 id="spring-bean的生命周期"><a href="#spring-bean的生命周期" class="headerlink" title="spring bean的生命周期"></a>spring bean的生命周期</h4><ol>
<li><p>spring调用bean的构造函数(或工厂模式方法)实例化bean</p>
</li>
<li><p>spring对bean进行依赖注入将成员变量赋值(set方式)</p>
</li>
<li>如果bean实现了BeanNameAware接口，spring将bean的id传给setBeanName()方法；</li>
<li>如果bean实现了BeanFactoryAware接口，spring将调用setBeanFactory方法，将BeanFactory实例传进来；</li>
<li>如果bean实现了ApplicationContextAware接口，它的setApplicationContext()方法将被调用，将应用上下文的引用传入到bean中；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessBeforeInitialization方法将被调用；</li>
<li>如果bean实现了InitializingBean接口，spring将调用它的afterPropertiesSet接口方法，类似的如果bean使用了init-method属性声明了初始化方法，该方法也会被调用；</li>
<li>如果bean实现了BeanPostProcessor接口，它的postProcessAfterInitialization接口方法将被调用；</li>
<li>此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁；</li>
<li>若bean实现了DisposableBean接口，spring将调用它的distroy()接口方法。同样的，如果bean使用了destroy-method属性声明了销毁方法，则该方法被调用；</li>
</ol>
<p><img src="/2019/03/20/spring相关面试/20180830171047_340.jpg" alt="img"></p>
<h5 id="Spring-中常见的创建对象的注解有哪些？"><a href="#Spring-中常见的创建对象的注解有哪些？" class="headerlink" title="Spring 中常见的创建对象的注解有哪些？"></a>Spring 中常见的创建对象的注解有哪些？</h5><ul>
<li>@Component</li>
<li>@Controller</li>
<li>@Service</li>
<li>@Repository</li>
</ul>
<h5 id="什么是依赖注入？什么是控制反转-IOC-？-在-Spring-中，有几种依赖注入方式？"><a href="#什么是依赖注入？什么是控制反转-IOC-？-在-Spring-中，有几种依赖注入方式？" class="headerlink" title="什么是依赖注入？什么是控制反转(IOC)？ 在 Spring 中，有几种依赖注入方式？"></a>什么是依赖注入？什么是控制反转(IOC)？ 在 Spring 中，有几种依赖注入方式？</h5><p>依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。</p>
<p>即本类引入其他类 （但是不用new  将已有（bean /属性）的注入给你 ）如：将Student 依赖进 User (用User 创建一个student对象就可以了，student相当于User 类的一个成员属性)</p>
<p>控制反转 是将new 实例的过程交给spring ，即将对实例的控制权交给spring</p>
<p>作为被注入对象，要想让IoC容器为其提供服务，并将所需要的被依赖对象送过来，也需要通过某种方式通知对方。在IoC模式中，被注入对象通过构造方法注入和setter方法，接口注入方式注入</p>
<h5 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h5><p>AOP 面向切面编程，所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。利用AOP可以对业务逻辑的各个部分隔离，从而使的业务逻辑各部分的耦合性降低，提高程序的可重用性，踢开开发效率，主要功能：日志记录，性能统计，安全控制，事务处理，异常处理等。</p>
<p>AOP实现原理是java动态代理，但是jdk的动态代理必须实现接口，所以spring的aop是用cglib这个库实现的，cglis使用里asm这个直接操纵字节码的框架，所以可以做到不使用接口的情况下实现动态代理。</p>
<h5 id="在Spring框架xml配置中共有5种自动装配："><a href="#在Spring框架xml配置中共有5种自动装配：" class="headerlink" title="在Spring框架xml配置中共有5种自动装配："></a>在Spring框架xml配置中共有5种自动装配：</h5><p>（1）no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。</p>
<p>（2）byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。 </p>
<p>（3）byType：通过参数的数据类型进行自动装配。</p>
<p>（4）constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。</p>
<p>（5）autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p>
<p>Spring的自动装配：</p>
<p>在spring中，对象无需自己查找或创建与其关联的其他对象，由容器负责把需要相互协作的对象引用赋予各个对象，使用autowire来配置自动装载模式。</p>
<h5 id="什么是Spring-MVC-？简单介绍下你对springMVC的理解"><a href="#什么是Spring-MVC-？简单介绍下你对springMVC的理解" class="headerlink" title="什么是Spring MVC ？简单介绍下你对springMVC的理解?"></a>什么是Spring MVC ？简单介绍下你对springMVC的理解?</h5><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p>
<p>SpringMVC的流程？</p>
<p>（1）用户发送请求至前端控制器DispatcherServlet；<br>（2） DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；<br>（3）处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；<br>（4）DispatcherServlet 调用 HandlerAdapter处理器适配器；<br>（5）HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；<br>（6）Handler执行完成返回ModelAndView；<br>（7）HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；<br>（8）DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；<br>（9）ViewResolver解析后返回具体View；<br>（10）DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）<br>（11）DispatcherServlet响应用户。</p>
<h5 id="springMVC和struts2的区别有哪些"><a href="#springMVC和struts2的区别有哪些" class="headerlink" title="springMVC和struts2的区别有哪些?"></a>springMVC和struts2的区别有哪些?</h5><p>（1）springmvc的入口是一个servlet即前端控制器（DispatchServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。</p>
<p>（2）springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>
<p>（3）Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。Jsp视图解析器默认使用jstl。</p>
<h5 id="SpringMvc怎么和AJAX相互调用的？"><a href="#SpringMvc怎么和AJAX相互调用的？" class="headerlink" title="SpringMvc怎么和AJAX相互调用的？"></a>SpringMvc怎么和AJAX相互调用的？</h5><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p>
<p>（1）加入Jackson.jar</p>
<p>（2）在配置文件中配置json的映射</p>
<p>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p>
<h5 id="解决post请求乱码问题："><a href="#解决post请求乱码问题：" class="headerlink" title="解决post请求乱码问题："></a>解决post请求乱码问题：</h5><p>在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；</p>
<h5 id="SpringMVC常用的注解有哪些？"><a href="#SpringMVC常用的注解有哪些？" class="headerlink" title="SpringMVC常用的注解有哪些？"></a>SpringMVC常用的注解有哪些？</h5><p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
<p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p>
<p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring事务</title>
    <url>/2019/03/20/spring%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="Spring事务的用法与原理"><a href="#Spring事务的用法与原理" class="headerlink" title="Spring事务的用法与原理"></a>Spring事务的用法与原理</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。对于纯JDBC操作数据库，想要用到事务，可以按照以下步骤进行：</p>
<ol>
<li>获取连接 Connection con = DriverManager.getConnection()</li>
<li>开启事务con.setAutoCommit(true/false);</li>
<li>执行CRUD</li>
<li>提交事务/回滚事务 con.commit() / con.rollback();</li>
<li>关闭连接 conn.close();</li>
</ol>
<p>使用Spring的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由Spirng 自动完成。Spring事务处理模块是通过AOP功能来实现声明式事务处理的，具体操作（比如事务实行的配置和读取，事务对象的抽象），用TransactionProxyFactoryBean接口来使用AOP功能，生成proxy代理对象，通过TransactionInterceptor完成对代理方法的拦截，将事务处理的功能编织到拦截的方法中。说得更详细一点：</p>
<p>（1）Spring事务处理模块是通过AOP功能为没有编写事务代码但加上了@Transactional注解的类生成代理。</p>
<p>（2）生成代理的过程中会读取@Transactional注解中的配置，比如传播行为、隔离级别、事务超时等。</p>
<p>（3）生成的代理会拦截目标对象的外部方法调用，自动开启事务、自动提交事务或回滚。</p>
<h4 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><p>Atomicity原子性：一个事务要么全部执行,要么不执行；</p>
<p>Consistency一致性：事务的运行并不改变数据库中数据的一致性，例如检查约束、非空约束、主键约束、外键约束；</p>
<p>Isolation隔离性：两个以上的事务不会出现交错执行的状态；</p>
<p>Durability持久性：事务执行成功以后,该事务对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚；</p>
<h4 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h4><p><img src="/2019/03/20/spring事务/20180202232828622.png" alt="img"></p>
<p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring 框架中，涉及到事务管理的 API 大约有100个左右，其中最重要的有三个：TransactionDefinition、PlatformTransactionManager、TransactionStatus。</p>
<h5 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h5><p>Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。主要包含三个方法：</p>
<p>（1）getTransaction获取事务状态；</p>
<p>（2）commit提交；</p>
<p>（3）rollback回滚；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionStatus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由TransactionDefinition得到TransactionStatus对象</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">	<span class="comment">// 提交</span></span><br><span class="line">	<span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回滚</span></span><br><span class="line">	<span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据底层所使用的不同的持久化 API 或框架，使用如下：</p>
<p>DataSourceTransactionManager：适用于使用JDBC和iBatis进行数据持久化操作的情况，在定义时需要提供底层的数据源作为其属性，也就是 DataSource。<br>HibernateTransactionManager：适用于使用Hibernate进行数据持久化操作的情况，与 HibernateTransactionManager 对应的是 SessionFactory。</p>
<p>JpaTransactionManager：适用于使用JPA进行数据持久化操作的情况，与 JpaTransactionManager 对应的是 EntityManagerFactory。</p>
<h5 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h5><p>PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事务）。TransactionStatus 接口提供了一个简单的控制事务执行和查询事务状态的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h5><p>org.springframework.transaction.TransactionDefinition，它用于定义一个事务。它包含了事务的静态属性，比如：事务传播行为、隔离级别、超时时间等等。</p>
<p>2.3 TransactionDefinition<br>org.springframework.transaction.TransactionDefinition，它用于定义一个事务。它包含了事务的静态属性，比如：事务传播行为、隔离级别、超时时间等等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; <span class="comment">// 返回事务的传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;  <span class="comment">// 返回事务必须在多少秒内完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">// 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h3><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><h5 id="support-存在与否"><a href="#support-存在与否" class="headerlink" title="support(存在与否)"></a>support(存在与否)</h5><p>PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
<h5 id="required"><a href="#required" class="headerlink" title="required"></a>required</h5><p>PROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</p>
<p>使用spring声明式事务，spring使用AOP来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，并在方法执行之后决定事务提交或回滚事务。例如单独调用一个PROPAGATION_REQUIRED的 methodB相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Main&#123; </span><br><span class="line">    Connection con=<span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span>&#123; </span><br><span class="line">        con = getConnection(); </span><br><span class="line">        con.setAutoCommit(<span class="keyword">false</span>); </span><br><span class="line">        <span class="comment">//方法调用</span></span><br><span class="line">        methodB(); </span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        con.commit(); </span><br><span class="line">	&#125; <span class="keyword">catch</span>(RuntimeException ex) &#123; </span><br><span class="line">        <span class="comment">//回滚事务</span></span><br><span class="line">        con.rollback();   </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        closeCon(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果methodB是在一个事务方法methodA中调用，那么对于methodB的调用会加入到methodA的事务当中。</p>
<h5 id="required-new"><a href="#required-new" class="headerlink" title="required_new"></a>required_new</h5><p>PROPAGATION_REQUIRED_NEW：表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。</p>
<h5 id="mandatory强制的"><a href="#mandatory强制的" class="headerlink" title="mandatory强制的"></a>mandatory强制的</h5><p>PROPAGATION_MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”)</span><br></pre></td></tr></table></figure>
<h5 id="not-supported"><a href="#not-supported" class="headerlink" title="not_supported"></a>not_supported</h5><p>PROPAGATION_NOT_SUPPORTED: 表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。</p>
<h5 id="never"><a href="#never" class="headerlink" title="never"></a>never</h5><p>PROPAGATION_NEVER: 表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。</p>
<h5 id="nested"><a href="#nested" class="headerlink" title="nested"></a>nested</h5><p>PROPAGATION_NESTED: 表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务</p>
<blockquote>
<p>1.嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。<br>2.外层事务失败时，会回滚内层事务所做的动作。<br>3.而内层事务操作失败并不会引起外层事务的回滚。嵌套事务是外部事务的一部分，只有当外部事务成功之后嵌套事务才会被提交。</p>
</blockquote>
<p>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别:它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>隔离级别定义了一个事务可能受其他并发事务影响的程度。</p>
<h5 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h5><p>（1）脏读 Dirty reads</p>
<p>脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</p>
<p>（2）不可重复读 Nonrepeatable read</p>
<p>不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。</p>
<p>（3）幻读 Phantom read</p>
<p>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。</p>
<p>从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大：</p>
<p>对于前者，只需要锁住满足条件的记录；<br>对于后者，要锁住满足条件及其相近的记录；<br>√: 可能出现 ×: 不会出现</p>
<p>脏读                                       不可重复读    幻读<br>Read Uncommitted                   √                  √<br>Read Committed                       ×                  √<br>Repeatable Read                      ×                   ×<br>Serializable                               ×                   ×</p>
<p>MySQL的默认事务隔离级别是：Repeatable Read</p>
<h5 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed"></a>Read Committed</h5><p>在提交读(READ COMMITTED)级别中，基于锁机制并发控制的DBMS需要对选定对象的</p>
<p>写锁(write locks)一直保持到事务结束；<br>读锁(read locks)在SELECT操作完成后马上释放；<br>不要求“范围锁(range-locks)”<br>所以READ COMMITTED只能保证读到的数据都是提交之后的数据，但是不能保证“可重复读”。在SELECT操作结束后就释放了共享锁，其他事务就可以对这个数据进行修改了，所以在本事务中再次读取这个数据，有可能已经改变。</p>
<h5 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read"></a>Repeatable Read</h5><p>在可重复读(REPEATABLE READS)隔离级别中，基于锁机制并发控制的DBMS需要对选定对象的</p>
<p>读锁(read locks)和写锁(write locks)一直保持到事务结束；<br>但不要求“范围锁(range-locks)”；<br>读锁也保持到事务结束，自然就杜绝了一次事务过程中两次读取的数据不一致的问题。但是只锁住了SELECT相关的记录，还是可以往表中插入新的记录的。所以，幻读的问题没法解决。</p>
<h5 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h5><p>将事务的执行变成了串行的，自然就没有并发问题了。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h5><p>事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。</p>
<h5 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h5><p>为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</p>
<h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><p><strong>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性。</strong>同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>
<p>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 <strong>Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上</strong>，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>
<p>默认情况下，<strong>只有来自外部的方法调用才会被AOP代理捕获</strong>，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</p>
<h4 id="异常触发回滚的示例"><a href="#异常触发回滚的示例" class="headerlink" title="异常触发回滚的示例"></a>异常触发回滚的示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line"><span class="keyword">private</span> MyBatisDao dao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Test test)</span> </span>&#123;  </span><br><span class="line">    dao.insert(test);  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test"</span>);<span class="comment">//抛出unchecked异常，触发事物，回滚  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RuntimeException时不回滚的事务"><a href="#RuntimeException时不回滚的事务" class="headerlink" title="RuntimeException时不回滚的事务"></a>RuntimeException时不回滚的事务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(noRollbackFor=RuntimeException.class)  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Test test)</span> </span>&#123;  </span><br><span class="line">    dao.insert(test);  </span><br><span class="line">    <span class="comment">//抛出unchecked异常，触发事物，noRollbackFor=RuntimeException.class,不回滚  </span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="作用于类上"><a href="#作用于类上" class="headerlink" title="作用于类上"></a>作用于类上</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisServiceImpl</span> <span class="keyword">implements</span> <span class="title">MyBatisService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> MyBatisDao dao; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Test test)</span> </span>&#123;  </span><br><span class="line">        dao.insert(test);  </span><br><span class="line">        <span class="comment">//抛出unchecked异常，触发事物，回滚  </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test"</span>);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置以非事务方式运行"><a href="#设置以非事务方式运行" class="headerlink" title="设置以非事务方式运行"></a>设置以非事务方式运行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation=Propagation.NOT_SUPPORTED)  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Test test)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//事物传播行为是PROPAGATION_NOT_SUPPORTED，以非事务方式运行，不会存入数据库  </span></span><br><span class="line">    dao.insert(test);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="设置传播行为和隔离级别"><a href="#设置传播行为和隔离级别" class="headerlink" title="设置传播行为和隔离级别"></a>设置传播行为和隔离级别</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"businessSerivce"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessServiceImpl</span> <span class="keyword">implements</span> <span class="title">IBaseService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    IStudentDao studentDao;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    IBaseServiceB baseServiceb;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, 	rollbackFor = Exception.class)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doA</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        Student st = <span class="keyword">new</span> Student();  </span><br><span class="line">        st.setId(<span class="number">1</span>);  </span><br><span class="line">        st.setSex(<span class="string">"girl"</span>);  </span><br><span class="line">        st.setUsername(<span class="string">"zx"</span>);  </span><br><span class="line">        studentDao.insertStudent(st);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2019/03/13/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<a id="more"></a>
<h5 id="1-hashcode相等的两个类一定相等吗？equals呢？相反呢？"><a href="#1-hashcode相等的两个类一定相等吗？equals呢？相反呢？" class="headerlink" title="1.hashcode相等的两个类一定相等吗？equals呢？相反呢？"></a>1.hashcode相等的两个类一定相等吗？equals呢？相反呢？</h5><p>1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。<br>2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。<br>对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性。</p>
<h5 id="2-介绍一下集合框架"><a href="#2-介绍一下集合框架" class="headerlink" title="2.介绍一下集合框架"></a>2.介绍一下集合框架</h5><p>分为三块：List列表、Set集合、Map映射</p>
<p><strong>Set、List和Map可以看做集合的三大类：</strong><br><strong>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</strong><br><strong>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。</strong><br><strong>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</strong> </p>
<p><strong>1.List接口</strong><br>List接口继承于Collection接口，它可以定义一个<strong>允许重复</strong>的<strong>有序集合</strong>。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p>
<p>List接口为Collection直接接口。List所代表的是<strong>有序的Collection</strong>，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p>
<p><strong>Map一种映射，用于储存关系型数据，保存着两种值，一组用于保存key,另一组用来保存value。并且key不允许重复。</strong><br><strong>HashMap底层就是一个数组，数组中根据存入的Key的HashCode决定存放位置，其Entry单元中有四个属性，分别为HashCode，Key，Vaule，和下一个Entry</strong>，这样就形成了一个链表，当HashMap中的另一个拥有相同的HashCode值的不同的Key存入时，会将原来的Entry赋到新Entry的属性中，然后形成Entry链，查询的时候先比较HashCode，如果相同且Key值相同则直接取出，如果HashCode相同Key值不同则继续顺着链表寻找直到寻找到相同的Key值。<br>TreeMap与HashMap的不同：表象上时TreeMap可以对Key进行排序，原因时TreeMap使用的时“红黑树”的二叉树结构储存Entry，也就是排序二叉树，左边恒放比此值小的数右边恒放比此值大的树，按照当前节点值与传入查询值的比较进行判断决定其存放位置/查询其数值；<br>Set集合：Set与Map可以手动的互相转换 Set转换Map只需要新建一个对象，对象中又key和value两个属性，新建一个类继承Set存储新建的对象即可实现。Map转换为Set只需要将Map的Value固定，只使用Key存储数据即可实现；<br>Table:Map的线程安全型号；</p>
<h5 id="3-hashmap，hashtable底层实现的区别，hashtable和concurrenthashtable呢？"><a href="#3-hashmap，hashtable底层实现的区别，hashtable和concurrenthashtable呢？" class="headerlink" title="3.hashmap，hashtable底层实现的区别，hashtable和concurrenthashtable呢？"></a>3.hashmap，hashtable底层实现的区别，hashtable和concurrenthashtable呢？</h5><p>hashtable简单的理解就是hashmap的线程安全类 其方法大部分都相同只不过家了synchronize关键字保证其线程安全。其他的区别也有继承的接口不同这点。<br>concurrenthashtable则是改进了hashtable的效率，hashtable虽然安全但是不能多线程同时操作，concurrenthashtable使用了分块的模式支持多线程操作，且使用了lock替换synchronize来提高了效率。</p>
<h5 id="4-hashmap与treemap的区别，底层数据结构是什么样的？"><a href="#4-hashmap与treemap的区别，底层数据结构是什么样的？" class="headerlink" title="4.hashmap与treemap的区别，底层数据结构是什么样的？"></a>4.hashmap与treemap的区别，底层数据结构是什么样的？</h5><p>HashMap：数组方式存储key/value，线程非安全，允许null作为key和value，key不可以重复，value允许重复，不保证元素迭代顺序是按照插入时的顺序，key的hash值是先计算key的hashcode值，然后再进行计算，每次容量扩容会重新计算所以key的hash值，会消耗资源，要求key必须重写equals和hashcode方法</p>
<p>默认初始容量16，加载因子0.75，扩容为旧容量乘2，查找元素快，如果key一样则比较value，如果value不一样，则按照链表结构存储value，就是一个key后面有多个value；</p>
<p>TreeMap：基于红黑二叉树的NavigableMap的实现，线程非安全，不允许null，key不可以重复，value允许重复，存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，会按照排序后的顺序迭代元素，两个相比较的key不得抛出classCastException。主要用于存入元素的时候对元素进行自动排序，迭代输出的时候就按排序顺序输出  </p>
<h5 id="5-线程池用过么，都有什么参数？底层如何实现的？"><a href="#5-线程池用过么，都有什么参数？底层如何实现的？" class="headerlink" title="5.线程池用过么，都有什么参数？底层如何实现的？"></a>5.线程池用过么，都有什么参数？底层如何实现的？</h5><ol>
<li>newSingleThreadExecutor</li>
</ol>
<p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p>2.newFixedThreadPool</p>
<p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p>
<ol start="3">
<li>newCachedThreadPool</li>
</ol>
<p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<p>4.newScheduledThreadPool</p>
<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<p>线程池：<br>1、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。<br>2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。<br>参数： </p>
<p>一般来说，非CPU密集型的业务（加解密、压缩解压缩、搜索排序等业务是CPU密集型的业务），瓶颈都在后端数据库，本地CPU计算的时间很少，所以设置几十或者几百个工作线程也都是可能的。</p>
<p>N核服务器，通过执行业务的单线程分析出本地计算时间为x，等待时间为y，则工作线程数（线程池线程数）设置为 N*(x+y)/x，能让CPU的利用率最大化。</p>
<p>corePoolSize - 池中所保存的线程数，包括空闲线程。</p>
<p>maximumPoolSize-池中允许的最大线程数。</p>
<p>keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</p>
<p>unit - keepAliveTime 参数的时间单位。</p>
<p>workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务。</p>
<p>threadFactory - 执行程序创建新线程时使用的工厂。</p>
<p>handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</p>
<p>底层核心实现为封装一层线程类work，在运行的时候再执行完自己的线程后主动去队列中拿取下一条线程去执行。</p>
<h5 id="Thread-类中的start-和-run-方法有什么区别？"><a href="#Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="Thread 类中的start() 和 run() 方法有什么区别？"></a>Thread 类中的start() 和 run() 方法有什么区别？</h5><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h5 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h5><p>RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</p>
<p>RPC会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）。</p>
<p>客户端发起请求，服务器返回响应（类似于Http的工作方式）RPC在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。</p>
<p>客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。</p>
<p>RPC 调用分以下两种：</p>
<ol>
<li>同步调用<br>客户方等待调用执行完成并返回结果。</li>
<li>异步调用<br>客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果。 若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果。</li>
</ol>
<p>异步和同步的区分在于是否等待服务端执行完成并返回结果。</p>
<h5 id="java读取xml文件的四种方法"><a href="#java读取xml文件的四种方法" class="headerlink" title="java读取xml文件的四种方法"></a>java读取xml文件的四种方法</h5><p>第一种 DOM 实现方法：</p>
<p>第二种 DOM4J实现方法</p>
<p>第三种 JDOM实现方法：</p>
<p>第四种 SAX实现方法：</p>
<h5 id="Tomcat内部工作原理"><a href="#Tomcat内部工作原理" class="headerlink" title="Tomcat内部工作原理"></a>Tomcat内部工作原理</h5><p>Connector负责接受客户的请求并向客户返回响应，是Tomcat接收请求的入口，每个Connector有自己专属的监听端口, 在同一个Service中，多个Connector共享一个Engine。同一个Engine有多个Host,Engine负责处理Service内的所有请求。它接收来自Connector的请求，并决定传给哪个Host来处理，Host处理完请求后，将结果返回给Engine，Engine再将结果返回给Connector，同一个Host有多个Context</p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><h5 id="Redis有哪些数据结构"><a href="#Redis有哪些数据结构" class="headerlink" title="Redis有哪些数据结构"></a>Redis有哪些数据结构</h5><p>字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。</p>
<h5 id="3-使用redis有哪些好处？"><a href="#3-使用redis有哪些好处？" class="headerlink" title="3.使用redis有哪些好处？"></a>3.使用redis有哪些好处？</h5><p>(1) <strong>速度快</strong>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；<br>(2) <strong>支持丰富数据类型</strong>，支持string，list，set，sorted set，hash；<br>(3) <strong>支持事务</strong>，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行；<br>(4) <strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除；</p>
<h5 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h5><p>分布式中的锁，通常不会是一个对象，而是一个唯一的数据，可以是商户的订单号，商户的编码，或者是一条数据的唯一主键等等。</p>
<p>synchronized主要对于单个应用中，多线程的同步；</p>
<p>而分布式锁对应的是多个应用，每个应用中都可能会处理相同的数据，所以需要对对个应用的数据进行同步，保证数据的一致性；</p>
<p>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。</p>
<ul>
<li>基于 DB 的唯一索引。</li>
<li>基于 ZK 的临时有序节点。</li>
<li>基于 Redis 的 <code>NX EX</code> 参数。</li>
</ul>
<p>向redis中添加一个key，添加的操作是原子性操作，key不存在才能添加成功；</p>
<p>在redis实现的分布式锁中，我们需要强调以下几点，只有保证了以下几点，才可说是确保了锁的实现：</p>
<ul>
<li>高性能(加、解锁时高性能)</li>
<li>可以使用阻塞锁与非阻塞锁。</li>
<li>不能出现死锁。</li>
<li>可用性(不能出现节点 down 掉后加锁失败)。</li>
</ul>
<p>利用 <code>Redis set key</code> 时的一个 NX 参数可以保证在这个 key 不存在的情况下写入成功。并且再加上 EX 参数可以让该 key 在超时之后自动删除。</p>
<h4 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h4><p>Maven主要服务于<strong>基于Java平台的项目构建、依赖管理和项目信息管理</strong>…</p>
<h5 id="Maven常见的依赖范围有哪些"><a href="#Maven常见的依赖范围有哪些" class="headerlink" title="Maven常见的依赖范围有哪些?"></a>Maven常见的依赖范围有哪些?</h5><p>compile:编译依赖，默认的依赖方式，在编译,测试,运行三个阶段都有效，典型地有spring-core等jar。<br>test:测试依赖，只在编译测试用例和运行测试用例有效，典型地有JUnit。<br>provided:对于编译和测试有效，不会打包进发布包中，典型的例子为servlet-api,一般的web工程运行时都使用容器的servlet-api。<br>runtime:只在运行测试用例和实际运行时有效，典型地是jdbc驱动jar包。<br>system: 不从maven仓库获取该jar,而是通过systemPath指定该jar的路径。<br>import: 用于一个dependencyManagement对另一个dependencyManagement的继承。</p>
<h5 id="如何设置本地仓库和远程仓库"><a href="#如何设置本地仓库和远程仓库" class="headerlink" title="如何设置本地仓库和远程仓库"></a>如何设置本地仓库和远程仓库</h5><p>4.1 配置本地仓库</p>
<p>​        用文本编辑器工具打开setting.xml文件，然后配置自定义地址：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;localRepository&gt;</span></span><br><span class="line"><span class="symbol">    F:</span>\DevInstall\yuxx-meven-libs</span><br><span class="line"><span class="params">&lt;/localRepository&gt;</span></span><br></pre></td></tr></table></figure>
<p>4.2 配置远程仓库</p>
<p>​        Maven默认的远程地址是：<a href="http://my.repository.com/repo/path" target="_blank" rel="noopener">http://my.repository.com/repo/path</a>，这个地址是国外网站，下载速度很慢，这里推荐我国阿里云的地址。</p>
<p>用文本编辑器工具打开setting.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>排除依赖</p>
<p> 将不需要依赖的传递依赖排除掉</p>
<p>  在<dependency>标签中添加子标签<exclusions>和<exclusion>将某传递依赖的jar包排除掉</exclusion></exclusions></dependency></p>
<p> 版本锁定（推荐使用）</p>
<p>  直接指定所依赖的jar包版本。</p>
<p>  使用<dependencymanagement>标签，在改标签中明确指定所依赖的jar包的版本。</dependencymanagement></p>
<h5 id="java-常见的几种运行时异常RuntimeException"><a href="#java-常见的几种运行时异常RuntimeException" class="headerlink" title="java 常见的几种运行时异常RuntimeException"></a>java 常见的几种运行时异常RuntimeException</h5><p>常见的几种如下：</p>
<p>NullPointerException - 空指针引用异常<br>ClassCastException - 类型强制转换异常。<br>IllegalArgumentException - 传递非法参数异常。<br>ArithmeticException - 算术运算异常<br>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常<br>IndexOutOfBoundsException - 下标越界异常<br>NegativeArraySizeException - 创建一个大小为负数的数组错误异常<br>NumberFormatException - 数字格式异常<br>SecurityException - 安全异常<br>UnsupportedOperationException - 不支持的操作异常</p>
<h5 id="重载与重写的区别"><a href="#重载与重写的区别" class="headerlink" title="重载与重写的区别"></a>重载与重写的区别</h5><p>方法重载是指同一个类中的多个方法具有相同的名字,但这些方法具有不同的参数列表,即参数的数量或参数类型不能完全相同    在方法的参数不同的情况下，方法的返回类型可以不相同。</p>
<p>方法重写是存在子父类之间的,子类定义的方法与父类中的方法要求返回值、方法名和参数都相同。</p>
<h5 id="ArrayList、LinkedList、Vector的区别"><a href="#ArrayList、LinkedList、Vector的区别" class="headerlink" title="ArrayList、LinkedList、Vector的区别"></a>ArrayList、LinkedList、Vector的区别</h5><p><strong>List的三个子类的特点</strong></p>
<p><strong>ArrayList:</strong></p>
<ul>
<li>底层数据结构是数组，查询快，增删慢。</li>
<li>线程不安全，效率高。</li>
</ul>
<p><strong>Vector:</strong></p>
<ul>
<li>底层数据结构是数组，查询快，增删慢。</li>
<li>线程安全，效率低。</li>
<li>Vector相对ArrayList查询慢(线程安全的)。</li>
<li>Vector相对LinkedList增删慢(数组结构)。</li>
</ul>
<p><strong>LinkedList</strong></p>
<ul>
<li>底层数据结构是链表，查询慢，增删快。</li>
<li>线程不安全，效率高。</li>
</ul>
<p><strong>Vector和ArrayList的区别</strong></p>
<ul>
<li>Vector是线程安全的,效率低。</li>
<li>ArrayList是线程不安全的,效率高。</li>
<li>共同点:底层数据结构都是数组实现的,查询快,增删慢。</li>
</ul>
<p><strong>ArrayList和LinkedList的区别</strong></p>
<ul>
<li>ArrayList底层是数组结果,查询和修改快。</li>
<li>LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢。</li>
</ul>
<p><strong>共同点:都是线程不安全的</strong></p>
<p><strong>List有三个子类使用</strong></p>
<ul>
<li>查询多用ArrayList。</li>
<li>增删多用LinkedList。</li>
<li>如果都多ArrayList。</li>
</ul>
<h5 id="String、StringBuffer与StringBuilder的区别"><a href="#String、StringBuffer与StringBuilder的区别" class="headerlink" title="String、StringBuffer与StringBuilder的区别"></a>String、StringBuffer与StringBuilder的区别</h5><p>String：适用于少量的字符串操作的情况。 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况。 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况。 StringBuilder：是线程不安全的，而StringBuffer是线程安全的。</p>
<p>这三个类之间的区别主要是在两个方面，<strong>即运行速度和线程安全</strong>这两方面。 首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：<strong>StringBuilder &gt; StringBuffer &gt; String</strong>。</p>
<p>String最慢的原因</p>
<p>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</p>
<p>再来说线程安全</p>
<p>在线程安全上，<strong>StringBuilder是线程不安全的，而StringBuffer是线程安全的</strong>。</p>
<p>如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
<h5 id="Java内存分配策略"><a href="#Java内存分配策略" class="headerlink" title="Java内存分配策略"></a>Java内存分配策略</h5><p>堆内存、虚拟机栈、方法区、本地方法栈、程序计数器。</p>
<p>静态分配—静态存储区（方法区）：主要存放静态数据，全局static</p>
<p>栈式分配—栈区：当方法执行时，方法内部的局部变量都建立在栈内存中，并在方法结束后自动释放分配的内存。因为栈内存分配是在处理器的指令集当中所以效率很高，但是分配的内存容量有限。</p>
<p><strong>在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都在方法的栈内存中分配。</strong>当在一段方法块中定义一个变量时，Java就会在栈中为其分配内存，当超出变量作用域时，该变量也就无效了，此时占用的内存就会释放，然后会被重新利用。</p>
<p>堆内存用来存放所有new出来的对象(包括该对象内的所有成员变量)和数组。</p>
<p>堆式分配—堆区：Java堆是被所有线程所共享的一块内存区域，在虚拟机启动时创建，目的就是用来存放对象实例，几乎所有的对象都是在这里分配（但随着技术发展，“所有”不是那么绝对了）Java堆是垃圾收集器的主要管理区域，也叫“GC”堆。从内存回收的角度可以将Java堆分为“新生代”，“老年代”</p>
<p>本地方法栈。本地方法栈为虚拟机使用到的Native方法服务。而JAVA的栈内存是为了保存我们编写的临时变量与对象引用。</p>
<p>程序计数器。JAVA其实说到底也就是一条一条的指令。程序计数器个人理解也就是用来指示执行哪条指令的。每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。</p>
<h5 id="ThreadLocal与Synchronized的区别"><a href="#ThreadLocal与Synchronized的区别" class="headerlink" title="ThreadLocal与Synchronized的区别"></a>ThreadLocal与Synchronized的区别</h5><p>​        ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。<strong>synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。</strong></p>
<p><strong>一句话，ThreadLocal用于数据隔离，而Synchronized用于数据共享。</strong></p>
<p><strong>Synchronized用于线程间的数据共享（使变量或代码块在某一时该只能被一个线程访问），是一种以延长访问时间来换取线程安全性的策略；</strong></p>
<p><strong>而ThreadLocal则用于线程间的数据隔离（为每一个线程都提供了变量的副本），是一种以空间来换取线程安全性的策略。</strong></p>
<h5 id="在java方法中改变传递的参数的值"><a href="#在java方法中改变传递的参数的值" class="headerlink" title="在java方法中改变传递的参数的值"></a>在java方法中改变传递的参数的值</h5><p>1、对于基本类型参数，在方法体内对参数进行重新赋值，并不会改变原有变量的值。</p>
<p>2、对于引用类型参数，在方法体内对参数进行重新赋予引用，并不会改变原有变量所持有的引用。 </p>
<p>3、方法体内对参数进行运算，不影响原有变量的值。 </p>
<p>4、方法体内对参数所指向对象的属性进行操作，将改变原有变量所指向对象的属性值。 </p>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>IO是指对数据流的输入和输出，也称为IO流，IO流主要分为两大类，字节流和字符流。字节流可以处理任何类型的数据，如图片，视频等，字符流只能处理字符类型的数据。</p>
<p>IO流的本质是数据传输，并且流是单向的。</p>
<p>1字符=2字节</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>blog操作及具体指令</title>
    <url>/2019/03/13/blog%E6%93%8D%E4%BD%9C%E5%8F%8A%E5%85%B7%E4%BD%93%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>那个文件太长了 新起一个文件 总结换电脑之后的命令操作和图片等问题 ,  还是有点麻烦的 所以记一下。</p>
<a id="more"></a>
<h3 id="图片添加方式"><a href="#图片添加方式" class="headerlink" title="图片添加方式"></a>图片添加方式</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">修改<span class="emphasis">_config.yml配置文件post_</span>asset_folder项为true。</span><br><span class="line">创建博客是使用命令创建：</span><br><span class="line">hexo new [layout] <span class="xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span></span><br><span class="line">其中的layout项可以省略，例如：</span><br><span class="line">hexo new "这是一个新的博客"</span><br><span class="line">使用完命令之后，在source/_post文件夹里面就会出现一个“这是一个新的博客.md”的文件和一个“这是一个新的博客”的文件夹。</span><br><span class="line">安装插件</span><br><span class="line">npm install hexo-asset-image --save</span><br><span class="line">将想要上传的图片先扔到文件夹下，然后在博客中使用markdown的格式引入图片：</span><br><span class="line">![<span class="string">你想要输入的替代文字</span>](<span class="link">xxxx/图片名.jpg</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Typora设置如下"><a href="#Typora设置如下" class="headerlink" title="Typora设置如下"></a>Typora设置如下</h4><p><img src="/2019/03/13/blog操作及具体指令/1552463003251.png" alt="1552463003251"></p>
<h3 id="本地搜索功能开启"><a href="#本地搜索功能开启" class="headerlink" title="本地搜索功能开启"></a>本地搜索功能开启</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加插件</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br><span class="line">修改blog下的_config.yml文件，进行编辑。</span><br><span class="line"><span class="keyword">search</span>:</span><br><span class="line">    <span class="keyword">path</span>: search.xml</span><br><span class="line">    <span class="keyword">field</span>: post</span><br><span class="line">    <span class="keyword">format</span>: html</span><br><span class="line">    <span class="keyword">limit</span>: <span class="number">10000</span></span><br><span class="line">    </span><br><span class="line">修改主题配置文件</span><br><span class="line">self_search: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="新设备命令"><a href="#新设备命令" class="headerlink" title="新设备命令"></a>新设备命令</h3><p>直接撸,打开我的电脑–&gt;d: –&gt;新建文件夹 (my_blog) –&gt;右键git bash</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">clone -b blog_file https://github.com/ejeonline/ejeonline.github.io.git my_blog/</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install hexo-cli -g</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">my_blog</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install hexo-deployer-git --save</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install hexo-renderer-pug --save</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install hexo-renderer-sass --save</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install hexo-asset-image --save</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install hexo-generator-searchdb --save   #本地搜索功能插件</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">server</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure>
<h3 id="博客文件提交及日常使用"><a href="#博客文件提交及日常使用" class="headerlink" title="博客文件提交及日常使用"></a>博客文件提交及日常使用</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看分支</span></span><br><span class="line"><span class="variable">$ </span>git branch -a</span><br><span class="line">* blog_file  <span class="comment">#目前所在分支</span></span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/blog_file</span><br><span class="line">  remotes/origin/master</span><br><span class="line"><span class="variable">$ </span>git pull   <span class="comment">#更新</span></span><br><span class="line"><span class="variable">$ </span>git status  <span class="comment">#状态</span></span><br><span class="line"><span class="variable">$ </span>git reset --hard  <span class="comment">#还原到默认版本</span></span><br><span class="line"><span class="variable">$ </span>git add --all <span class="comment">#添加文件</span></span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"提交源文件到分支"</span> 提交到本地仓库</span><br><span class="line"><span class="variable">$ </span>git push --set-upstream origin blog_file <span class="comment">#提交远程仓库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重新发布</span></span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建</title>
    <url>/2019/03/13/hexo%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Hexo 是一个非常流行的静态站点生成工具，它可以把 Markdown 文档快速的解析成漂亮的静态页面，支持各种主题，让用户专注在写作上。我们可以使用 Hexo + Github 搭建自己的博客（免费的），还可以绑定自己的域名。</p>
<a id="more"></a>
<h3 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h3><ol>
<li>安装Git,Node.js,Hexo</li>
<li>GitHub创建个人仓库</li>
<li>将hexo部署到GitHub</li>
<li>发布文章</li>
</ol>
<h4 id="1-安装Git-Node-js-Hexo"><a href="#1-安装Git-Node-js-Hexo" class="headerlink" title="1.安装Git,Node.js,Hexo"></a>1.安装Git,Node.js,Hexo</h4><h5 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h5><p>安装Git：win下载地址<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>一路next, 安装后，注册 Github 账号，配置 SSH, 如果需要了解这方面的知识自行百度<br>•打开 Git Bash,本地生成公钥私钥  ssh-keygen -t rsa -C “你的邮件地址”<br>•添加公钥到 Github 根据上一步的提示，找到公钥文件（默认为id_rsa.pub），用记事本打开，全选并复制。(或许乱码，那就换一种打开方式)<br>•登录 Github，右上角 头像 -&gt; Settings —&gt; SSH keys —&gt; Add SSH key。把公钥粘贴到key中，填好title并点击 Add key。git bash中输入命令ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，选yes，等待片刻可看到成功提示。<br>安装Node.js   下载地址<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>安装 Hexo : $ npm install -g hexo-cli</p>
<h5 id="Centos"><a href="#Centos" class="headerlink" title="Centos"></a>Centos</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install git-core</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvm install stable</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>
<h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> myblog 为空，初始化文件夹 myblog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init myblog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myblog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure>
<p>新建Github仓库：仓库名必须为你的Github名.github.io，要不然就不能使用Github Pages服务了。。。</p>
<h5 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h5><p>相当于 hexo generate,生成的静态站点放在 public 目录下面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo g</span></span><br></pre></td></tr></table></figure>
<h5 id="查看目录结构"><a href="#查看目录结构" class="headerlink" title="查看目录结构"></a>查看目录结构</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree -L 1</span></span><br><span class="line">.</span><br><span class="line">├── _config.yml  # 网站配置文件</span><br><span class="line">├── db.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json  # 应用程序信息</span><br><span class="line">├── public  # 静态站点存放于此</span><br><span class="line">├── scaffolds  # 模板文件夹，新建文章时会使用此文件夹下的文件作为模板</span><br><span class="line">├── source # 存放用户资源的地方</span><br><span class="line">├── themes  # 主题</span><br></pre></td></tr></table></figure>
<p>启动服务，相当于 hexo server，本地预览</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo s</span></span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/13/hexo搭建/20180204223302697-1552448601263.png" alt="index"></p>
<h4 id="2-创建-Github-Pages"><a href="#2-创建-Github-Pages" class="headerlink" title="2.创建 Github Pages"></a>2.创建 Github Pages</h4><p>很多人都使用 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> 来搭建博客，原因是它的空间免费而且稳定</p>
<p>在 Github 上<a href="https://github.com/new" target="_blank" rel="noopener">创建</a>一个仓库，名字为 username.github.io，请注意，username 是你 GitHub 的用户名。</p>
<h4 id="3-将hexo部署到GitHub"><a href="#3-将hexo部署到GitHub" class="headerlink" title="3.将hexo部署到GitHub"></a>3.将hexo部署到GitHub</h4><p>把 Hexo 生成的静态页面推送到 Github</p>
<p>修改 _config.xml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/ejeonline/ejeonline.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>执行部署命令</p>
<p>安装插件 <strong>hexo-deployer-git</strong></p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>npm install hexo-deployer-git --save</span><br><span class="line"><span class="variable">$ </span>hexo d</span><br></pre></td></tr></table></figure>
<p>完成之后访问 <a href="https://ejeonline.github.io" target="_blank" rel="noopener">https://ejeonline.github.io</a>  效果如下</p>
<p><img src="/2019/03/13/hexo搭建/20180204223302697-1552448601263.png" alt="index"></p>
<p>如何绑定自己域名有很多样例 , 可以自己百度</p>
<h4 id="4-发布文章"><a href="#4-发布文章" class="headerlink" title="4.发布文章"></a>4.发布文章</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 新建一篇文章,名为 <span class="built_in">test</span>，默认会放到 <span class="built_in">source</span>/_posts/ 下。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo new <span class="built_in">test</span></span></span><br><span class="line">INFO  Created: /Volumes/warehouse/myblog/source/_posts/test.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 test.md </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># $ cat source/_posts/test.md</span></span></span><br><span class="line"></span><br><span class="line">title: test</span><br><span class="line">date: 2018-01-02 19:40:10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># tags:</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑 test.md ，添加 <span class="comment">## 我是用来测试的 </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim <span class="built_in">source</span>/_posts/test.md</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># $ cat source/_posts/test.md</span></span></span><br><span class="line"></span><br><span class="line">title: test</span><br><span class="line">date: 2018-01-02 19:40:10</span><br><span class="line">tags:</span><br><span class="line"></span><br><span class="line">我是用来测试的</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo g  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s  <span class="comment">#预览</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo d  <span class="comment">#发布</span></span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2019/03/13/hexo搭建/20180204223314691-1552466254191.png" alt="111"></p>
<h3 id="hexo的基本配置，更换主题"><a href="#hexo的基本配置，更换主题" class="headerlink" title="hexo的基本配置，更换主题"></a>hexo的基本配置，更换主题</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>在文件根目录下的<code>_config.yml</code>，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。下面为<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">官方的配置</a>描述。</p>
<h5 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>title</code></td>
<td>网站标题</td>
</tr>
<tr>
<td><code>subtitle</code></td>
<td>网站副标题</td>
</tr>
<tr>
<td><code>description</code></td>
<td>网站描述</td>
</tr>
<tr>
<td><code>author</code></td>
<td>您的名字</td>
</tr>
<tr>
<td><code>language</code></td>
<td>网站使用的语言</td>
</tr>
<tr>
<td><code>timezone</code></td>
<td>网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td>
</tr>
</tbody>
</table>
<p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p>
<h5 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>url</code></td>
<td>网址</td>
<td></td>
</tr>
<tr>
<td><code>root</code></td>
<td>网站根目录</td>
<td></td>
</tr>
<tr>
<td><code>permalink</code></td>
<td>文章的 <a href="https://hexo.io/zh-cn/docs/permalinks" target="_blank" rel="noopener">永久链接</a> 格式</td>
<td><code>:year/:month/:day/:title/</code></td>
</tr>
<tr>
<td><code>permalink_defaults</code></td>
<td>永久链接中各部分的默认值</td>
</tr>
</tbody>
</table>
<blockquote>
<p>网站存放在子目录</p>
<p>如果您的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p>
</blockquote>
<h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>source_dir</code></td>
<td>资源文件夹，这个文件夹用来存放内容。</td>
<td><code>source</code></td>
</tr>
<tr>
<td><code>public_dir</code></td>
<td>公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td><code>public</code></td>
</tr>
<tr>
<td><code>tag_dir</code></td>
<td>标签文件夹</td>
<td><code>tags</code></td>
</tr>
<tr>
<td><code>archive_dir</code></td>
<td>归档文件夹</td>
<td><code>archives</code></td>
</tr>
<tr>
<td><code>category_dir</code></td>
<td>分类文件夹</td>
<td><code>categories</code></td>
</tr>
<tr>
<td><code>code_dir</code></td>
<td>Include code 文件夹</td>
<td><code>downloads/code</code></td>
</tr>
<tr>
<td><code>i18n_dir</code></td>
<td>国际化（i18n）文件夹</td>
<td><code>:lang</code></td>
</tr>
<tr>
<td><code>skip_render</code></td>
<td>跳过指定文件的渲染，您可使用 <a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">glob 表达式</a>来匹配路径。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>提示</p>
<p>如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。</p>
</blockquote>
<h5 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new_post_name</code></td>
<td>新文章的文件名称</td>
<td>:title.md</td>
</tr>
<tr>
<td><code>default_layout</code></td>
<td>预设布局</td>
<td>post</td>
</tr>
<tr>
<td><code>auto_spacing</code></td>
<td>在中文和英文之间加入空格</td>
<td>false</td>
</tr>
<tr>
<td><code>titlecase</code></td>
<td>把标题转换为 title case</td>
<td>false</td>
</tr>
<tr>
<td><code>external_link</code></td>
<td>在新标签中打开链接</td>
<td>true</td>
</tr>
<tr>
<td><code>filename_case</code></td>
<td>把文件名称转换为 (1) 小写或 (2) 大写</td>
<td>0</td>
</tr>
<tr>
<td><code>render_drafts</code></td>
<td>显示草稿</td>
<td>false</td>
</tr>
<tr>
<td><code>post_asset_folder</code></td>
<td>启动 <a href="https://hexo.io/zh-cn/docs/asset-folders" target="_blank" rel="noopener">Asset 文件夹</a></td>
<td>false</td>
</tr>
<tr>
<td><code>relative_link</code></td>
<td>把链接改为与根目录的相对位址</td>
<td>false</td>
</tr>
<tr>
<td><code>future</code></td>
<td>显示未来的文章</td>
<td>true</td>
</tr>
<tr>
<td><code>highlight</code></td>
<td>代码块的设置</td>
</tr>
</tbody>
</table>
<blockquote>
<p>相对地址</p>
<p>默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为<code>example.com</code>,您有一篇文章名为<code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p>
</blockquote>
<h5 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>default_category</code></td>
<td>默认分类</td>
<td><code>uncategorized</code></td>
</tr>
<tr>
<td><code>category_map</code></td>
<td>分类别名</td>
<td></td>
</tr>
<tr>
<td><code>tag_map</code></td>
<td>标签别名</td>
</tr>
</tbody>
</table>
<h5 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h5><p>Hexo 使用 <a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a> 来解析和显示时间。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>date_format</code></td>
<td>日期格式</td>
<td><code>YYYY-MM-DD</code></td>
</tr>
<tr>
<td><code>time_format</code></td>
<td>时间格式</td>
<td><code>H:mm:ss</code></td>
</tr>
</tbody>
</table>
<h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>per_page</code></td>
<td>每页显示的文章量 (0 = 关闭分页功能)</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>pagination_dir</code></td>
<td>分页目录</td>
<td><code>page</code></td>
</tr>
</tbody>
</table>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>theme</code></td>
<td>当前主题名称。值为<code>false</code>时禁用主题</td>
</tr>
<tr>
<td><code>deploy</code></td>
<td>部署部分的设置</td>
</tr>
</tbody>
</table>
<h4 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h4><p>新建文件之后 文件的基本格式包含 Front-matter部分 , 就是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="string">/03/12</span> <span class="number">16</span><span class="string">:26:09</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>下面是一些预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<blockquote>
<p>参数    描述<br>layout    布局<br>title    标题<br>date    建立日期<br>updated    更新日期<br>comments    开启文章的评论功能<br>tags    标签（不适用于分页）<br>categories    分类（不适用于分页）<br>permalink    覆盖文章网址</p>
</blockquote>
<h4 id="layout（布局）"><a href="#layout（布局）" class="headerlink" title="layout（布局）"></a>layout（布局）</h4><p>当你每一次使用代码</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> paper</span><br></pre></td></tr></table></figure>
<p>它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。</p>
<p>Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">布局	路径</span><br><span class="line">post	source/_posts</span><br><span class="line">page	source</span><br><span class="line">draft	source/_drafts</span><br></pre></td></tr></table></figure>
<p>而new这个命令其实是：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type"></span>[layout] &lt;标题&gt;</span><br></pre></td></tr></table></figure>
<p>只不过这个layout默认是post罢了。</p>
<p>page<br>如果你想另起一页，那么可以使用</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span>board</span><br></pre></td></tr></table></figure>
<p>系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是<a href="http://xxx.xxx/board" target="_blank" rel="noopener">http://xxx.xxx/board</a></p>
<p>draft<br>draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type">draft</span> <span class="keyword">new</span><span class="type">page</span></span><br></pre></td></tr></table></figure>
<p>这样会在source/_draft中新建一个newpage.md文件，如果草稿文件写的过程中，想要预览一下，那么可以使用</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo<span class="built_in"> server </span>--draft</span><br></pre></td></tr></table></figure>
<p>在本地端口中开启服务预览。</p>
<p>如果你的草稿文件写完了，想要发表到post中，</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo publish draft newpage</span></span><br></pre></td></tr></table></figure>
<p>就会自动把newpage.md发送到post中。</p>
<h4 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h4><p>官方主题地址 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<p>我选的是<strong>maupassant</strong> 理由是简洁,使用方便,耐看,觉得不好看来怼我    </p>
<p>github地址是 <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">https://github.com/tufu9441/maupassant-hexo</a></p>
<p><img src="/2019/03/13/hexo搭建/687474703a2f2f6f6f6f2e306f302e6f6f6f2f323031352f31302f32342f353632623562653132313737652e6a7067.jfif" alt="template preview"></p>
<p>使用极其方便 跟着向导走就可以  <a href="https://www.haomwei.com/technology/maupassant-hexo.html" target="_blank" rel="noopener">https://www.haomwei.com/technology/maupassant-hexo.html</a></p>
<p>防止以后找不到 自己记一下 主目录执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-renderer-pug --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-renderer-sass --save</span></span><br></pre></td></tr></table></figure>
<p>编辑Hexo目录下的 <code>_config.yml</code>，将<code>theme</code>的值改为<code>maupassant</code>。</p>
<p>注：若<code>npm install hexo-renderer-sass</code>安装时报错，可能是国内网络问题，请尝试使用代理或者切换至<a href="http://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像</a>安装，感谢光头强提供的<a href="http://www.rockcoding.com/2016/03/02/hexo/" target="_blank" rel="noopener">方法</a>。</p>
<h4 id="主题配置说明"><a href="#主题配置说明" class="headerlink" title="主题配置说明"></a>主题配置说明</h4><ul>
<li>fancybox - 是否启用<a href="http://fancyapps.com/fancybox/" target="_blank" rel="noopener">Fancybox</a>图片灯箱效果</li>
<li>disqus - <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus评论</a> shortnam</li>
<li>uyan - <a href="http://www.uyan.cc/" target="_blank" rel="noopener">友言评论</a> id</li>
<li>livere - <a href="https://livere.com/" target="_blank" rel="noopener">来必力评论</a> data-uid</li>
<li>changyan - <a href="http://changyan.kuaizhan.com/" target="_blank" rel="noopener">畅言评论</a> appid</li>
<li>gitment - <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment评论</a>相关参数</li>
<li>gitalk - <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk评论</a>相关参数</li>
<li>valine - <a href="https://valine.js.org/" target="_blank" rel="noopener">Valine评论</a>相关参数</li>
<li>google_search - 默认使用Google搜索引擎</li>
<li>baidu_search - 若想使用百度搜索，将其设定为<code>true</code>。</li>
<li>swiftype - <a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a> 站内搜索key</li>
<li>tinysou - <a href="http://tinysou.com/" target="_blank" rel="noopener">微搜索</a> key</li>
<li>self_search - 基于jQuery的<a href="http://hahack.com/codes/local-search-engine-for-hexo" target="_blank" rel="noopener">本地搜索引擎</a>，需要安装<a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a>插件使用。</li>
<li>google_analytics - <a href="https://www.google.com/analytics/" target="_blank" rel="noopener">Google Analytics</a> 跟踪ID</li>
<li>baidu_analytics - <a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a> 跟踪ID</li>
<li>show_category_count - 是否显示侧边栏分类数目</li>
<li>toc_number - 是否显示文章中目录列表自动编号</li>
<li>shareto - 是否使用分享按鈕，需要安装<a href="https://github.com/yscoder/hexo-helper-qrcode" target="_blank" rel="noopener">hexo-helper-qrcode</a>插件使用</li>
<li>busuanzi - 是否使用<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>页面访问计数</li>
<li>widgets_on_small_screens - 是否在移动设备屏幕底部显示侧边栏</li>
<li><a href="https://github.com/hustcc/canvas-nest.js/blob/master/README-zh.md" target="_blank" rel="noopener">canvas_nest</a> - 是否使用canvas动态背景</li>
<li>donate - 是否启用捐赠按钮</li>
<li>menu - 自定义页面及菜单，依照已有格式填写。填写后请在<code>source</code>目录下建立相应名称的文件夹，并包含<code>index.md</code>文件，以正确显示页面。导航菜单中集成了<a href="http://fontawesome.io/" target="_blank" rel="noopener">FontAwesome</a>图标字体，可以在<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">这里</a>选择新的图标，并按照相关说明使用。</li>
<li>widgets - 选择和排列希望使用的侧边栏小工具。</li>
<li>links - 友情链接，请依照格式填写。</li>
<li>timeline - 网站历史时间线，在页面<code>front-matter</code>中设置<code>layout: timeline</code>可显示。</li>
<li>Static files - 静态文件存储路径，方便设置CDN缓存。</li>
<li>Theme version - 主题版本，便于静态文件更新后刷新CDN缓存。</li>
</ul>
<h5 id="添加页面"><a href="#添加页面" class="headerlink" title="添加页面"></a>添加页面</h5><p>在<code>source</code>目录下建立相应名称的文件夹，然后在文件夹中建立<code>index.md</code>文件，并在<code>index.md</code>的<code>front-matter</code>中设置layout为<code>layout: page</code>。若需要单栏页面，就将layout设置为 <code>layout: single-column</code>。</p>
<h5 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h5><p>在文章的<code>front-matter</code>中添加<code>toc: true</code>即可让该篇文章显示目录。</p>
<h5 id="文章评论"><a href="#文章评论" class="headerlink" title="文章评论"></a>文章评论</h5><p>文章和页面的评论功能可以通过在<code>front-matter</code>中设置<code>comments: true</code>或<code>comments: false</code>来进行开启或关闭（默认开启）。</p>
<h5 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h5><p>要启用代码高亮，请在Hexo目录的<code>_config.yml</code>中将<code>highlight</code>选项按照如下设置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br></pre></td></tr></table></figure>
<p>都配置好之后，使用命令查看效果 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p> 美滋滋…</p>
<h3 id="更换电脑发布博客方法"><a href="#更换电脑发布博客方法" class="headerlink" title="更换电脑发布博客方法"></a>更换电脑发布博客方法</h3><p>你以为这就完了, 先别美滋滋,最关键的地方来了 下班了 ,电脑不想带回去 , 我想更新博客 , 怎么办???  按上面重来一次弄环境 ? 嘿嘿  这时候我看到网上说可以使用github将源文件上传到分支 主干负责美貌美如花可以了 nb 方法  我怎么就想不到呢</p>
<p>具体的思路是：在生成的已经推到github上的hexo静态代码出建立一个分支，利用这个分支来管理自己hexo的源文件。如果能在刚刚配置hexo的时候就想好以后的迁移的问题就太好了，可以省掉很多麻烦，可实际使用中，刚刚配置hexo的时候，好多人都是初学，不会想到以后的问题，我就是这样的。所以说可以先操作这个过程 然后再执行上面的操作</p>
<p>具体的操作：</p>
<p>克隆gitHub上面生成的静态文件到本地</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/ejeonline/ejeonline.github.io.git</span><br></pre></td></tr></table></figure>
<p>把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就到删了吧。不要用<code>hexo init</code>初始化。</p>
<p><img src="/2019/03/13/hexo搭建/1552460232589.png" alt="1552460232589"></p>
<p>把上面图中文件复制到这边的文件夹中  </p>
<p>创建一个叫blog_file的分支</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">git checkout -<span class="selector-tag">b</span> blog_file</span><br></pre></td></tr></table></figure>
<p>提交复制过来的文件到暂存区</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> --all</span></span><br></pre></td></tr></table></figure>
<p>提交</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">"新建分支源文件"</span></span><br></pre></td></tr></table></figure>
<p>推送分支到github</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">push</span> --<span class="keyword">set</span>-upstream origin blog_file</span><br></pre></td></tr></table></figure>
<p>到这里基本上就搞定了，以后再推就可以直接<code>git push</code>了，hexo的操作跟以前一样。</p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础(一)</title>
    <url>/2019/03/12/Java%E5%9F%BA%E7%A1%80(%E4%B8%80)/</url>
    <content><![CDATA[<a id="more"></a>
<h4 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h4><h5 id="1-hashcode相等两个类一定相等吗？equals呢？相反呢？"><a href="#1-hashcode相等两个类一定相等吗？equals呢？相反呢？" class="headerlink" title="1.hashcode相等两个类一定相等吗？equals呢？相反呢？"></a>1.hashcode相等两个类一定相等吗？equals呢？相反呢？</h5><p>重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理这两个方法。</p>
<h5 id="2-集合框架"><a href="#2-集合框架" class="headerlink" title="2.集合框架"></a>2.集合框架</h5><p>Java集合框架下大致可以分为五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。</p>
<p>Java集合类的整体框架如下：<img src="/2019/03/12/Java基础(一)/Java基础(一" alt="img">/4676229-f093fafe4fc63713.png)</p>
<p>集合类主要分为两大类：Collection和Map。</p>
<h5 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h5><p>Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</p>
<h5 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h5><p>List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。和下面要提到的Set不同，List允许有相同的元素。</p>
<p>除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。</p>
<p>实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。</p>
<h5 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h5><p>Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。<br>很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</p>
<p>Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。</p>
<hr>
<p>我们看到，抽象类AbstractCollection、AbstractList和AbstractSet分别实现了Collection、List和Set接口，这就是在Java集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</p>
<ul>
<li><h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h5></li>
</ul>
<p>请注意，Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。</p>
<ul>
<li><h5 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h5></li>
</ul>
<p>Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。</p>
<ul>
<li><h5 id="Arrays和Collections工具类"><a href="#Arrays和Collections工具类" class="headerlink" title="Arrays和Collections工具类"></a>Arrays和Collections工具类</h5></li>
</ul>
<p>Arrays和Collections是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选Concurrent并发包下的对应的集合类。</p>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h4><ul>
<li><strong>Arraylist：</strong> Object数组</li>
<li><strong>Vector：</strong> Object数组</li>
<li><strong>LinkedList：</strong> 双向循环链表</li>
</ul>
<h4 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h4><ul>
<li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素。HashMap底层数据结构见下。</li>
<li><strong>LinkedHashSet：</strong> LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li>
<li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树。)</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li>
<li><strong>LinkedHashMap:</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><strong>HashTable:</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><strong>TreeMap:</strong> 红黑树（自平衡的排序二叉树）</li>
</ul>
<h5 id="3-hashmap和hashtable-ConcurrentHashMap底层实现有什么区别？"><a href="#3-hashmap和hashtable-ConcurrentHashMap底层实现有什么区别？" class="headerlink" title="3.hashmap和hashtable,ConcurrentHashMap底层实现有什么区别？"></a>3.hashmap和hashtable,ConcurrentHashMap底层实现有什么区别？</h5><ul>
<li><p>hashtable简单的理解就是hashmap的线程安全类 其方法大部分都相同只不过家了synchronize关键字保证其线程安全。其他的区别也有继承的接口不同这点。 </p>
<p>concurrenthashtable则是改进了hashtable的效率，hashtable虽然安全但是不能多线程同时操作，concurrenthashtable使用了分块的模式支持多线程操作，且使用了lock替换synchronize来提高了效率。</p>
</li>
</ul>
<p>4.hashmap和treemap有什么区别？底层数据结构是什么？</p>
<p>HashMap底层就是一个数组，数组中根据存入的Key的HashCode决定存放位置，其Entry单元中有四个属性，分别为HashCode，Key，Vaule，和下一个Entry，这样就形成了一个链表，当HashMap中的另一个拥有相同的HashCode值的不同的Key存入时，会将原来的Entry赋到新Entry的属性中，然后形成Entry链，查询的时候先比较HashCode，如果相同且Key值相同则直接取出，如果HashCode相同Key值不同则继续顺着链表寻找直到寻找到相同的Key值。 </p>
<p>TreeMap与HashMap的不同：表象上时TreeMap可以对Key进行排序，原因时TreeMap使用的时“红黑树”的二叉树结构储存Entry，也就是排序二叉树，左边恒放比此值小的数右边恒放比此值大的树，按照当前节点值与传入查询值的比较进行判断决定其存放位置/查询其数值；</p>
<p>5.线程池用过吗?都有什么参数？底层如何实现的？<br>线程池：<br>1、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。<br>2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。<br>参数：<br>corePoolSize：线程池核心线程数量<br>maximumPoolSize:线程池最大线程数量<br>keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间<br>unit：存活时间的单位<br>workQueue：存放任务的队列<br>handler：超出线程范围和队列容量的任务的处理程序<br>底层核心实现为封装一层线程类work，在运行的时候再执行完自己的线程后主动去队列中拿取下一条线程去执行。</p>
<p>6.sychnized和Lock的区别、sychnized什么情况是对象锁，什么情况是全局锁，为什么？</p>
<p>synchronized是java中的一个关键字，用于线程同步。 </p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。</li>
</ol>
<p>synchronized修饰不加static的方法，锁是加在单个对象上，不同的对象没有竞争关系；修饰加了static的方法，锁是加载类上，这个类所有的对象竞争一把锁。</p>
<p>Lock是一个java接口 里面有一些实现类，也用于实现线程同步，但是相比较于synchronized，无论功能还是性能都有很大提升，但是要注意需要手动释放。<br>性能上由于synchronized在编译时会对代码进行修正，最终由cpu通过调度线程的方式处理线程同步问题，开销很大。而lock使用了Java的unsafe类中的CAS方法实现对线程同步的控制，减小了消耗。 </p>
<p>功能上：synchronized由线程控制，只有等待执行结束和异常释放，本身是可重入的，非公平锁，书写时无需手动释放。lock实现多样，除了最基础的可重入锁ReentrantLock，还有使用读写锁（ReadWriteLock）来实现读写分离，进一步提高效率，ReentrantLock默认使用的是非公平锁（竞争锁，可以设置）。</p>
<p>7.ThreadLocal是什么？底层如何实现？写个例子呗？<br>是一个解决线程并发问题的一个类，底层实现主要是存有一个map，以线程作为key，范型作为value。可以理解为线程级别的缓存。<br>使用起来比较简单 假设我们要实现一个线程级别的缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&gt; testInt=<span class="keyword">new</span> ThreadLocal&lt;Map&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">getMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map s = (Map) testInt.get();</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</span><br><span class="line">                s=<span class="keyword">new</span> HashMap();</span><br><span class="line">                testInt.set(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就能实现在调用这个方法的时候 获得的map是线程级别的。每一个线程都会获得一个单独的map。</p>
<p>8.volitile的工作原理？<br>定义：<br>java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁更加方便。如果一个字段被声明成volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。<br>在多个线程之间能够被共享的变量被称为共享变量。共享变量包括所有的实例变量，静态变量和数组元素。他们都被存放在堆内存中，volatile只作用于共享变量。<br>工作原理：<br>在汇编时 有volatile修饰符的变量将会被lock，这个lock做两件事：</p>
<p>1.将当前处理器缓存行的数据会写回到系统内存。<br>2.这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。<br>你也可以理解为：volatile修饰的变量在修改时直接修改内存（越过缓存）</p>
<h3 id="1-equals方法的几个特性："><a href="#1-equals方法的几个特性：" class="headerlink" title="1.equals方法的几个特性："></a>1.equals方法的几个特性：</h3><p>equals方法必须满足自反性、对称性、传递性和一致性。</p>
<h3 id="2-为什么函数不能根据返回类型来区分重载？"><a href="#2-为什么函数不能根据返回类型来区分重载？" class="headerlink" title="2. 为什么函数不能根据返回类型来区分重载？"></a>2. 为什么函数不能根据返回类型来区分重载？</h3><p>因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">float max(int a, int b);</span><br><span class="line">int max(int a, int b);</span><br></pre></td></tr></table></figure>
<p>当调用 max(1, 2);时无法确定调用的是哪个。</p>
<h3 id="3-抽象方法-abstract-是否可同时是静态的-static-？是否可同时是本地方法-native-？是否可同时被-synchronized修饰？"><a href="#3-抽象方法-abstract-是否可同时是静态的-static-？是否可同时是本地方法-native-？是否可同时被-synchronized修饰？" class="headerlink" title="3. 抽象方法(abstract)是否可同时是静态的(static)？是否可同时是本地方法(native)？是否可同时被 synchronized修饰？"></a>3. 抽象方法(abstract)是否可同时是静态的(static)？是否可同时是本地方法(native)？是否可同时被 synchronized修饰？</h3><p>都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的；本地方法是由本地代码实现的方法，而抽象方法是没有实现的，也是矛盾的；synchronized 和方法的实现细节有关， 抽象方法不涉及实现细节，因此也是相互矛盾的。</p>
<h3 id="4-Math-round-11-5-等于多少？Math-round-11-5-又等于多少"><a href="#4-Math-round-11-5-等于多少？Math-round-11-5-又等于多少" class="headerlink" title="4. Math.round(11.5)等于多少？Math.round(- 11.5) 又等于多少?"></a>4. Math.round(11.5)等于多少？Math.round(- 11.5) 又等于多少?</h3><p>第一个等于12，第二个等于-11。四舍五入的原理是在参数上加 0.5然后进行取整。</p>
<h3 id="5-关于生成随机数问题："><a href="#5-关于生成随机数问题：" class="headerlink" title="5. 关于生成随机数问题："></a>5. 关于生成随机数问题：</h3><ul>
<li>Math.random()：令系统随机选取大于等于 0.0 且小于 1.0 的伪随机 double 值，比如要生成1到10之间的随机数：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random()*<span class="number">9</span>+<span class="number">1</span>; <span class="comment">//  这样生成的有十多为小数</span></span><br></pre></td></tr></table></figure>
<p>写一个生成任意两个数之间的随机整数的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> int getRandom(int start,int end)&#123;</span><br><span class="line">    <span class="keyword">return</span> (int)(<span class="built_in">Math</span>.random()*(end-start+<span class="number">1</span>))+start;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Random类：用法如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="comment">//Integer a =random.nextInt(90) + 10;//生成两位随机数</span></span><br><span class="line">Integer number =random.nextInt(<span class="number">900000</span>) + <span class="number">100000</span>;<span class="comment">//生成六位随机数</span></span><br></pre></td></tr></table></figure>
<h3 id="6-如何获取年月日小时分钟秒？"><a href="#6-如何获取年月日小时分钟秒？" class="headerlink" title="6. 如何获取年月日小时分钟秒？"></a>6. 如何获取年月日小时分钟秒？</h3><p>java 1.8之前：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.get(Calendar.MONTH));<span class="comment">// 0-11，所以获取当前月份要加1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>java 1.8新增：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">LocalDateTime localTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localTime.getMonthValue());<span class="comment">// 1-12</span></span><br></pre></td></tr></table></figure>
<h3 id="7-如何取得从-1970-年-1-月-1-日-0-时-0-分-0-秒到现在的毫秒数？"><a href="#7-如何取得从-1970-年-1-月-1-日-0-时-0-分-0-秒到现在的毫秒数？" class="headerlink" title="7.  如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？"></a>7.  如何取得从 1970 年 1 月 1 日 0 时 0 分 0 秒到现在的毫秒数？</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Calendar.getInstance().getTimeInMillis();  <span class="comment">//第一种方式 </span></span><br><span class="line">System.currentTimeMillis();  <span class="comment">//第二种方式</span></span><br></pre></td></tr></table></figure>
<h3 id="8-格式化日期："><a href="#8-格式化日期：" class="headerlink" title="8. 格式化日期："></a>8. 格式化日期：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd"</span>); </span><br><span class="line"><span class="built_in">Date</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">System.out.println(sdf.format(date1)); </span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd"</span>);      </span><br><span class="line">LocalDate date2 = LocalDate.now(); </span><br><span class="line">System.out.println(date2.format(dtf));</span><br></pre></td></tr></table></figure>
<h3 id="9-关于Integer的问题：下面这段代码输出结果如何"><a href="#9-关于Integer的问题：下面这段代码输出结果如何" class="headerlink" title="9. 关于Integer的问题：下面这段代码输出结果如何?"></a>9. 关于Integer的问题：下面这段代码输出结果如何?</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="number">100</span>,i2 = <span class="number">100</span>,i3 = <span class="number">150</span>,i4 = <span class="number">150</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>这是因为Integer在设计的时候用了一个IntegerCache，如果数值在 -128 ~ 127之间，那么就直接从IntegerCache里拿出来用，如果在这个范围之外，就会new新的Integer对象。</p>
<h3 id="10-字符串如何转成基本类型？"><a href="#10-字符串如何转成基本类型？" class="headerlink" title="10. 字符串如何转成基本类型？"></a>10. 字符串如何转成基本类型？</h3><p>使用对应的包装类调用valueOf或者parseXxx方法即可，例如要将字符串转成int类型，方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> s = <span class="string">"1234"</span>;</span><br><span class="line">int x = Integer.parseInt(s);<span class="comment">// 方式一</span></span><br><span class="line">int y = Integer.valueOf(s);<span class="comment">// 方式二</span></span><br></pre></td></tr></table></figure>
<h3 id="11-动静态代理的区别，什么场景使用？"><a href="#11-动静态代理的区别，什么场景使用？" class="headerlink" title="11. 动静态代理的区别，什么场景使用？"></a>11. 动静态代理的区别，什么场景使用？</h3><p>静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。动态代理是实现JDK里的 InvocationHandler接口的 invoke方法，但注意的是代理的是接口，也就是你的业务类必须要实现接口，通过Proxy里的newProxyInstance得到代理对象。  AOP编程就是基于动态代理实现的，比如著名的Spring框架、Hibernate框架等等都是动态代理的使用例子。</p>
<h3 id="12-heap-堆-和stack-栈-有什么区别？"><a href="#12-heap-堆-和stack-栈-有什么区别？" class="headerlink" title="12.heap(堆)和stack(栈)有什么区别？"></a>12.heap(堆)和stack(栈)有什么区别？</h3><p>有以下几个方面的区别：</p>
<ul>
<li>申请方式 ：stack由系统自动分配。例如声明一个局部变量 int b，系统自动在栈中为b开辟空间 ；heap需要程序员自己以new Object的形式申请，并指明大小。</li>
<li>申请后系统的响应 ：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出；而对于堆而言，操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</li>
<li>申请大小的限制 ：能从栈获得的空间较小；堆获得的空间比较灵活，也比较大。</li>
<li>申请效率的比较： stack由系统自动分配，速度较快，但程序员是无法控制的。 heap由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</li>
<li>存储的内容不同：栈中存储引用、局部变量等；堆中存储对象、成员变量等内容。</li>
</ul>
<h3 id="13-Java的类加载器有哪些？"><a href="#13-Java的类加载器有哪些？" class="headerlink" title="13. Java的类加载器有哪些？"></a>13. Java的类加载器有哪些？</h3><ul>
<li>根类加载器(Bootstrap)：C++写的 ，看不到源码</li>
<li>扩展类加载器(Extension)：加载位置 ：jre\lib\ext中</li>
<li>系统(应用)类加载器(System\App)：加载位置 ：classpath中</li>
<li>自定义加载器(必须继承ClassLoader)</li>
</ul>
<h2 id="二、JavaWeb基础："><a href="#二、JavaWeb基础：" class="headerlink" title="二、JavaWeb基础："></a>二、JavaWeb基础：</h2><h3 id="1-说一下原生的JDBC操作数据库的流程。"><a href="#1-说一下原生的JDBC操作数据库的流程。" class="headerlink" title="1. 说一下原生的JDBC操作数据库的流程。"></a>1. 说一下原生的JDBC操作数据库的流程。</h3><p>总共有5个步骤，如下：</p>
<ul>
<li>第一步加载数据库连接驱动：Class.forName()</li>
<li>第二步获取数据连接对象：DriverManager.getConnection()</li>
<li>第三步根据SQL获取sql会话对象，可以使用 Statement或者PreparedStatement</li>
<li>第四步执行SQL处理结果集，执行SQL前如果有参数值就设置参数值setXXX()</li>
<li>第五步关闭结果集、关闭会话、关闭连接</li>
</ul>
<h3 id="2-说说PreparedStatement和Statement的区别。"><a href="#2-说说PreparedStatement和Statement的区别。" class="headerlink" title="2. 说说PreparedStatement和Statement的区别。"></a>2. 说说PreparedStatement和Statement的区别。</h3><p>PreparedStatement接口继承Statement， PreparedStatement 实例包含已编译的 SQL 语句，所以其执行速度要快于 Statement 对象。Statement需要不断地拼接sql语句，而PreparedStatement不用，所以可以防止SQL注入。</p>
<h3 id="3-谈谈关系数据库连接池的机制。"><a href="#3-谈谈关系数据库连接池的机制。" class="headerlink" title="3. 谈谈关系数据库连接池的机制。"></a>3. 谈谈关系数据库连接池的机制。</h3><p>连接池其实就是为数据库建立了一个缓冲池，连接池中的连接数量一直保持一个不少于最小连接数的数量，使用时从连接池拿出连接，用完还给连接池。当数量不够时，数据库会创建一些连接，直到一个最大连接数。</p>
<h3 id="4-什么叫http协议？"><a href="#4-什么叫http协议？" class="headerlink" title="4. 什么叫http协议？"></a>4. 什么叫http协议？</h3><p>HTTP(Hypertext transfer protocol)：超文本传输协议，详细的制定了万维网服务器与客户端间的数据传输的通信规则。HTTP是基于TCP/IP通信协议来传递数据的，属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
<h3 id="5-http常见的状态码有哪些？"><a href="#5-http常见的状态码有哪些？" class="headerlink" title="5. http常见的状态码有哪些？"></a>5. http常见的状态码有哪些？</h3><p>常见状态码如下：</p>
<ul>
<li>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解</li>
<li>403 Forbidden   //服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found  //请求资源不存在</li>
<li>500 Internal Server Error //服务器发生不可预期的错误</li>
</ul>
<h3 id="6-Get请求和Post请求的区别是什么？"><a href="#6-Get请求和Post请求的区别是什么？" class="headerlink" title="6. Get请求和Post请求的区别是什么？"></a>6. Get请求和Post请求的区别是什么？</h3><p>Get会把请求时的数据暴露在url中，Post则把提交的数据放置在HTTP包的包体中。所以就这点而言，Post方式更加安全。由于浏览器及服务器的限制，Get方式提交的数据最多只能是1024字节，Post理论上没有限制，可传较大量的数据。</p>
<h3 id="7-请求转发-forward-和重定向-redirect-有什么区别？"><a href="#7-请求转发-forward-和重定向-redirect-有什么区别？" class="headerlink" title="7. 请求转发(forward)和重定向(redirect)有什么区别？"></a>7. 请求转发(forward)和重定向(redirect)有什么区别？</h3><p>区别如下：</p>
<ul>
<li>请求重定向：客户端行为，从本质上讲相当于请求两次，地址栏URL会改变，前一次的请求对象不会保存。举例：A去B局办事，B局说这个事是C管的，然后A就自己去了C局</li>
<li>请求转发：服务器行为，是一次请求，地址栏URL不变，会保存转发后的请求对象。 举例：A去B局办事，B局知道这个事是C局管的，B局就联系了C局的人办好了这件事。</li>
</ul>
<h3 id="8-说说cookie和session的区别。"><a href="#8-说说cookie和session的区别。" class="headerlink" title="8. 说说cookie和session的区别。"></a>8. 说说cookie和session的区别。</h3><p>Cookie 是 web 服务器发送给浏览器的信息，浏览器会在本地一个文件中给每个 web 服务器存储 cookie。以后浏览器再给特定的web服务器发送请求时，同时会发送所有为该服务器存储的cookie。 Session 是存储在 web 服务器端的信息。session <a href="https://cloud.tencent.com/product/cos" target="_blank" rel="noopener">对象存储</a>特定用户会话所需的属性及配置信息。当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。无论客户端做怎样的设置，session都能够正常工作；当客户端禁用cookie时将无法使用cookie。 在存储的数据量方面：session能够存储任意的java对象，cookie只能存储String类型的对象。</p>
<h3 id="9-什么是jsp，什么是Servlet？jsp和Servlet有什么区别？"><a href="#9-什么是jsp，什么是Servlet？jsp和Servlet有什么区别？" class="headerlink" title="9. 什么是jsp，什么是Servlet？jsp和Servlet有什么区别？"></a>9. 什么是jsp，什么是Servlet？jsp和Servlet有什么区别？</h3><p>Servlet是由 Java提供用于开发 web服务器应用程序的一个组件，运行在服务端，由servlet 容器管理，用来生成动态内容。一个 servlet 实例是实现了Servlet接口的 Java 类，所有自定义的 servlet 必须实现 Servlet 接口。jsp本质上就是一个Servlet，它是Servlet的一种特殊形式（由SUN公司推出），每个jsp页面都是一个servlet实例。 特殊在哪？就是特殊在jsp是html页面中内嵌的Java代码，侧重页面显示。</p>
<h3 id="10-你知道JSP的四大域对象和九大内置对象吗？"><a href="#10-你知道JSP的四大域对象和九大内置对象吗？" class="headerlink" title="10. 你知道JSP的四大域对象和九大内置对象吗？"></a>10. 你知道JSP的四大域对象和九大内置对象吗？</h3><p>四大域对象是：</p>
<ul>
<li>pageContext：  page域，指当前页面，在当前jsp页面有效，跳到其它页面失效</li>
<li>request： request域，指一次请求范围内有效，从http请求到服务器处理结束，返回响应的整个过程  在这个过程中使用forward（请求转发）方式跳转多个jsp，在这些页面里你都可以使用这个变量</li>
<li>session： session域，指当前会话有效范围，浏览器从打开到关闭过程中，转发、重定向均可以使用</li>
<li>application： context域，指只能在同一个web中使用，服务器未关闭或者重启，数据就有效</li>
</ul>
<p>九大内置对象是：  out、request、response、session、application、page、pageContext、exception和config。</p>
<h3 id="一、JavaWeb高级："><a href="#一、JavaWeb高级：" class="headerlink" title="一、JavaWeb高级："></a>一、JavaWeb高级：</h3><h3 id="1-什么叫监听器-listener"><a href="#1-什么叫监听器-listener" class="headerlink" title="1. 什么叫监听器(listener)?"></a>1. 什么叫监听器(listener)?</h3><p>监听器主要是用来监听特定对象的创建或销毁、属性的变化的，是一个实现特定接口的普通java类。具体实现哪个接口，要看你监听什么内容，比如要监听Request对象的创建或销毁，就实现ServletRequestListener 接口。它是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。</p>
<h3 id="2-什么叫过滤器-filter-？"><a href="#2-什么叫过滤器-filter-？" class="headerlink" title="2. 什么叫过滤器(filter)？"></a>2. 什么叫过滤器(filter)？</h3><p>就是对servlet请求起到过滤的作用，它在监听器之后，作用在servlet之前。比如编码过滤器，就是经过了该过滤器的请求都会设置成过滤器中指定的编码。过滤器是随web应用启动而启动，只初始化一次，只有当web应用停止或重新部署的时候才销毁。</p>
<h3 id="3-什么叫拦截器-interceptor-？"><a href="#3-什么叫拦截器-interceptor-？" class="headerlink" title="3. 什么叫拦截器(interceptor)？"></a>3. 什么叫拦截器(interceptor)？</h3><p>拦截器类似于fileter ，也是拦截用户的请求。不同的是，它不需要在web.xml中配置，不随WEB应用的启动而启动，是基于JAVA的反射机制和动态代理实现的。只有调用相应的方法时才会调用,在面向切面编程中应用的。</p>
<h3 id="4-servlet请求的执行过程是怎样的？"><a href="#4-servlet请求的执行过程是怎样的？" class="headerlink" title="4. servlet请求的执行过程是怎样的？"></a>4. servlet请求的执行过程是怎样的？</h3><p>过程是这样的：context-param(初始化配置) –&gt; listener –&gt; filter –&gt; servlet –&gt; interceptor –&gt; 页面。</p>
<h3 id="5-谈谈你对Ajax的认识。"><a href="#5-谈谈你对Ajax的认识。" class="headerlink" title="5. 谈谈你对Ajax的认识。"></a>5. 谈谈你对Ajax的认识。</h3><p>Asynchronous JavaScript and XML的缩写，是一种创建交互式网页应用的的网页开发技术。通过异步提交的方式，可以实现局部刷新，在不更新整个页面的前提下维护数据，提升用户体验度。</p>
<h3 id="二、数据库："><a href="#二、数据库：" class="headerlink" title="二、数据库："></a>二、数据库：</h3><h3 id="1-select语句的执行顺序怎样的？"><a href="#1-select语句的执行顺序怎样的？" class="headerlink" title="1. select语句的执行顺序怎样的？"></a>1. select语句的执行顺序怎样的？</h3><p>SQL语言不同于其他编程语言的最明显特征是处理代码的执行顺序。在大多数据库语言中，代码按顺序执行，但是SQL语言执行顺序如下：  from –&gt; where –&gt; group by分组 –&gt; 聚合函数 –&gt; having筛选分组 –&gt; 计算所有的表达式 –&gt; select的字段 –&gt; order by排序。</p>
<h3 id="2-你知道聚合函数吗？"><a href="#2-你知道聚合函数吗？" class="headerlink" title="2. 你知道聚合函数吗？"></a>2. 你知道聚合函数吗？</h3><p>聚合函数是对一组值进行计算并返回单一的值的函数，它经常与select 语句中的 group by 子句一同使用。 比如求平均值的聚合函数是avg()。</p>
<h3 id="3-你知道连接查询吗？"><a href="#3-你知道连接查询吗？" class="headerlink" title="3. 你知道连接查询吗？"></a>3. 你知道连接查询吗？</h3><p>连接查询分为内连接和外连接，内连接显示表之间有连接匹配的所有行。外连接又分为左外连接、右外连接和全连接。左外连接就是以左表作为基准进行查询，左表数据会全部显示出来，右表如果和左表匹配的数据则显示相应字段的数据，如果不匹配则显示为null。 右连接是以右表作为基准进行查询，右表数据会全部显示出来，左表如果和右表匹配的数据则显示相应字段的数据，如果不匹配则显示为null。 全连接是先以左表进行左外连接，再以右表进行右外连接。</p>
<h3 id="4-事务有几大特性？分别是什么？"><a href="#4-事务有几大特性？分别是什么？" class="headerlink" title="4. 事务有几大特性？分别是什么？"></a>4. 事务有几大特性？分别是什么？</h3><p>事务有四大特性，ACID。</p>
<ul>
<li>原子性(A)：整个事务中的所有操作，要么全部完成，要么全部不完成。</li>
<li>一致性(C)：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</li>
<li>隔离性(I)：如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。</li>
<li>持久性(D)：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li>
</ul>
<h3 id="5-mysql中的四种隔离级别是什么？"><a href="#5-mysql中的四种隔离级别是什么？" class="headerlink" title="5.mysql中的四种隔离级别是什么？"></a>5.mysql中的四种隔离级别是什么？</h3><p>四种隔离级别如下：</p>
<ul>
<li>读未提交(READ UNCOMMITTED)：未提交读也叫读脏，就是事务可以读取其它事务未提交的数据。</li>
<li>读已提交(READ COMMITTED)：读已提交就是在事务未提交之前所做的修改其它事务是不可见的。 在其它数据库系统比如<a href="https://cloud.tencent.com/product/sqlserver" target="_blank" rel="noopener">SQL Server</a>默认的隔离级别就是读已提交。</li>
<li>可重复读(REPEATABLE READ)：保证同一个事务中的多次相同的查询的结果是一致的，比如一个事务一开始查询了一条记录然后过了几秒钟又执行了相同的查询，保证两次查询的结果是相同的，可重复读也是mysql的默认隔离级别。</li>
<li>可串行化(SERIALIZABLE)：可串行化就是保证读取的范围内没有新的数据插入，比如事务第一次查询得到某个范围的数据，第二次查询也同样得到了相同范围的数据，中间没有新的数据插入到该范围中。</li>
</ul>
<h3 id="6-对于MySQL性能优化，你知道多少？"><a href="#6-对于MySQL性能优化，你知道多少？" class="headerlink" title="6. 对于MySQL性能优化，你知道多少？"></a>6. 对于MySQL性能优化，你知道多少？</h3><p>我知道的有以下几点：</p>
<ul>
<li>当只要一行数据时使用limit 1 。查询时如果已知会得到一条数据，这种情况下加上 limit 1 会增加性能。因为 <a href="https://cloud.tencent.com/product/cdb" target="_blank" rel="noopener">mysql 数据库</a>引擎会在找到一条结果停止搜索，而不是继续查询下一条是否符合标准直到所有记录查询完毕。</li>
<li>选择正确的数据库引擎 。Mysql中有两个引擎，MyISAM和InnoDB，每个引擎有利有弊。 MyISAM 适用于一些大量查询的应用，但对于有大量写功能的应用不是很好。InnoDB是一个非常复杂的存储引擎，对于一些小的应用会比MyISAM还慢，但是在写操作比较多的时候会比较优秀。并且，它支持很多的高级应用，例如：事物。</li>
<li>用not exists代替not in 。Not exists可以使用索引，not in不能使用索引。在数据量比较大的操作中不建议使用not in 这种方式。</li>
<li>对操作符的优化。尽量不采用不利于索引的操作符 ，如：in    not in    is null    is not null    &lt;&gt;  等 。</li>
<li>limit 的基数比较大时使用 between 。  例如：select <em> from admin order by admin_id limit 100000,10  优化为：select </em> from admin where admin_id between 100000 and 100010 order by admin_id。</li>
<li>尽量避免在列上做运算，这样导致索引失效 。  例如：select <em> from admin where year(admin_time)&gt;2014  优化为： select </em> from admin where admin_time&gt; ‘2014-01-01′</li>
</ul>
<h1 id="三、框架篇："><a href="#三、框架篇：" class="headerlink" title="三、框架篇："></a>三、框架篇：</h1><h4 id="一-、Spring"><a href="#一-、Spring" class="headerlink" title="(一)、Spring"></a>(一)、Spring</h4><p><strong>1. 谈谈你对spring的理解。</strong>  <strong>答：</strong>Spring是一个轻量的开源框架，为简化企业级应用开发而生，它的核心如下：</p>
<ul>
<li>控制反转(IOC)：传统的java开发模式中，当需要一个对象时，我们会自己使用new或者getInstance等直接或者间接调用构造方法创建一个对象。而在spring开发模式中，spring容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用spring提供的对象就可以了，这就是控制反转的思想。 控制反转是一种思想，而不是一种技术。</li>
<li>依赖注入(DI)：，spring 使用 javaBean 对象的 set 方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值，这就是依赖注入的思想。依赖注入就是使用了控制反转这种思想的一种技术。</li>
<li>面向切面编程(AOP)：在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等公用操作处理，这就是面向切面编程的思想。AOP底层是动态代理，如果是接口采用的是JDK动态代理，如果是类采用的是CGLIB方式实现动态代理。</li>
</ul>
<p><strong>2. 你知道spring框架中使用了哪些设计模式吗？</strong>  <strong>答：</strong>spring中使用到的部分设计模式如下：</p>
<ul>
<li>单例模式：在spring的配置文件中设置bean默认为单例模式。</li>
<li>模板方法模式：用来解决重复代码，JpaTemplate 、RedisTemplate等。</li>
<li>前端控制器模式：spring提供了前端控制器DispatherServlet来对请求进行分发。</li>
<li>工厂模式：Spring中使用beanFactory来创建对象的实例，就是用的工厂模式。</li>
</ul>
<p><strong>3. 介绍一下spring bean的生命周期。</strong>  <strong>答：</strong>bean的生命周期为 创建 –&gt; 初始化 –&gt; 调用 –&gt; 销毁。</p>
<p><strong>4. 说一说spring有哪些核心模块？</strong>  <strong>答：</strong>主要有以下七大核心模块：  </p>
<p><img src="/2019/03/12/Java基础(一)/Java基础(一" alt="img">/menjqm3dgw.png)</p>
<p>七大核心模块</p>
<ul>
<li>Core模块：封装了框架依赖的最底层部分，包括资源访问、类型转换及一些常用工具类。</li>
<li>Context模块：以Core和Beans为基础，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等，核心接口是ApplicationContext。</li>
<li>AOP模块：面向切面编程，通过配置管理特性，spring AOP直接将面向切面的编程集中到了框架中，所以可以很容易使spring管理的对象支持AOP。</li>
<li>ORM模块：Spring的ORM模块提供了对常用ORM框架如Hibernate，Mybaties等的辅助和支持，他本身更并不实现ORM，仅仅对常见的ORM框架进行封装并对其进行管理。</li>
<li>DAO模块：通常编写数据库代码时总要写一些样板似的内容，如获取连接，创建语句，释放连接等 ，Dao模块将这些模板抽象出来，使得数据库代码变得简单明了，也可以避免因为释放数据库资源失败而导致的问题。</li>
<li>WEB模块：提供了基本的面向web的集成功能，例如多个文件的上传功能、使用servlet监听器、面向web应用程序的上下文来初始化IOC容器，还实现了springMVC。</li>
<li>WEB MVC模块：该模块为spring提供了一套轻量级的mvc实现，他还可以支持和管理其他的mvc框架，如struts。相对于struts，spring自己的mvc框架更加简洁和方便。</li>
</ul>
<p><strong>5. 请描述一下spring的事务。</strong>  <strong>答：</strong>Spring既支持编程式事务管理(也称编码式事务)，也支持声明式的事务管理。编程式事务就是把事务写在业务逻辑代码中，声明式事务是将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。大多数情况下比编程式事务管理更好用。声明式事务可以在配置文件中用<tx>标签来实现，也可以在需要使用事务的方法上加@Transaction注解。</tx></p>
<p><strong>6. 如何理解spring的 IOC容器？</strong>  <strong>答：</strong>IOC就是控制反转，这是一种思想而不是一种技术。通常创建对象是由程序员来new的，而”控制反转”是指new实例的工作不由程序员来做，而是交给Spring容器来做。在Spring中BeanFactory是IOC容器的实际代表者。</p>
<p><strong>7. ApplicationContext是干嘛的？有哪些实现类？</strong>  <strong>答：</strong>ApplicationContext是“应用容器”，继承自BeanFactory。Spring把Bean放在这个容器中，在需要的时候，用getBean方法取出。它的实现有以下三个：</p>
<ul>
<li>FileSystemXmlApplicationContext ：从指定的文件系统路径中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。</li>
<li>ClassPathXmlApplicationContext：从类路径ClassPath中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。</li>
<li>XmlWebApplicationContext：从Web应用中寻找指定的XML配置文件，找到并装载完成ApplicationContext的实例化工作。</li>
</ul>
<p><strong>8. BeanFactory与AppliacationContext有什么区别？</strong>  <strong>答：</strong>BeanFactory 是基础类型的IOC容器，提供完整的IOC服务支持。ApplicationContext 是在 BeanFactory 的基础上构建，是相对比较高级的容器，除了 BeanFactory 的所有支持外，ApplicationContext还提供了事件发布、国际化支持等功能。</p>
<p><strong>9. 依赖注入有哪些实现方式？</strong>  <strong>答：</strong>spring提供了以下四种依赖注入的方式：</p>
<ul>
<li>使用Set方法注入</li>
<li>使用构造方法注入</li>
<li>使用静态工厂注入</li>
<li>使用实例工厂注入</li>
</ul>
<p><strong>10. 什么是spring beans？</strong>  <strong>答：</strong>spring beans 就是被spring容器初始化、配置和管理的对象。</p>
<p><strong>11. 一个spring beans 的定义需要包含什么？</strong>  <strong>答：</strong>一个 Spring Bean 的定义包含容器必知的所有配置元数据，包括如何创建一个 bean，它的生命周期详情及它的依赖。</p>
<p><strong>12. spring支持几种类的作用域？</strong>  <strong>答：</strong>spring在配置bean的时候，可以通过scope属性来定义作用域，scope属性有以下5个值：</p>
<ul>
<li>singleton : bean在每个Spring ioc 容器中只有一个实例。 默认就是singleton，它是线程不安全的。</li>
<li>prototype：每一次请求都会产生一个新的bean实例。</li>
<li>request：request表示针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效。</li>
<li>session：作用域表示针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效。</li>
<li>global session：作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义。</li>
</ul>
<p><strong>13. 怎么开启spring的注解装配？</strong>  <strong>答：</strong>spring默认是没有开启注解的，要使用注解，我们必须在 Spring 配置文件中配置 <a href="context:annotation-config/" target="_blank" rel="noopener">context:annotation-config/</a>元素。</p>
<p><strong>14. 简单的说一下AOP编程中的相关概念。</strong>  <strong>答：</strong>主要有如下概念：</p>
<ul>
<li>Joinpoint(连接点) : 类里面可以被增强的方法，这些方法称为连接点 。</li>
<li>Pointcut(切入点)：在哪些类的哪些方法上切入(where)。</li>
<li>Advice(通知/增强) ：拦截到Joinpoint之后所要做的事情就是通知。通知分为前置通知、后置通知、异常通知、最终通知、环绕通知。</li>
<li>Aspect(切面) : 切面 = 切入点 + 通知，通俗点就是：在什么时机，什么地方，做什么增强。</li>
<li>Weaving(织入) ：把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）。</li>
<li>Target(目标对象) ：需要增强的类就是目标对象。</li>
<li>Proxy(代理) ：一个类被AOP织入增强后，就产生一个代理类。</li>
</ul>
<h4 id="二-、SpringMVC"><a href="#二-、SpringMVC" class="headerlink" title="(二)、SpringMVC"></a>(二)、SpringMVC</h4><p><strong>1. 什么是springMVC?</strong>  <strong>答：</strong>Spring MVC是一种基于Java的实现了Web MVC设计模式的请求驱动类型的轻量级Web框架。使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型。框架的目的就是帮助我们简化开发。</p>
<p><strong>2. 简单描述一下SpringMVC的工作原理。</strong>  <strong>答：</strong>工作原理如下：</p>
<p>DispatcherServlet是前置控制器来对相应的规则分发到目标Controller来处理，是配置spring MVC的第一步。</p>
<ul>
<li>用户向服务器发送请求，请求被springMVC前端控制器DispatcherServlet捕获；</li>
<li>由DispatcherServlet控制器找到处理请求的Controller；</li>
<li>DispatcherServlet将请求提交到Controller；</li>
<li>Controller调用业务逻辑处理后，返回ModelAndView给DispatcherServlet；</li>
<li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图；</li>
<li>ViewResoler 解析出 ModelAndView()中的参数，将视图返回给客户端; 。</li>
</ul>
<p><strong>3. springMVC有什么优点？</strong>  <strong>答：</strong>它是基于组件技术的，全部的应用对象,无论控制器和视图,还是业务对象之类的都是 java组件；可以任意使用各种视图技术,而不仅仅局限于JSP；支持各种请求资源的映射策略；它应是易于扩展的。</p>
<p><strong>4. springMVC和struts2有什么区别？</strong>  <strong>答：</strong>区别如下：</p>
<ul>
<li>springmvc的入口是一个servlet即前端控制器（DispatcherServlet），而struts2入口是一个filter过虑器（StrutsPrepareAndExecuteFilter）。</li>
<li>springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。</li>
<li>Struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过reques域传输到页面。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ面试</title>
    <url>/2019/03/12/RabbitMQ%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<a id="more"></a>
<h5 id="使用RabbitMQ有什么好处？"><a href="#使用RabbitMQ有什么好处？" class="headerlink" title="使用RabbitMQ有什么好处？"></a>使用RabbitMQ有什么好处？</h5><ul>
<li>应用解耦（系统拆分）</li>
<li>异步处理（预约挂号业务处理成功后，异步发送短信、推送消息、日志记录等）</li>
<li>消息分发</li>
<li>流量削峰</li>
<li>消息缓冲</li>
</ul>
<h5 id="使用了消息队列会有什么缺点"><a href="#使用了消息队列会有什么缺点" class="headerlink" title="使用了消息队列会有什么缺点"></a>使用了消息队列会有什么缺点</h5><ul>
<li>系统可用性降低：你想呀，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低</li>
<li>系统复杂性增加：加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，刺痛复杂性增大。</li>
</ul>
<p>但是，我们该用的还是要用的。</p>
<h5 id="如何保证消费的可靠性传输？"><a href="#如何保证消费的可靠性传输？" class="headerlink" title="如何保证消费的可靠性传输？"></a>如何保证消费的可靠性传输？</h5><p>分析：我们在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。如果无法做到可靠性传输，可能给公司带来千万级别的财产损失。同样的，如果可靠性传输在使用过程中，没有考虑到，这不是给公司挖坑麽，你可以拍拍屁股走人，公司损失的钱，谁承担。还是那句话，认真对待每一个项目，不要给公司挖坑。</p>
<p>回答：其实这个可靠性传输，每种MQ都要从三个角度来分析：</p>
<ul>
<li>生产者弄丢数据</li>
<li>消息队列弄丢数据</li>
<li>消费者弄丢数据</li>
</ul>
<p>（1）生产者丢数据<br>从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p>
<p>transaction机制就是说，发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。</p>
<p>然而，这种方式有个缺点：吞吐量下降。因为，按照经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了。如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。处理Ack和Nack的代码如下所示：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">channel.add<span class="constructor">ConfirmListener(<span class="params">new</span> ConfirmListener()</span> &#123;  </span><br><span class="line">                @Override  </span><br><span class="line">                public void handle<span class="constructor">Nack(<span class="params">long</span> <span class="params">deliveryTag</span>, <span class="params">boolean</span> <span class="params">multiple</span>)</span> throws IOException &#123;  </span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"nack: deliveryTag = "</span>+deliveryTag+<span class="string">" multiple: "</span>+multiple);  </span><br><span class="line">                &#125;  </span><br><span class="line">                @Override  </span><br><span class="line">                public void handle<span class="constructor">Ack(<span class="params">long</span> <span class="params">deliveryTag</span>, <span class="params">boolean</span> <span class="params">multiple</span>)</span> throws IOException &#123;  </span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">"ack: deliveryTag = "</span>+deliveryTag+<span class="string">" multiple: "</span>+multiple);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>(2)消息队列丢数据</p>
<p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步</p>
<ol>
<li>将queue的持久化标识durable设置为true,则代表是一个持久的队列</li>
<li>发送消息的时候将deliveryMode=2</li>
</ol>
<p>这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据</p>
<p>（3）消费者丢数据</p>
<p>消费者丢数据一般是因为采用了自动确认消息模式。这种模式下，消费者会自动确认收到信息。这时rabbitMQ会立即将消息删除，这种情况下，如果消费者出现异常而未能处理消息，就会丢失该消息。</p>
<p>至于解决方案，采用手动确认消息即可。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>pinpoint搭建流程</title>
    <url>/2019/03/12/pinpoint%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>​    pinpoint是开源在github上的一款APM监控工具，它是用Java编写的，用于大规模分布式系统监控。它对性能的影响最小（只增加约3％资源利用率），安装agent是无侵入式的，只需要在被测试的Tomcat中加上3句话，打下探针，就可以监控整套程序了。因需求要获取阿里云专有云组件之间的联系，了解到了这个开源项目。我们知道,前端向后台发起一个查询请求，后台服务可能要调用多个服务，每个服务可能又会调用其它服务，最终将结果返回，汇总到页面上。如果某个环节发生异常，工程师很难准确定位这个问题到底是由哪个服务调用造成的，Pinpoint等相关工具的作用就是<strong>追踪每个请求的完整调用链路，收集调用链路上每个服务的性能数据</strong>，方便工程师能够快速定位问题。</p>
<p>​    这个是一个Pinpoint框架结构图 emm。。。看了概述之后这个图还算比较直观 大概意思就是探针agent通过jvm收集应用端监控数据，反馈给collector，collector属于数据收集模块，接收Agent发送过来的监控数据，并存储到HBase，再通过Web UI 监控展示模块，展示系统调用关系、调用详情、应用状态等，并支持报警等功能。</p>
<p>架构说明：</p>
<ul>
<li>Pinpoint-Collector：收集各种性能数据</li>
<li>Pinpoint-Agent：和自己运行的应用关联起来的探针</li>
<li>Pinpoint-Web：将收集到的数据显示成WEB网页形式</li>
<li>HBase Storage：收集到的数据存到HBase中</li>
</ul>
<p><img src="/2019/03/12/pinpoint搭建流程/626593-20161127170110237-2102871440.png" alt="img"></p>
<h3 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h3><p>由于搭建pinpoint需要hbase和使用tomcat等相关测试，所以内存使用比较费，手头没有合适的资源，开了个虚拟机整一个单机环境进行测试和部署。4核8g </p>
<p><strong>jdk1.8</strong><a href="https://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/documentation/jdk8-doc-downloads-2133158.html</a></p>
<p><strong>hbase</strong> 此处下载的是hbase-1.2.9-bin.tar.gz <a href="http://archive.apache.org/dist/hbase/" target="_blank" rel="noopener">http://archive.apache.org/dist/hbase/</a></p>
<p>注意：如果是windows环境下部署，由于Hbase构建在Hadoop HDFS（即Hadoop分布式文件系统 Hadoop Distributed Filesystem）之上，因此Hbase需要Hadoop的支持。刚开始是在windows环境搭建的，那会儿时间比较紧，没来得及整理，反正工具就是这些，如有需要可以再翻阅一下其他的文章。</p>
<p><strong>Hadoop</strong>  支持文件<a href="https://github.com/srccodes/hadoop-common-2.2.0-bin" target="_blank" rel="noopener">https://github.com/srccodes/hadoop-common-2.2.0-bin</a> </p>
<p><strong>pinpoint</strong> github地址<a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">https://github.com/naver/pinpoint</a>  这里使用1.9.0最新版</p>
<p>如果要使用源码部署</p>
<p>下载：git clone <a href="https://github.com/naver/pinpoint.git" target="_blank" rel="noopener">https://github.com/naver/pinpoint.git</a></p>
<p>进入Pinpoint目录后编译(实际使用中需要安装jdk6,7,8,9  也有可能是我自己没解决掉那些问题)：</p>
<p>mvn install -Dmaven.test.skip=true 安装会需要很长时间，耐心的等一会，嗯 大概就2个小时左右吧…</p>
<p>如果不想自己手动打包，则可以下载打包好的。<a href="https://github.com/naver/pinpoint/releases/tag/1.8.2" target="_blank" rel="noopener">https://github.com/naver/pinpoint/releases/tag/1.8.2</a></p>
<h3 id="3-开始搭建"><a href="#3-开始搭建" class="headerlink" title="3.开始搭建"></a>3.开始搭建</h3><h4 id="1、jdk配置"><a href="#1、jdk配置" class="headerlink" title="1、jdk配置"></a>1、jdk配置</h4><p>解压之后环境变量配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash">jdk环境变量</span></span><br><span class="line">export JAVA_HOME=/root/mytools/jdk1.8.0_191</span><br><span class="line">export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">source /etc/profile 使之生效</span><br><span class="line">java -version 验证</span><br></pre></td></tr></table></figure>
<h4 id="2、hbase-配置"><a href="#2、hbase-配置" class="headerlink" title="2、hbase 配置"></a>2、hbase 配置</h4><p>解压后编辑：<code>conf/hbase-env.sh,</code>添加JAVA_HOME配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/root/mytools/jdk1.8.0_191</span><br></pre></td></tr></table></figure>
<p>然后，进行下一项配置，还是在conf文件夹中，找到“hbase-site.xml”文件，编辑此文件，在configuration标签内添加如下配置：<strong>这个文件可以不配置，那么会采取默认值</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///root/mytools/hbase-1.2.9/rootdir<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HBASE_HOME=/root/mytools/hbase-1.2.9</span><br><span class="line">export PATH=$PATH:$HBASE_HOME/bin</span><br></pre></td></tr></table></figure>
<p>启动hbase的时候，hbase用得是自带的zk，在hbase的配置里可见 export HBASE_MANAGES_ZK=true；</p>
<ul>
<li>进入hbase/bin目录启动hbase：./start-hbase.sh</li>
<li>用<code>ps</code>命令查看Hbase是否启动成功，如果启动成功的会看到”HMaster”的进程</li>
<li>初始化pinpoint需要的表：./hbase shell hbase-create.hbase (这里的hbase-create.hbase在源码<code>pinpoint/hbase/scripts/hbase-create.hbase</code>)</li>
<li>访问页面测试是否成功：<a href="http://localhost:16010/master-status" target="_blank" rel="noopener">http://localhost:16010/master-status</a> ，如果成功在页面的tables标签下能看到导入的表。</li>
<li>也可以用命令来查看是否导入表成功，进入hbase，输入”status ‘detailed’”可以查看初始化的表</li>
</ul>
<h4 id="3、pinpoint-collector部署："><a href="#3、pinpoint-collector部署：" class="headerlink" title="3、pinpoint-collector部署："></a>3、pinpoint-collector部署：</h4><p>　　解压apache-tomcat-8.5.34，目录重命名为tomcat-pp-col</p>
<p>　　解压pinpoint-collector-1.9.0-SNAPSHOT.war，并将解压后目录中的META-INF、monitor和WEB-INF目录拷贝到\tomcat-pp-col\webapps\ROOT目录下，覆盖相关文档</p>
<p>　　修改\tomcat-pp-col\conf目录下server.xml中相关端口后，建议在所有端口号前加1，如：18080，18443，18009</p>
<p>　　配置完成后启动Tomcat</p>
<h4 id="4、pinpoint-web部署"><a href="#4、pinpoint-web部署" class="headerlink" title="4、pinpoint-web部署"></a>4、pinpoint-web部署</h4><p>　　解压第二个apache-tomcat-8.5.34，目录重命名为tomcat-pp-web</p>
<p>　　解压pinpoint-web-1.9.0-SNAPSHOT.war，并将解压后目录中的所有目录和文件等拷贝到\tomcat-pp-web\webapps\ROOT目录下，覆盖相关文档</p>
<p>　　修改\tomcat-pp-web\conf目录下server.xml中相关端口后，建议在所有端口号前加2，如：28080，28443，28009</p>
<p>　　配置完成后启动Tomcat</p>
<h4 id="5、pinpoint-agent部署"><a href="#5、pinpoint-agent部署" class="headerlink" title="5、pinpoint-agent部署"></a>5、pinpoint-agent部署</h4><p>　　将pinpoint-agent压缩包pinpoint-agent-1.9.0-SNAPSHOT.tar.gz拷贝到web服务器上并解压，我顺手解压到了Web UI所在的webapps文件夹下 别的地方也可以。在解压后的pinpoint-agent目录中找到pinpoint.config文件，修改Collector server的配置参数，如果web服务和pinpoint系统部署在同一服务器上，profiler.collector.ip可设置为localhost，否则设置为profiler.collector所在服务器ip地址。配置完成后进行保存。</p>
<h4 id="6、web服务器监控配置"><a href="#6、web服务器监控配置" class="headerlink" title="6、web服务器监控配置"></a>6、web服务器监控配置</h4><p>　　web服务器监控这里以Tomcat为例，其他类型后期讲解。</p>
<p>　　在被监测的Tomcat目录\Tomcat\bin下找到catalina.bat文件，使用文本编译器在其中添加如下参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CATALINA_OPTS="$CATALINA_OPTS -javaagent:/root/mytools/tomcat-pp-web/webapps/pinpoint-agent-1.9.0-SNAPSHOT/pinpoint-bootstrap-1.9.0-SNAPSHOT.jar"</span><br><span class="line">CATALINA_OPTS="$CATALINA_OPTS -Dpinpoint.agentId=testAgent"</span><br><span class="line">CATALINA_OPTS="$CATALINA_OPTS -Dpinpoint.applicationName=test"</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p>-javaagent:/root/mytools/tomcat-pp-web/webapps/pinpoint-agent-1.9.0-SNAPSHOT/pinpoint-bootstrap-1.9.0-SNAPSHOT.jar #设置\pinpoint-agent目录下的pinpoint-bootstrap-1.9.0-SNAPSHOT.jar路径</p>
<p>-Dpinpoint.agentId=testAgent #设置被监控程序名称</p>
<p>-Dpinpoint.applicationName=test #设置采集器agent的id名称，全局唯一</p>
<p><strong>注意 pinpoint.agentId 必须全局唯一来标识应用实例， 而所有共用相同 pinpoint.applicationName 的应用被当成单个服务的多个实例。</strong></p>
<h4 id="7、启动collector和web-ui"><a href="#7、启动collector和web-ui" class="headerlink" title="7、启动collector和web ui"></a>7、启动collector和web ui</h4><p>保存成功后启动所有应用到的Tomcat和hbase数据库</p>
<p>Tomcat启动成功后，在部署pinpoint-web服务器的浏览器中输入<a href="http://localhost:28080" target="_blank" rel="noopener">http://localhost:28080</a> 回车</p>
<h3 id="4-进行测试"><a href="#4-进行测试" class="headerlink" title="4.进行测试"></a>4.进行测试</h3><p>部署好pinpoint的基础环境之后开始测试流程  </p>
<p>测试 过程</p>
<p>1.单应用tomcat,配置tomcat中的catalina.sh</p>
<p>通过这种方式可以查到基础组件相关信息 如调用的mysql,redis等组件  数据同步不是很及时 </p>
<p>2.单应用通过内部方式调用别的项目,要在多个tomcat中都配置agent探针,能够监测到内容</p>
<p>3.前后端分离项目 ,做了一个示例是前段项目一个tomcat,后端项目一个tomcat .查看页面信息的时候可以查到内容 但是pinpoint中未显示到关联关系 有待确认pinpoint是否存在该问题</p>
<p>4.分布式多模块项目,部署了基于springcloud的 server client ribbon组件来进行测试 这里只有配置pp-agent的pinpoint.config, RxJava、Hystrix、RestTemplate都为true的时候，pinpoint对于微服务之间的链路监控才能收集到</p>
<h3 id="5-支持的组件"><a href="#5-支持的组件" class="headerlink" title="5.支持的组件"></a>5.支持的组件</h3><ul>
<li>JDK 6+</li>
<li><a href="https://github.com/naver/pinpoint/tree/master/plugins/tomcat" target="_blank" rel="noopener">Tomcat 6/7/8/9</a>, <a href="https://github.com/naver/pinpoint/tree/master/plugins/jetty" target="_blank" rel="noopener">Jetty 8/9</a>, <a href="https://github.com/naver/pinpoint/tree/master/plugins/jboss" target="_blank" rel="noopener">JBoss EAP 6/7</a>, <a href="https://github.com/naver/pinpoint/tree/master/plugins/resin" target="_blank" rel="noopener">Resin 4</a>, <a href="https://github.com/naver/pinpoint/tree/master/plugins/websphere" target="_blank" rel="noopener">Websphere 6/7/8</a>, <a href="https://github.com/naver/pinpoint/tree/master/plugins/vertx" target="_blank" rel="noopener">Vertx 3.3/3.4/3.5</a>, <a href="https://github.com/naver/pinpoint/tree/master/plugins/weblogic" target="_blank" rel="noopener">Weblogic 10/11g/12c</a>, Undertow</li>
<li>Spring, Spring Boot (Embedded Tomcat, Jetty), Spring asynchronous communication</li>
<li>Apache HTTP Client 3.x/4.x, JDK HttpConnector, GoogleHttpClient, OkHttpClient, NingAsyncHttpClient, Akka-http, Apache CXF</li>
<li>Thrift Client, Thrift Service, DUBBO PROVIDER, DUBBO CONSUMER, GRPC</li>
<li>ActiveMQ, RabbitMQ, Kafka</li>
<li>MySQL, Oracle, MSSQL(jtds), CUBRID, POSTGRESQL, MARIA</li>
<li>Arcus, Memcached, Redis(<a href="https://github.com/naver/pinpoint/blob/master/plugins/redis" target="_blank" rel="noopener">Jedis</a>, <a href="https://github.com/naver/pinpoint/tree/master/plugins/redis-lettuce" target="_blank" rel="noopener">Lettuce</a>), CASSANDRA, MongoDB, Hbase</li>
<li>iBATIS, MyBatis</li>
<li>DBCP, DBCP2, HIKARICP, DRUID</li>
<li>gson, Jackson, Json Lib, Fastjson</li>
<li>log4j, Logback</li>
</ul>
<h3 id="6-使用说明"><a href="#6-使用说明" class="headerlink" title="6.使用说明"></a>6.使用说明</h3><p>使用说明转载至：<a href="https://blog.csdn.net/xvshu/article/details/79866237" target="_blank" rel="noopener">https://blog.csdn.net/xvshu/article/details/79866237</a> </p>
<p><img src="/2019/03/12/pinpoint搭建流程/C1552378561502.png" alt="1552378561502"></p>
<h4 id="1-查看调用关系"><a href="#1-查看调用关系" class="headerlink" title="1.查看调用关系"></a>1.查看调用关系</h4><p>1.1 访问地址<br>1.2 选择应用</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409143955665.png" alt="img"></p>
<p>默认两层展示</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144039303.png" alt="img"></p>
<p>调整层级深度：</p>
<p>示例为前端调用4层追溯，后端调用4层追溯（4层为最深层级）</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144116572.png" alt="img"></p>
<p>结果展示：</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144150249.png" alt="img"></p>
<p>在图片内按鼠标滚轮调整图片大小。</p>
<p>连线上数字为调用次数</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144232732.png" alt="img"></p>
<p>选择更多时间范围（默认最新5分钟）</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144257419.png" alt="img"></p>
<h4 id="2-查看调用链"><a href="#2-查看调用链" class="headerlink" title="2.查看调用链"></a>2.查看调用链</h4><p>鼠标按住右键，选中图中区域，松开右键，则展示选中时间段调用层级</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144402245.png" alt="img"></p>
<p>展示结果：</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144435711.png" alt="img"></p>
<p>默认按耗时排序</p>
<p>选中某一调用，展示详细调用链及耗时</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144506725.png" alt="img"></p>
<p>选中timelinetab可查看耗时情况：</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144539835.png" alt="img"></p>
<h4 id="3-查看错误信息"><a href="#3-查看错误信息" class="headerlink" title="3.查看错误信息"></a>3.查看错误信息</h4><p>3.1 选择错误应用</p>
<p>机器应用抛出错误，机器应用会标红</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144622853.png" alt="img"></p>
<p>3.2 查看详细信息<br>选中应用，去除成功多选按钮选中对勾，按住鼠标右键，选中红点范围，松开鼠标右键，即可查看详细错误信息：</p>
<p><img src="/2019/03/12/pinpoint搭建流程/20180409144716826.png" alt="img"></p>
<p>结果为：</p>
<p><img src="/2019/03/12/pinpoint搭建流程/2018040914480155.png" alt="img"></p>
<p>选中某次错误请求，可在详细列表内找到详细错误信息</p>
<h4 id="4-查看应用情况"><a href="#4-查看应用情况" class="headerlink" title="4.查看应用情况"></a>4.查看应用情况</h4><p>选中某一应用<br>单击inspector</p>
<p><img src="/2019/03/12/pinpoint搭建流程/2018040914480155-1552447999517.png" alt="img"></p>
<p>选中某一机器id，时间段，可展示jvm详细信息</p>
<p>其中内容包含：Jvm内存使用情况，Jvm永久带使用占用空间，Cpu使用情况，每秒处理的消息数（S标识操作系统，U标识此应用），Jvm线程情况，单请求平均响应时间等。</p>
<p><strong>参考文章</strong></p>
<p><a href="https://www.cnblogs.com/yyhh/p/6106472.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyhh/p/6106472.html</a></p>
<p><a href="https://blog.csdn.net/heyeqingquan/article/details/74456591" target="_blank" rel="noopener">https://blog.csdn.net/heyeqingquan/article/details/74456591</a></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>EFK部署(单机)</title>
    <url>/2019/03/12/EFK%E9%83%A8%E7%BD%B2-%E5%8D%95%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>EFK不是一个软件，而是一套解决方案，并且都是开源软件，之间互相配合使用，完美衔接，高效的满足了很多场合的应用，是目前主流的一种日志系统。EFK是三个开源软件的缩写，分别表示：Elasticsearch , FileBeat, Kibana , 其中ELasticsearch负责日志保存和搜索，FileBeat负责收集日志，Kibana 负责界面,当然EFK和ELK只有一个区别，那就是EFK把ELK的Logstash替换成了FileBeat，因为Filebeat相对于Logstash来说有2个好处：</p>
<p>1、侵入低，无需修改程序目前任何代码和配置<br>2、相对于Logstash来说性能高，Logstash对于IO占用很大</p>
<p>当然FileBeat也并不是完全好过Logstash，毕竟Logstash对于日志的格式化这些相对FileBeat好很多，FileBeat只是将日志从日志文件中读取出来，当然如果你日志本身是有一定格式的，FileBeat也可以格式化，但是相对于Logstash来说，还是差一点。</p>
<a id="more"></a>
<p><strong>Elasticsearch</strong></p>
<p>Elasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</p>
<p><strong>FileBeat</strong></p>
<p>Filebeat隶属于Beats。目前Beats包含六种工具：<br>Packetbeat（搜集网络流量数据）<br>Metricbeat（搜集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）<br>Filebeat（搜集文件数据）<br>Winlogbeat（搜集 Windows 事件日志数据）<br>Auditbeat（ 轻量型审计日志采集器）<br>Heartbeat（轻量级服务器健康采集器）</p>
<p><strong>Kibana</strong></p>
<p>Kibana可以为 Logstash 、Beats和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。</p>
<h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2.环境准备"></a>2.环境准备</h2><p>CentOS 7.0 64位 4核8G</p>
<p>jdk1.8</p>
<p>EFK下载地址 <a href="https://www.elastic.co/downloads" target="_blank" rel="noopener">https://www.elastic.co/downloads</a></p>
<p>我这里用的都是6.5.1最新稳定版本 elasticsearch-6.5.1,filebeat-6.5.1,kibana-6.5.1</p>
<h2 id="3-JDK-配置"><a href="#3-JDK-配置" class="headerlink" title="3.JDK 配置"></a>3.JDK 配置</h2><p>Elasticsearch需要运行在Java 1.8 及以上，所以需要先安装Java1.8</p>
<p>我这里是下载好的tar包,放在了/usr/local 目录下,解压并配置环境变量</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">tar -xzvf  jdk-8u191-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/usr/java/jdk1.8.0_141</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">CLASSPATH</span>=<span class="variable">$JAVA_HOME</span>/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$JAVA_HOME</span>/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>按 Esc 键退出编辑模式，输入 :wq 保存并关闭文件。<br>加载环境变量：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>
<p>查看 jdk 版本。当出现 jdk 版本信息时，表示 JDK 已经安装成功。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">java version <span class="string">"1.8.0_191"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_191-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit<span class="built_in"> Server </span>VM (build 25.191-b12, mixed mode)</span><br></pre></td></tr></table></figure>
<h2 id="4-安装elasticsearch"><a href="#4-安装elasticsearch" class="headerlink" title="4.安装elasticsearch"></a>4.安装elasticsearch</h2><p>我这里新建了一个文件夹去管理EFK</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">├── efk</span><br><span class="line">│   ├── elasticsearch-<span class="number">6.5</span>.<span class="number">1</span></span><br><span class="line">│   │   ├── bin</span><br><span class="line">│   │   ├── config</span><br><span class="line">│   │   ├── data</span><br><span class="line">│   │   ├── lib</span><br><span class="line">│   │   ├── LICENSE.txt</span><br><span class="line">│   │   ├── logs</span><br><span class="line">│   │   ├── modules</span><br><span class="line">│   │   ├── NOTICE.txt</span><br><span class="line">│   │   ├── plugins</span><br><span class="line">│   │   └── README.textile</span><br><span class="line">│   ├── filebeat-<span class="number">6.5</span>.<span class="number">1</span>-linux-x86_64</span><br><span class="line">│   │   ├── data</span><br><span class="line">│   │   ├── fields.yml</span><br><span class="line">│   │   ├── filebeat</span><br><span class="line">│   │   ├── filebeat<span class="selector-class">.reference</span><span class="selector-class">.yml</span></span><br><span class="line">│   │   ├── filebeat.yml</span><br><span class="line">│   │   ├── kibana</span><br><span class="line">│   │   ├── LICENSE.txt</span><br><span class="line">│   │   ├── logs</span><br><span class="line">│   │   ├── module</span><br><span class="line">│   │   ├── modules.d</span><br><span class="line">│   │   ├── NOTICE.txt</span><br><span class="line">│   │   └── README.md</span><br><span class="line">│   ├── kibana-<span class="number">6.5</span>.<span class="number">1</span>-linux-x86_64</span><br><span class="line">│   │   ├── bin</span><br><span class="line">│   │   ├── config</span><br><span class="line">│   │   ├── data</span><br><span class="line">│   │   ├── LICENSE.txt</span><br><span class="line">│   │   ├── logs</span><br><span class="line">│   │   ├── node</span><br><span class="line">│   │   ├── node_modules</span><br><span class="line">│   │   ├── NOTICE.txt</span><br><span class="line">│   │   ├── optimize</span><br><span class="line">│   │   ├── package.json</span><br><span class="line">│   │   ├── plugins</span><br><span class="line">│   │   ├── README.txt</span><br><span class="line">│   │   ├── src</span><br><span class="line">│   │   └── webpackShims</span><br><span class="line">└── testlog</span><br><span class="line">    ├── <span class="selector-tag">a</span>.out</span><br><span class="line">    └── catalina.<span class="number">2018</span>-<span class="number">11</span>-<span class="number">28</span>.log</span><br></pre></td></tr></table></figure>
<h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>由于Elasticsearch不能使用root用户打开，所以需要专门创建一个用户来启动Elasticsearch并赋予权限</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">groupadd</span> <span class="string">efk</span></span><br><span class="line"></span><br><span class="line"><span class="attr">useradd</span> <span class="string">efk -g efk -p efk</span></span><br><span class="line"></span><br><span class="line"><span class="attr">chown</span> <span class="string">-R efk:efk EFK</span></span><br></pre></td></tr></table></figure>
<h3 id="创建data数据目录和日志目录"><a href="#创建data数据目录和日志目录" class="headerlink" title="创建data数据目录和日志目录"></a>创建data数据目录和日志目录</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">su</span> <span class="string">efk</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">data/esdata </span></span><br><span class="line"></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">alllogs/eslog</span></span><br></pre></td></tr></table></figure>
<h3 id="解压elasticsearch"><a href="#解压elasticsearch" class="headerlink" title="解压elasticsearch"></a>解压elasticsearch</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-xzvf</span> <span class="selector-tag">elasticsearch-6</span><span class="selector-class">.5</span><span class="selector-class">.1</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<p>进入elasticsearch主目录</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">vim <span class="built_in">config</span>/elasticsearch.yml</span><br></pre></td></tr></table></figure>
<p>因为是单机 所以只配了下面几个属性</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">http.port: <span class="number">9200</span></span><br><span class="line">path.data: /myproject/efk/elasticsearch<span class="number">-6.5</span><span class="number">.1</span>/data</span><br><span class="line">path.logs: /myproject/efk/elasticsearch<span class="number">-6.5</span><span class="number">.1</span>/logs</span><br><span class="line">network.host: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<h3 id="elasticsearch控制台中文乱码和jvm大小调节乱码问题"><a href="#elasticsearch控制台中文乱码和jvm大小调节乱码问题" class="headerlink" title="elasticsearch控制台中文乱码和jvm大小调节乱码问题"></a>elasticsearch控制台中文乱码和jvm大小调节乱码问题</h3><p>修改conf下面的jvm.options如下</p>
<figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="literal">-Xms256m</span></span><br><span class="line"><span class="literal">-Xmx256m</span></span><br><span class="line"><span class="comment"># ensure UTF-8 encoding by default (e.g. filenames)</span></span><br><span class="line"><span class="comment">#-Dfile.encoding=UTF-8</span></span><br><span class="line"><span class="literal">-Dfile.encoding=GBK</span></span><br></pre></td></tr></table></figure>
<h3 id="es主要配置说明"><a href="#es主要配置说明" class="headerlink" title="es主要配置说明"></a>es主要配置说明</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#集群主节点名称</span></span><br><span class="line"></span><br><span class="line">cluster.name: mymaster   </span><br><span class="line"></span><br><span class="line"><span class="keyword">node</span>.name:<span class="title"> es-1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 是否为master</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">node</span>.master:<span class="title"> true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否为数据节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">node</span>.data:<span class="title"> true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据目录</span></span><br><span class="line"></span><br><span class="line">path.data: /myproject/efk/elasticsearch-<span class="number">6.5</span>.<span class="number">1</span>/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志目录</span></span><br><span class="line"></span><br><span class="line">path.logs: /myproject/efk/elasticsearch-<span class="number">6.5</span>.<span class="number">1</span>/logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本机IP</span></span><br><span class="line"></span><br><span class="line">network.host: <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本机http端口</span></span><br><span class="line"></span><br><span class="line">http.port: <span class="number">9200</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定集群中的节点中有几个有master资格的节点</span></span><br><span class="line"></span><br><span class="line">discovery.zen.minimum_master_nodes: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定集群中其他节点的IP</span></span><br><span class="line"></span><br><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">"10.168.1.44"</span>,<span class="string">"10.168.0.126"</span>,<span class="string">"10.168.0.127"</span>,<span class="string">"10.168.0.128"</span>,<span class="string">"10.168.0.130"</span>]</span><br></pre></td></tr></table></figure>
<h3 id="启动Elasticsearch"><a href="#启动Elasticsearch" class="headerlink" title="启动Elasticsearch"></a>启动Elasticsearch</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">.<span class="regexp">/bin/</span>elasticsearch</span><br></pre></td></tr></table></figure>
<h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./elasticsearch</span> -d</span><br></pre></td></tr></table></figure>
<h3 id="查找ES进程"><a href="#查找ES进程" class="headerlink" title="查找ES进程"></a>查找ES进程</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> elastic</span><br></pre></td></tr></table></figure>
<h3 id="杀掉ES进程"><a href="#杀掉ES进程" class="headerlink" title="杀掉ES进程"></a>杀掉ES进程</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">kill <span class="number">-9</span> <span class="number">2382</span>（进程号）</span><br></pre></td></tr></table></figure>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>如果遇到错误：max file descriptors [65535] for elasticsearch process is too low, increase to at least [65536]</p>
<p>vi /etc/security/limits.conf  </p>
<p>如果有 <em> soft nofile 65535 </em> hard nofile 65535 则将65535修改为65536，如果没有则在后面添加，注意此处的65535对应descriptors [65535]中的65535，修改后的值65536对应increase to at least [65536]，所以当提示不一致时，需要根据具体的错误提示具体修改</p>
<p>如果遇到错误： max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vi</span> /etc/sysctl.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<p>添加配置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">vm.max_map_count</span>=<span class="number">262144</span></span><br></pre></td></tr></table></figure>
<p>并执行命令</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sysctl -p</span></span><br></pre></td></tr></table></figure>
<p>以上2个修改需要在root用户权限修改，如果是使用xshell开两个窗口的话修改完成之后一定要断开重新登录一下，启动成功用执行命令</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">curl <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span></span><br></pre></td></tr></table></figure>
<p>会得到类似以下json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"JEBFbUB"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span> : <span class="string">"tDw_Tk9rSyevhkazjbVa0Q"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"6.5.1"</span>,</span><br><span class="line">    <span class="attr">"build_flavor"</span> : <span class="string">"default"</span>,</span><br><span class="line">    <span class="attr">"build_type"</span> : <span class="string">"tar"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"8c58350"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span> : <span class="string">"2018-11-16T02:22:42.182257Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"7.5.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-安装kibana"><a href="#5-安装kibana" class="headerlink" title="5.安装kibana"></a>5.安装kibana</h2><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-xzvf</span> <span class="selector-tag">kibana-6</span><span class="selector-class">.5</span><span class="selector-class">.1-linux-x86_64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">vim <span class="built_in">config</span>/kibana.yml</span><br></pre></td></tr></table></figure>
<h3 id="添加以下配置或者取消注释并修改"><a href="#添加以下配置或者取消注释并修改" class="headerlink" title="添加以下配置或者取消注释并修改"></a>添加以下配置或者取消注释并修改</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">logging<span class="selector-class">.dest</span>: /myproject/efk/kibana-<span class="number">6.5</span>.<span class="number">1</span>-linux-x86_64/logs/kibana.log</span><br><span class="line">elasticsearch<span class="selector-class">.url</span>: <span class="string">"http://127.0.0.1:9200"</span></span><br><span class="line">server<span class="selector-class">.host</span>: <span class="string">"0.0.0.0"</span></span><br><span class="line">kibana<span class="selector-class">.index</span>: <span class="string">".kibana"</span></span><br></pre></td></tr></table></figure>
<p>其中elasticsearch.url为Elasticsearch的地址，server.host默认是localhost，如果只是本地访问可以默认localhost，如果需要外网访问，可以设置为0.0.0.0</p>
<h3 id="如果外网不能访问-开放端口号"><a href="#如果外网不能访问-开放端口号" class="headerlink" title="如果外网不能访问,开放端口号"></a>如果外网不能访问,开放端口号</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--query-port</span>=80/tcp</span><br><span class="line"><span class="comment">#查看5601是否占用</span></span><br><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--query-port</span>=5601/tcp</span><br><span class="line"><span class="comment">#添加5601</span></span><br><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=5601/tcp --permanent</span><br><span class="line"><span class="comment">#重载</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment">#再次查看5601是否占用</span></span><br><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--query-port</span>=5601/tcp</span><br></pre></td></tr></table></figure>
<h3 id="后台启动-1"><a href="#后台启动-1" class="headerlink" title="后台启动"></a>后台启动</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">nohup ./bin/kibana &gt; logs/kibana.<span class="built_in">log</span> <span class="meta">&amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="查找ES进程-1"><a href="#查找ES进程-1" class="headerlink" title="查找ES进程"></a>查找ES进程</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure>
<h3 id="杀掉ES进程-1"><a href="#杀掉ES进程-1" class="headerlink" title="杀掉ES进程"></a>杀掉ES进程</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">kill <span class="number">-9</span> <span class="number">2382</span></span><br></pre></td></tr></table></figure>
<h3 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h3><p><a href="http://10.146.247.161:8080" target="_blank" rel="noopener">http://10.146.247.161:8080</a></p>
<h2 id="6-FileBeat安装"><a href="#6-FileBeat安装" class="headerlink" title="6. FileBeat安装"></a>6. FileBeat安装</h2><h3 id="解压-1"><a href="#解压-1" class="headerlink" title="解压"></a>解压</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-xzvf</span> <span class="selector-tag">filebeat-6</span><span class="selector-class">.5</span><span class="selector-class">.1-linux-x86_64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span> filebeat.yml</span><br><span class="line">filebeat.<span class="built_in">input</span><span class="variable">s:</span></span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: true  #默认此处为false  要改成true才会生效 </span><br><span class="line">  path<span class="variable">s:</span></span><br><span class="line">    - /myproject/testlog/*.<span class="built_in">log</span></span><br><span class="line">    - /myproject/testlog/*.out</span><br><span class="line">  multiline.pattern: ^\[</span><br><span class="line">  multiline.negate: true</span><br><span class="line">  multiline.<span class="keyword">match</span>: after</span><br><span class="line">setup.kiban<span class="variable">a:</span></span><br><span class="line">  hos<span class="variable">t:</span> <span class="string">"127.0.0.1:5601"</span></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  host<span class="variable">s:</span> [<span class="string">"127.0.0.1:9200"</span>]</span><br></pre></td></tr></table></figure>
<p>配置一定要注意格式，是以2个空格为子级，里面的配置都在配置文件中，列出来的只是要修改的部分，<strong>enabled默认为false，需要改成true才会收集日志。</strong>其中/myproject/test/*.log修改为自己的日志路径，注意-后面有一个空格，如果多个路径则添加一行，一定要注意新行前面的4个空格，multiline开头的几个配置取消注释就行了，是为了兼容多行日志的情况，setup.kibana中的host取消注释，根据实际情况配置地址，output.elasticsearch中的host也一样，根据实际情况配置</p>
<h3 id="启动filebeat"><a href="#启动filebeat" class="headerlink" title="启动filebeat"></a>启动filebeat</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./filebeat</span> -e -c filebeat.yml</span><br></pre></td></tr></table></figure>
<p>常用的filebeat命令：</p>
<p>-E, –E “SETTING_NAME=VALUE”</p>
<p>覆盖特定的配置设置。 您可以指定多个覆盖。 例如： </p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">filebeat -<span class="keyword">E</span> <span class="string">"name=mybeat"</span> -<span class="keyword">E</span> <span class="string">"output.elasticsearch.hosts=["</span>http://myhost:<span class="number">9200</span><span class="string">"]"</span></span><br></pre></td></tr></table></figure>
<p>此设置适用于当前正在运行的Filebeat进程。 Filebeat配置文件不会更改。</p>
<p>-c, –c FILE</p>
<p>指定用于Filebeat的配置文件。 你在这里指定的文件是相对于path.config。 如果未指定-c标志，则使用默认配置文件filebeat.yml。</p>
<p>-d, –d SELECTORS</p>
<p>启用对指定选择器的调试。 对于选择器，可以指定逗号分隔的组件列表，也可以使用-d“*”为所有组件启用调试。 例如，-d“publish”显示所有“publish”相关的消息。</p>
<p>-e, –e</p>
<p>记录到stderr并禁用syslog /文件输出。</p>
<p>-v, –v</p>
<p>记录INFO级别的消息。</p>
<p>./filebeat -configtest 测试配置文件</p>
<p>./filebeat -httpprof[(host)]:(port):启动http服务器进行性能分析</p>
<p>-memprofile (output file) :将存储器配置文件写入指定的输出文件</p>
<p>-path.config : 设置配置的默认位置</p>
<p>-path.data : 设置数据文件的默认位置</p>
<p>-path.home : 设置其他文件的默认位置</p>
<p>-path.logs : 设置日志文件的默认位置</p>
<p>测试filebeat启动后，查看相关输出信息：</p>
<p>./filebeat -e -c filebeat.yml -d “publish”</p>
<h3 id="后台方式启动filebeat："><a href="#后台方式启动filebeat：" class="headerlink" title="后台方式启动filebeat："></a>后台方式启动filebeat：</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">nohup ./filebeat -e -c filebeat<span class="selector-class">.yml</span> &gt; logs/filebeat<span class="selector-class">.out</span> &amp;</span><br></pre></td></tr></table></figure>
<h3 id="查找进程ID并kill掉："><a href="#查找进程ID并kill掉：" class="headerlink" title="查找进程ID并kill掉："></a>查找进程ID并kill掉：</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ps -ef |grep filebeat</span><br><span class="line">kill <span class="number">-9</span> <span class="number">2233</span></span><br></pre></td></tr></table></figure>
<p>/usr/local/filebeat/filebeat.yml为filebeat 的配置文件地址，需要根据实际情况修改，启动后FileBeat就会自动收集日志了</p>
<h2 id="7-配置Kibana"><a href="#7-配置Kibana" class="headerlink" title="7.配置Kibana"></a>7.配置Kibana</h2><p>进入 <a href="http://10.146.247.161:8080" target="_blank" rel="noopener">http://10.146.247.161:8080</a></p>
<p>点击Management进入配置</p>
<p>点击进入Index Patterns</p>
<p>FileBeat默认创建的Elasticsearch索引格式为filebeat-版本号-日期</p>
<p>在第一个红框的输入框中输入</p>
<p>filebeat-6.5.1-*</p>
<p>能匹配到Elasticsearch的索引，第二个红框出会显示出Elasticsearch中已有的索引，点击Next step进入下一步,</p>
<p>点击Create index pattern完成配置，配置完成后点击 Discover就能查看日志了，还能搜索</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过Filebeat读取配置目录下的log文件,从kibana页面搜索结果</p>
<p>e.g</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">cd /myproject/test/</span><br><span class="line"></span><br><span class="line">vim <span class="selector-tag">a</span>.log</span><br><span class="line"></span><br><span class="line">teststststststtststs</span><br></pre></td></tr></table></figure>
<p>wq保存之后 在kibana查询</p>
<p>teststststststtststs即可查询到结果</p>
<p>EFK搭建完毕.</p>
<p>EFK使用方式后续补充</p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>EFK</tag>
      </tags>
  </entry>
</search>
